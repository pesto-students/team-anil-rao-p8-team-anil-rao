{"ast":null,"code":"import { logger } from '@sentry/utils';\nimport { wrapTransactionWithProfiling } from './hubextensions.js';\nimport { PROFILE_MAP, findProfiledTransactionsFromEnvelope, createProfilingEvent, addProfilesToEnvelope } from './utils.js';\n\n/**\n * Browser profiling integration. Stores any event that has contexts[\"profile\"][\"profile_id\"]\n * This exists because we do not want to await async profiler.stop calls as transaction.finish is called\n * in a synchronous context. Instead, we handle sending the profile async from the promise callback and\n * rely on being able to pull the event from the cache when we need to construct the envelope. This makes the\n * integration less reliable as we might be dropping profiles when the cache is full.\n *\n * @experimental\n */\nclass BrowserProfilingIntegration {\n  constructor() {\n    BrowserProfilingIntegration.prototype.__init.call(this);\n    BrowserProfilingIntegration.prototype.__init2.call(this);\n  }\n  __init() {\n    this.name = 'BrowserProfilingIntegration';\n  }\n  __init2() {\n    this.getCurrentHub = undefined;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setupOnce(addGlobalEventProcessor, getCurrentHub) {\n    this.getCurrentHub = getCurrentHub;\n    const client = this.getCurrentHub().getClient();\n    if (client && typeof client.on === 'function') {\n      client.on('startTransaction', transaction => {\n        wrapTransactionWithProfiling(transaction);\n      });\n      client.on('beforeEnvelope', envelope => {\n        // if not profiles are in queue, there is nothing to add to the envelope.\n        if (!PROFILE_MAP['size']) {\n          return;\n        }\n        const profiledTransactionEvents = findProfiledTransactionsFromEnvelope(envelope);\n        if (!profiledTransactionEvents.length) {\n          return;\n        }\n        const profilesToAddToEnvelope = [];\n        for (const profiledTransaction of profiledTransactionEvents) {\n          const context = profiledTransaction && profiledTransaction.contexts;\n          const profile_id = context && context['profile'] && context['profile']['profile_id'];\n          if (!profile_id) {\n            (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Profiling] cannot find profile for a transaction without a profile context');\n            continue;\n          }\n\n          // Remove the profile from the transaction context before sending, relay will take care of the rest.\n          if (context && context['profile']) {\n            delete context.profile;\n          }\n          const profile = PROFILE_MAP.get(profile_id);\n          if (!profile) {\n            (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Profiling] Could not retrieve profile for transaction: ${profile_id}`);\n            continue;\n          }\n          PROFILE_MAP.delete(profile_id);\n          const profileEvent = createProfilingEvent(profile_id, profile, profiledTransaction);\n          if (profileEvent) {\n            profilesToAddToEnvelope.push(profileEvent);\n          }\n        }\n        addProfilesToEnvelope(envelope, profilesToAddToEnvelope);\n      });\n    } else {\n      logger.warn('[Profiling] Client does not support hooks, profiling will be disabled');\n    }\n  }\n}\nexport { BrowserProfilingIntegration };","map":{"version":3,"names":["BrowserProfilingIntegration","constructor","prototype","__init","call","__init2","name","getCurrentHub","undefined","setupOnce","addGlobalEventProcessor","client","getClient","on","transaction","wrapTransactionWithProfiling","envelope","PROFILE_MAP","profiledTransactionEvents","findProfiledTransactionsFromEnvelope","length","profilesToAddToEnvelope","profiledTransaction","context","contexts","profile_id","__SENTRY_DEBUG__","logger","log","profile","get","delete","profileEvent","createProfilingEvent","push","addProfilesToEnvelope","warn"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/src/profiling/integration.ts"],"sourcesContent":["import type { EventProcessor, Hub, Integration, Transaction } from '@sentry/types';\nimport type { Profile } from '@sentry/types/src/profiling';\nimport { logger } from '@sentry/utils';\n\nimport type { BrowserClient } from './../client';\nimport { wrapTransactionWithProfiling } from './hubextensions';\nimport type { ProfiledEvent } from './utils';\nimport {\n  addProfilesToEnvelope,\n  createProfilingEvent,\n  findProfiledTransactionsFromEnvelope,\n  PROFILE_MAP,\n} from './utils';\n\n/**\n * Browser profiling integration. Stores any event that has contexts[\"profile\"][\"profile_id\"]\n * This exists because we do not want to await async profiler.stop calls as transaction.finish is called\n * in a synchronous context. Instead, we handle sending the profile async from the promise callback and\n * rely on being able to pull the event from the cache when we need to construct the envelope. This makes the\n * integration less reliable as we might be dropping profiles when the cache is full.\n *\n * @experimental\n */\nexport class BrowserProfilingIntegration implements Integration {\n  public readonly name: string = 'BrowserProfilingIntegration';\n  public getCurrentHub?: () => Hub = undefined;\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    this.getCurrentHub = getCurrentHub;\n    const client = this.getCurrentHub().getClient() as BrowserClient;\n\n    if (client && typeof client.on === 'function') {\n      client.on('startTransaction', (transaction: Transaction) => {\n        wrapTransactionWithProfiling(transaction);\n      });\n\n      client.on('beforeEnvelope', (envelope): void => {\n        // if not profiles are in queue, there is nothing to add to the envelope.\n        if (!PROFILE_MAP['size']) {\n          return;\n        }\n\n        const profiledTransactionEvents = findProfiledTransactionsFromEnvelope(envelope);\n        if (!profiledTransactionEvents.length) {\n          return;\n        }\n\n        const profilesToAddToEnvelope: Profile[] = [];\n\n        for (const profiledTransaction of profiledTransactionEvents) {\n          const context = profiledTransaction && profiledTransaction.contexts;\n          const profile_id = context && context['profile'] && (context['profile']['profile_id'] as string);\n\n          if (!profile_id) {\n            __DEBUG_BUILD__ &&\n              logger.log('[Profiling] cannot find profile for a transaction without a profile context');\n            continue;\n          }\n\n          // Remove the profile from the transaction context before sending, relay will take care of the rest.\n          if (context && context['profile']) {\n            delete context.profile;\n          }\n\n          const profile = PROFILE_MAP.get(profile_id);\n          if (!profile) {\n            __DEBUG_BUILD__ && logger.log(`[Profiling] Could not retrieve profile for transaction: ${profile_id}`);\n            continue;\n          }\n\n          PROFILE_MAP.delete(profile_id);\n          const profileEvent = createProfilingEvent(profile_id, profile, profiledTransaction as ProfiledEvent);\n\n          if (profileEvent) {\n            profilesToAddToEnvelope.push(profileEvent);\n          }\n        }\n\n        addProfilesToEnvelope(envelope, profilesToAddToEnvelope);\n      });\n    } else {\n      logger.warn('[Profiling] Client does not support hooks, profiling will be disabled');\n    }\n  }\n}\n"],"mappings":";;;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAAA,2BAAA;EAAAC,YAAA;IAAAD,2BAAA,CAAAE,SAAA,CAAAC,MAAA,CAAAC,IAAA;IAAAJ,2BAAA,CAAAE,SAAA,CAAAG,OAAA,CAAAD,IAAA;EAAA;EACAD,OAAA;IAAA,KAAAG,IAAA;EAAA;EACAD,QAAA;IAAA,KAAAE,aAAA,GAAAC,SAAA;EAAA;;EAEA;AACA;AACA;EACAC,UAAAC,uBAAA,EAAAH,aAAA;IACA,KAAAA,aAAA,GAAAA,aAAA;IACA,MAAAI,MAAA,QAAAJ,aAAA,GAAAK,SAAA;IAEA,IAAAD,MAAA,WAAAA,MAAA,CAAAE,EAAA;MACAF,MAAA,CAAAE,EAAA,qBAAAC,WAAA;QACAC,4BAAA,CAAAD,WAAA;MACA;MAEAH,MAAA,CAAAE,EAAA,mBAAAG,QAAA;QACA;QACA,KAAAC,WAAA;UACA;QACA;QAEA,MAAAC,yBAAA,GAAAC,oCAAA,CAAAH,QAAA;QACA,KAAAE,yBAAA,CAAAE,MAAA;UACA;QACA;QAEA,MAAAC,uBAAA;QAEA,WAAAC,mBAAA,IAAAJ,yBAAA;UACA,MAAAK,OAAA,GAAAD,mBAAA,IAAAA,mBAAA,CAAAE,QAAA;UACA,MAAAC,UAAA,GAAAF,OAAA,IAAAA,OAAA,eAAAA,OAAA;UAEA,KAAAE,UAAA;YACA,QAAAC,gBAAA,oBAAAA,gBAAA,KACAC,MAAA,CAAAC,GAAA;YACA;UACA;;UAEA;UACA,IAAAL,OAAA,IAAAA,OAAA;YACA,OAAAA,OAAA,CAAAM,OAAA;UACA;UAEA,MAAAA,OAAA,GAAAZ,WAAA,CAAAa,GAAA,CAAAL,UAAA;UACA,KAAAI,OAAA;YACA,QAAAH,gBAAA,oBAAAA,gBAAA,KAAAC,MAAA,CAAAC,GAAA,4DAAAH,UAAA;YACA;UACA;UAEAR,WAAA,CAAAc,MAAA,CAAAN,UAAA;UACA,MAAAO,YAAA,GAAAC,oBAAA,CAAAR,UAAA,EAAAI,OAAA,EAAAP,mBAAA;UAEA,IAAAU,YAAA;YACAX,uBAAA,CAAAa,IAAA,CAAAF,YAAA;UACA;QACA;QAEAG,qBAAA,CAAAnB,QAAA,EAAAK,uBAAA;MACA;IACA;MACAM,MAAA,CAAAS,IAAA;IACA;EACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}