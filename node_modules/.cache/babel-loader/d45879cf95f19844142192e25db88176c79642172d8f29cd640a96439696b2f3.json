{"ast":null,"code":"import { isString } from './is.js';\nimport { logger, CONSOLE_LEVELS } from './logger.js';\nimport { fill } from './object.js';\nimport { getFunctionName } from './stacktrace.js';\nimport { supportsNativeFetch } from './supports.js';\nimport { getGlobalObject } from './worldwide.js';\nimport { supportsHistory } from './vendor/supportsHistory.js';\n\n// eslint-disable-next-line deprecation/deprecation\nconst WINDOW = getGlobalObject();\nconst SENTRY_XHR_DATA_KEY = '__sentry_xhr_v2__';\n\n/**\n * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.\n *  - Console API\n *  - Fetch API\n *  - XHR API\n *  - History API\n *  - DOM API (click/typing)\n *  - Error API\n *  - UnhandledRejection API\n */\n\nconst handlers = {};\nconst instrumented = {};\n\n/** Instruments given API */\nfunction instrument(type) {\n  if (instrumented[type]) {\n    return;\n  }\n  instrumented[type] = true;\n  switch (type) {\n    case 'console':\n      instrumentConsole();\n      break;\n    case 'dom':\n      instrumentDOM();\n      break;\n    case 'xhr':\n      instrumentXHR();\n      break;\n    case 'fetch':\n      instrumentFetch();\n      break;\n    case 'history':\n      instrumentHistory();\n      break;\n    case 'error':\n      instrumentError();\n      break;\n    case 'unhandledrejection':\n      instrumentUnhandledRejection();\n      break;\n    default:\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('unknown instrumentation type:', type);\n      return;\n  }\n}\n\n/**\n * Add handler that will be called when given type of instrumentation triggers.\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addInstrumentationHandler(type, callback) {\n  handlers[type] = handlers[type] || [];\n  handlers[type].push(callback);\n  instrument(type);\n}\n\n/** JSDoc */\nfunction triggerHandlers(type, data) {\n  if (!type || !handlers[type]) {\n    return;\n  }\n  for (const handler of handlers[type] || []) {\n    try {\n      handler(data);\n    } catch (e) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error(`Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`, e);\n    }\n  }\n}\n\n/** JSDoc */\nfunction instrumentConsole() {\n  if (!('console' in WINDOW)) {\n    return;\n  }\n  CONSOLE_LEVELS.forEach(function (level) {\n    if (!(level in WINDOW.console)) {\n      return;\n    }\n    fill(WINDOW.console, level, function (originalConsoleMethod) {\n      return function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        triggerHandlers('console', {\n          args,\n          level\n        });\n\n        // this fails for some browsers. :(\n        if (originalConsoleMethod) {\n          originalConsoleMethod.apply(WINDOW.console, args);\n        }\n      };\n    });\n  });\n}\n\n/** JSDoc */\nfunction instrumentFetch() {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n  fill(WINDOW, 'fetch', function (originalFetch) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      const {\n        method,\n        url\n      } = parseFetchArgs(args);\n      const handlerData = {\n        args,\n        fetchData: {\n          method,\n          url\n        },\n        startTimestamp: Date.now()\n      };\n      triggerHandlers('fetch', {\n        ...handlerData\n      });\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalFetch.apply(WINDOW, args).then(response => {\n        triggerHandlers('fetch', {\n          ...handlerData,\n          endTimestamp: Date.now(),\n          response\n        });\n        return response;\n      }, error => {\n        triggerHandlers('fetch', {\n          ...handlerData,\n          endTimestamp: Date.now(),\n          error\n        });\n        // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n        //       it means the sentry.javascript SDK caught an error invoking your application code.\n        //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n        throw error;\n      });\n    };\n  });\n}\nfunction hasProp(obj, prop) {\n  return !!obj && typeof obj === 'object' && !!obj[prop];\n}\nfunction getUrlFromResource(resource) {\n  if (typeof resource === 'string') {\n    return resource;\n  }\n  if (!resource) {\n    return '';\n  }\n  if (hasProp(resource, 'url')) {\n    return resource.url;\n  }\n  if (resource.toString) {\n    return resource.toString();\n  }\n  return '';\n}\n\n/**\n * Parses the fetch arguments to find the used Http method and the url of the request\n */\nfunction parseFetchArgs(fetchArgs) {\n  if (fetchArgs.length === 0) {\n    return {\n      method: 'GET',\n      url: ''\n    };\n  }\n  if (fetchArgs.length === 2) {\n    const [url, options] = fetchArgs;\n    return {\n      url: getUrlFromResource(url),\n      method: hasProp(options, 'method') ? String(options.method).toUpperCase() : 'GET'\n    };\n  }\n  const arg = fetchArgs[0];\n  return {\n    url: getUrlFromResource(arg),\n    method: hasProp(arg, 'method') ? String(arg.method).toUpperCase() : 'GET'\n  };\n}\n\n/** JSDoc */\nfunction instrumentXHR() {\n  if (!('XMLHttpRequest' in WINDOW)) {\n    return;\n  }\n  const xhrproto = XMLHttpRequest.prototype;\n  fill(xhrproto, 'open', function (originalOpen) {\n    return function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      const url = args[1];\n      const xhrInfo = this[SENTRY_XHR_DATA_KEY] = {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        method: isString(args[0]) ? args[0].toUpperCase() : args[0],\n        url: args[1],\n        request_headers: {}\n      };\n\n      // if Sentry key appears in URL, don't capture it as a request\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (isString(url) && xhrInfo.method === 'POST' && url.match(/sentry_key/)) {\n        this.__sentry_own_request__ = true;\n      }\n      const onreadystatechangeHandler = () => {\n        // For whatever reason, this is not the same instance here as from the outer method\n        const xhrInfo = this[SENTRY_XHR_DATA_KEY];\n        if (!xhrInfo) {\n          return;\n        }\n        if (this.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = this.status;\n          } catch (e) {\n            /* do nothing */\n          }\n          triggerHandlers('xhr', {\n            args: args,\n            endTimestamp: Date.now(),\n            startTimestamp: Date.now(),\n            xhr: this\n          });\n        }\n      };\n      if ('onreadystatechange' in this && typeof this.onreadystatechange === 'function') {\n        fill(this, 'onreadystatechange', function (original) {\n          return function () {\n            onreadystatechangeHandler();\n            for (var _len4 = arguments.length, readyStateArgs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n              readyStateArgs[_key4] = arguments[_key4];\n            }\n            return original.apply(this, readyStateArgs);\n          };\n        });\n      } else {\n        this.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      // Intercepting `setRequestHeader` to access the request headers of XHR instance.\n      // This will only work for user/library defined headers, not for the default/browser-assigned headers.\n      // Request cookies are also unavailable for XHR, as `Cookie` header can't be defined by `setRequestHeader`.\n      fill(this, 'setRequestHeader', function (original) {\n        return function () {\n          for (var _len5 = arguments.length, setRequestHeaderArgs = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n            setRequestHeaderArgs[_key5] = arguments[_key5];\n          }\n          const [header, value] = setRequestHeaderArgs;\n          const xhrInfo = this[SENTRY_XHR_DATA_KEY];\n          if (xhrInfo) {\n            xhrInfo.request_headers[header.toLowerCase()] = value;\n          }\n          return original.apply(this, setRequestHeaderArgs);\n        };\n      });\n      return originalOpen.apply(this, args);\n    };\n  });\n  fill(xhrproto, 'send', function (originalSend) {\n    return function () {\n      const sentryXhrData = this[SENTRY_XHR_DATA_KEY];\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      if (sentryXhrData && args[0] !== undefined) {\n        sentryXhrData.body = args[0];\n      }\n      triggerHandlers('xhr', {\n        args,\n        startTimestamp: Date.now(),\n        xhr: this\n      });\n      return originalSend.apply(this, args);\n    };\n  });\n}\nlet lastHref;\n\n/** JSDoc */\nfunction instrumentHistory() {\n  if (!supportsHistory()) {\n    return;\n  }\n  const oldOnPopState = WINDOW.onpopstate;\n  WINDOW.onpopstate = function () {\n    const to = WINDOW.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n    triggerHandlers('history', {\n      from,\n      to\n    });\n    if (oldOnPopState) {\n      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.\n      // https://github.com/getsentry/sentry-javascript/issues/3344\n      // https://github.com/bugsnag/bugsnag-js/issues/469\n      try {\n        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n          args[_key7] = arguments[_key7];\n        }\n        return oldOnPopState.apply(this, args);\n      } catch (_oO) {\n        // no-empty\n      }\n    }\n  };\n\n  /** @hidden */\n  function historyReplacementFunction(originalHistoryFunction) {\n    return function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        triggerHandlers('history', {\n          from,\n          to\n        });\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n  fill(WINDOW.history, 'pushState', historyReplacementFunction);\n  fill(WINDOW.history, 'replaceState', historyReplacementFunction);\n}\nconst debounceDuration = 1000;\nlet debounceTimerID;\nlet lastCapturedEvent;\n\n/**\n * Decide whether the current event should finish the debounce of previously captured one.\n * @param previous previously captured event\n * @param current event to be captured\n */\nfunction shouldShortcircuitPreviousDebounce(previous, current) {\n  // If there was no previous event, it should always be swapped for the new one.\n  if (!previous) {\n    return true;\n  }\n\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (previous.type !== current.type) {\n    return true;\n  }\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (previous.target !== current.target) {\n      return true;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return false;\n}\n\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(event) {\n  // We are only interested in filtering `keypress` events for now.\n  if (event.type !== 'keypress') {\n    return false;\n  }\n  try {\n    const target = event.target;\n    if (!target || !target.tagName) {\n      return true;\n    }\n\n    // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n    // e.g.tabbing through elements, hotkeys, etc.\n    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n      return false;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n  return true;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param handler function that will be triggered\n * @param globalListener indicates whether event was captured by the global event listener\n * @returns wrapped breadcrumb events handler\n * @hidden\n */\nfunction makeDOMEventHandler(handler) {\n  let globalListener = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return event => {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || lastCapturedEvent === event) {\n      return;\n    }\n\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event)) {\n      return;\n    }\n    const name = event.type === 'keypress' ? 'input' : event.type;\n\n    // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.\n    if (debounceTimerID === undefined) {\n      handler({\n        event: event,\n        name,\n        global: globalListener\n      });\n      lastCapturedEvent = event;\n    }\n    // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {\n      handler({\n        event: event,\n        name,\n        global: globalListener\n      });\n      lastCapturedEvent = event;\n    }\n\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = WINDOW.setTimeout(() => {\n      debounceTimerID = undefined;\n    }, debounceDuration);\n  };\n}\n\n/** JSDoc */\nfunction instrumentDOM() {\n  if (!('document' in WINDOW)) {\n    return;\n  }\n\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  const triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  WINDOW.document.addEventListener('click', globalDOMEventHandler, false);\n  WINDOW.document.addEventListener('keypress', globalDOMEventHandler, false);\n\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach(target => {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const proto = WINDOW[target] && WINDOW[target].prototype;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n    fill(proto, 'addEventListener', function (originalAddEventListener) {\n      return function (type, listener, options) {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            const el = this;\n            const handlers = el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {};\n            const handlerForType = handlers[type] = handlers[type] || {\n              refCount: 0\n            };\n            if (!handlerForType.handler) {\n              const handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n            handlerForType.refCount++;\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n    fill(proto, 'removeEventListener', function (originalRemoveEventListener) {\n      return function (type, listener, options) {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            const el = this;\n            const handlers = el.__sentry_instrumentation_handlers__ || {};\n            const handlerForType = handlers[type];\n            if (handlerForType) {\n              handlerForType.refCount--;\n              // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n              if (handlerForType.refCount <= 0) {\n                originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                handlerForType.handler = undefined;\n                delete handlers[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n              }\n\n              // If there are no longer any custom handlers of any type on this element, cleanup everything.\n              if (Object.keys(handlers).length === 0) {\n                delete el.__sentry_instrumentation_handlers__;\n              }\n            }\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n        return originalRemoveEventListener.call(this, type, listener, options);\n      };\n    });\n  });\n}\nlet _oldOnErrorHandler = null;\n/** JSDoc */\nfunction instrumentError() {\n  _oldOnErrorHandler = WINDOW.onerror;\n  WINDOW.onerror = function (msg, url, line, column, error) {\n    triggerHandlers('error', {\n      column,\n      error,\n      line,\n      msg,\n      url\n    });\n    if (_oldOnErrorHandler && !_oldOnErrorHandler.__SENTRY_LOADER__) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnErrorHandler.apply(this, arguments);\n    }\n    return false;\n  };\n  WINDOW.onerror.__SENTRY_INSTRUMENTED__ = true;\n}\nlet _oldOnUnhandledRejectionHandler = null;\n/** JSDoc */\nfunction instrumentUnhandledRejection() {\n  _oldOnUnhandledRejectionHandler = WINDOW.onunhandledrejection;\n  WINDOW.onunhandledrejection = function (e) {\n    triggerHandlers('unhandledrejection', e);\n    if (_oldOnUnhandledRejectionHandler && !_oldOnUnhandledRejectionHandler.__SENTRY_LOADER__) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n    }\n    return true;\n  };\n  WINDOW.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;\n}\nexport { SENTRY_XHR_DATA_KEY, addInstrumentationHandler, parseFetchArgs };","map":{"version":3,"names":["WINDOW","getGlobalObject","SENTRY_XHR_DATA_KEY","handlers","instrumented","instrument","type","instrumentConsole","instrumentDOM","instrumentXHR","instrumentFetch","instrumentHistory","instrumentError","instrumentUnhandledRejection","__SENTRY_DEBUG__","logger","warn","addInstrumentationHandler","callback","push","triggerHandlers","data","handler","e","error","getFunctionName","CONSOLE_LEVELS","forEach","level","console","fill","originalConsoleMethod","_len","arguments","length","args","Array","_key","apply","supportsNativeFetch","originalFetch","_len2","_key2","method","url","parseFetchArgs","handlerData","fetchData","startTimestamp","Date","now","then","response","endTimestamp","hasProp","obj","prop","getUrlFromResource","resource","toString","fetchArgs","options","String","toUpperCase","arg","xhrproto","XMLHttpRequest","prototype","originalOpen","_len3","_key3","xhrInfo","isString","request_headers","match","__sentry_own_request__","onreadystatechangeHandler","readyState","status_code","status","xhr","onreadystatechange","original","_len4","readyStateArgs","_key4","addEventListener","_len5","setRequestHeaderArgs","_key5","header","value","toLowerCase","originalSend","sentryXhrData","_len6","_key6","undefined","body","lastHref","supportsHistory","oldOnPopState","onpopstate","to","location","href","from","_len7","_key7","_oO","historyReplacementFunction","originalHistoryFunction","_len8","_key8","history","debounceDuration","debounceTimerID","lastCapturedEvent","shouldShortcircuitPreviousDebounce","previous","current","target","shouldSkipDOMEvent","event","tagName","isContentEditable","makeDOMEventHandler","globalListener","name","global","clearTimeout","setTimeout","triggerDOMHandler","bind","globalDOMEventHandler","document","proto","hasOwnProperty","originalAddEventListener","listener","el","__sentry_instrumentation_handlers__","handlerForType","refCount","call","originalRemoveEventListener","Object","keys","_oldOnErrorHandler","onerror","msg","line","column","__SENTRY_LOADER__","__SENTRY_INSTRUMENTED__","_oldOnUnhandledRejectionHandler","onunhandledrejection"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/instrument.ts"],"sourcesContent":["/* eslint-disable max-lines */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\nimport type {\n  HandlerDataFetch,\n  HandlerDataXhr,\n  SentryWrappedXMLHttpRequest,\n  SentryXhrData,\n  WrappedFunction,\n} from '@sentry/types';\n\nimport { isString } from './is';\nimport { CONSOLE_LEVELS, logger } from './logger';\nimport { fill } from './object';\nimport { getFunctionName } from './stacktrace';\nimport { supportsHistory, supportsNativeFetch } from './supports';\nimport { getGlobalObject } from './worldwide';\n\n// eslint-disable-next-line deprecation/deprecation\nconst WINDOW = getGlobalObject<Window>();\n\nexport const SENTRY_XHR_DATA_KEY = '__sentry_xhr_v2__';\n\nexport type InstrumentHandlerType =\n  | 'console'\n  | 'dom'\n  | 'fetch'\n  | 'history'\n  | 'sentry'\n  | 'xhr'\n  | 'error'\n  | 'unhandledrejection';\nexport type InstrumentHandlerCallback = (data: any) => void;\n\n/**\n * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.\n *  - Console API\n *  - Fetch API\n *  - XHR API\n *  - History API\n *  - DOM API (click/typing)\n *  - Error API\n *  - UnhandledRejection API\n */\n\nconst handlers: { [key in InstrumentHandlerType]?: InstrumentHandlerCallback[] } = {};\nconst instrumented: { [key in InstrumentHandlerType]?: boolean } = {};\n\n/** Instruments given API */\nfunction instrument(type: InstrumentHandlerType): void {\n  if (instrumented[type]) {\n    return;\n  }\n\n  instrumented[type] = true;\n\n  switch (type) {\n    case 'console':\n      instrumentConsole();\n      break;\n    case 'dom':\n      instrumentDOM();\n      break;\n    case 'xhr':\n      instrumentXHR();\n      break;\n    case 'fetch':\n      instrumentFetch();\n      break;\n    case 'history':\n      instrumentHistory();\n      break;\n    case 'error':\n      instrumentError();\n      break;\n    case 'unhandledrejection':\n      instrumentUnhandledRejection();\n      break;\n    default:\n      __DEBUG_BUILD__ && logger.warn('unknown instrumentation type:', type);\n      return;\n  }\n}\n\n/**\n * Add handler that will be called when given type of instrumentation triggers.\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addInstrumentationHandler(type: InstrumentHandlerType, callback: InstrumentHandlerCallback): void {\n  handlers[type] = handlers[type] || [];\n  (handlers[type] as InstrumentHandlerCallback[]).push(callback);\n  instrument(type);\n}\n\n/** JSDoc */\nfunction triggerHandlers(type: InstrumentHandlerType, data: any): void {\n  if (!type || !handlers[type]) {\n    return;\n  }\n\n  for (const handler of handlers[type] || []) {\n    try {\n      handler(data);\n    } catch (e) {\n      __DEBUG_BUILD__ &&\n        logger.error(\n          `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`,\n          e,\n        );\n    }\n  }\n}\n\n/** JSDoc */\nfunction instrumentConsole(): void {\n  if (!('console' in WINDOW)) {\n    return;\n  }\n\n  CONSOLE_LEVELS.forEach(function (level: string): void {\n    if (!(level in WINDOW.console)) {\n      return;\n    }\n\n    fill(WINDOW.console, level, function (originalConsoleMethod: () => any): Function {\n      return function (...args: any[]): void {\n        triggerHandlers('console', { args, level });\n\n        // this fails for some browsers. :(\n        if (originalConsoleMethod) {\n          originalConsoleMethod.apply(WINDOW.console, args);\n        }\n      };\n    });\n  });\n}\n\n/** JSDoc */\nfunction instrumentFetch(): void {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n\n  fill(WINDOW, 'fetch', function (originalFetch: () => void): () => void {\n    return function (...args: any[]): void {\n      const { method, url } = parseFetchArgs(args);\n\n      const handlerData: HandlerDataFetch = {\n        args,\n        fetchData: {\n          method,\n          url,\n        },\n        startTimestamp: Date.now(),\n      };\n\n      triggerHandlers('fetch', {\n        ...handlerData,\n      });\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalFetch.apply(WINDOW, args).then(\n        (response: Response) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            response,\n          });\n          return response;\n        },\n        (error: Error) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            error,\n          });\n          // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n          //       it means the sentry.javascript SDK caught an error invoking your application code.\n          //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n          throw error;\n        },\n      );\n    };\n  });\n}\n\nfunction hasProp<T extends string>(obj: unknown, prop: T): obj is Record<string, string> {\n  return !!obj && typeof obj === 'object' && !!(obj as Record<string, string>)[prop];\n}\n\ntype FetchResource = string | { toString(): string } | { url: string };\n\nfunction getUrlFromResource(resource: FetchResource): string {\n  if (typeof resource === 'string') {\n    return resource;\n  }\n\n  if (!resource) {\n    return '';\n  }\n\n  if (hasProp(resource, 'url')) {\n    return resource.url;\n  }\n\n  if (resource.toString) {\n    return resource.toString();\n  }\n\n  return '';\n}\n\n/**\n * Parses the fetch arguments to find the used Http method and the url of the request\n */\nexport function parseFetchArgs(fetchArgs: unknown[]): { method: string; url: string } {\n  if (fetchArgs.length === 0) {\n    return { method: 'GET', url: '' };\n  }\n\n  if (fetchArgs.length === 2) {\n    const [url, options] = fetchArgs as [FetchResource, object];\n\n    return {\n      url: getUrlFromResource(url),\n      method: hasProp(options, 'method') ? String(options.method).toUpperCase() : 'GET',\n    };\n  }\n\n  const arg = fetchArgs[0];\n  return {\n    url: getUrlFromResource(arg as FetchResource),\n    method: hasProp(arg, 'method') ? String(arg.method).toUpperCase() : 'GET',\n  };\n}\n\n/** JSDoc */\nfunction instrumentXHR(): void {\n  if (!('XMLHttpRequest' in WINDOW)) {\n    return;\n  }\n\n  const xhrproto = XMLHttpRequest.prototype;\n\n  fill(xhrproto, 'open', function (originalOpen: () => void): () => void {\n    return function (this: XMLHttpRequest & SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      const url = args[1];\n      const xhrInfo: SentryXhrData = (this[SENTRY_XHR_DATA_KEY] = {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        method: isString(args[0]) ? args[0].toUpperCase() : args[0],\n        url: args[1],\n        request_headers: {},\n      });\n\n      // if Sentry key appears in URL, don't capture it as a request\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (isString(url) && xhrInfo.method === 'POST' && url.match(/sentry_key/)) {\n        this.__sentry_own_request__ = true;\n      }\n\n      const onreadystatechangeHandler: () => void = () => {\n        // For whatever reason, this is not the same instance here as from the outer method\n        const xhrInfo = this[SENTRY_XHR_DATA_KEY];\n\n        if (!xhrInfo) {\n          return;\n        }\n\n        if (this.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = this.status;\n          } catch (e) {\n            /* do nothing */\n          }\n\n          triggerHandlers('xhr', {\n            args: args as [string, string],\n            endTimestamp: Date.now(),\n            startTimestamp: Date.now(),\n            xhr: this,\n          } as HandlerDataXhr);\n        }\n      };\n\n      if ('onreadystatechange' in this && typeof this.onreadystatechange === 'function') {\n        fill(this, 'onreadystatechange', function (original: WrappedFunction): Function {\n          return function (this: SentryWrappedXMLHttpRequest, ...readyStateArgs: any[]): void {\n            onreadystatechangeHandler();\n            return original.apply(this, readyStateArgs);\n          };\n        });\n      } else {\n        this.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      // Intercepting `setRequestHeader` to access the request headers of XHR instance.\n      // This will only work for user/library defined headers, not for the default/browser-assigned headers.\n      // Request cookies are also unavailable for XHR, as `Cookie` header can't be defined by `setRequestHeader`.\n      fill(this, 'setRequestHeader', function (original: WrappedFunction): Function {\n        return function (this: SentryWrappedXMLHttpRequest, ...setRequestHeaderArgs: unknown[]): void {\n          const [header, value] = setRequestHeaderArgs as [string, string];\n\n          const xhrInfo = this[SENTRY_XHR_DATA_KEY];\n\n          if (xhrInfo) {\n            xhrInfo.request_headers[header.toLowerCase()] = value;\n          }\n\n          return original.apply(this, setRequestHeaderArgs);\n        };\n      });\n\n      return originalOpen.apply(this, args);\n    };\n  });\n\n  fill(xhrproto, 'send', function (originalSend: () => void): () => void {\n    return function (this: XMLHttpRequest & SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      const sentryXhrData = this[SENTRY_XHR_DATA_KEY];\n      if (sentryXhrData && args[0] !== undefined) {\n        sentryXhrData.body = args[0];\n      }\n\n      triggerHandlers('xhr', {\n        args,\n        startTimestamp: Date.now(),\n        xhr: this,\n      });\n\n      return originalSend.apply(this, args);\n    };\n  });\n}\n\nlet lastHref: string;\n\n/** JSDoc */\nfunction instrumentHistory(): void {\n  if (!supportsHistory()) {\n    return;\n  }\n\n  const oldOnPopState = WINDOW.onpopstate;\n  WINDOW.onpopstate = function (this: WindowEventHandlers, ...args: any[]): any {\n    const to = WINDOW.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n    triggerHandlers('history', {\n      from,\n      to,\n    });\n    if (oldOnPopState) {\n      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.\n      // https://github.com/getsentry/sentry-javascript/issues/3344\n      // https://github.com/bugsnag/bugsnag-js/issues/469\n      try {\n        return oldOnPopState.apply(this, args);\n      } catch (_oO) {\n        // no-empty\n      }\n    }\n  };\n\n  /** @hidden */\n  function historyReplacementFunction(originalHistoryFunction: () => void): () => void {\n    return function (this: History, ...args: any[]): void {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        triggerHandlers('history', {\n          from,\n          to,\n        });\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(WINDOW.history, 'pushState', historyReplacementFunction);\n  fill(WINDOW.history, 'replaceState', historyReplacementFunction);\n}\n\nconst debounceDuration = 1000;\nlet debounceTimerID: number | undefined;\nlet lastCapturedEvent: Event | undefined;\n\n/**\n * Decide whether the current event should finish the debounce of previously captured one.\n * @param previous previously captured event\n * @param current event to be captured\n */\nfunction shouldShortcircuitPreviousDebounce(previous: Event | undefined, current: Event): boolean {\n  // If there was no previous event, it should always be swapped for the new one.\n  if (!previous) {\n    return true;\n  }\n\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (previous.type !== current.type) {\n    return true;\n  }\n\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (previous.target !== current.target) {\n      return true;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return false;\n}\n\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(event: Event): boolean {\n  // We are only interested in filtering `keypress` events for now.\n  if (event.type !== 'keypress') {\n    return false;\n  }\n\n  try {\n    const target = event.target as HTMLElement;\n\n    if (!target || !target.tagName) {\n      return true;\n    }\n\n    // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n    // e.g.tabbing through elements, hotkeys, etc.\n    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n      return false;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  return true;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param handler function that will be triggered\n * @param globalListener indicates whether event was captured by the global event listener\n * @returns wrapped breadcrumb events handler\n * @hidden\n */\nfunction makeDOMEventHandler(handler: Function, globalListener: boolean = false): (event: Event) => void {\n  return (event: Event): void => {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || lastCapturedEvent === event) {\n      return;\n    }\n\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event)) {\n      return;\n    }\n\n    const name = event.type === 'keypress' ? 'input' : event.type;\n\n    // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.\n    if (debounceTimerID === undefined) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n    // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = WINDOW.setTimeout(() => {\n      debounceTimerID = undefined;\n    }, debounceDuration);\n  };\n}\n\ntype AddEventListener = (\n  type: string,\n  listener: EventListenerOrEventListenerObject,\n  options?: boolean | AddEventListenerOptions,\n) => void;\ntype RemoveEventListener = (\n  type: string,\n  listener: EventListenerOrEventListenerObject,\n  options?: boolean | EventListenerOptions,\n) => void;\n\ntype InstrumentedElement = Element & {\n  __sentry_instrumentation_handlers__?: {\n    [key in 'click' | 'keypress']?: {\n      handler?: Function;\n      /** The number of custom listeners attached to this element */\n      refCount: number;\n    };\n  };\n};\n\n/** JSDoc */\nfunction instrumentDOM(): void {\n  if (!('document' in WINDOW)) {\n    return;\n  }\n\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  const triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  WINDOW.document.addEventListener('click', globalDOMEventHandler, false);\n  WINDOW.document.addEventListener('keypress', globalDOMEventHandler, false);\n\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach((target: string) => {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const proto = (WINDOW as any)[target] && (WINDOW as any)[target].prototype;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n\n    fill(proto, 'addEventListener', function (originalAddEventListener: AddEventListener): AddEventListener {\n      return function (\n        this: Element,\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: boolean | AddEventListenerOptions,\n      ): AddEventListener {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            const el = this as InstrumentedElement;\n            const handlers = (el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {});\n            const handlerForType = (handlers[type] = handlers[type] || { refCount: 0 });\n\n            if (!handlerForType.handler) {\n              const handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n\n            handlerForType.refCount++;\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n\n    fill(\n      proto,\n      'removeEventListener',\n      function (originalRemoveEventListener: RemoveEventListener): RemoveEventListener {\n        return function (\n          this: Element,\n          type: string,\n          listener: EventListenerOrEventListenerObject,\n          options?: boolean | EventListenerOptions,\n        ): () => void {\n          if (type === 'click' || type == 'keypress') {\n            try {\n              const el = this as InstrumentedElement;\n              const handlers = el.__sentry_instrumentation_handlers__ || {};\n              const handlerForType = handlers[type];\n\n              if (handlerForType) {\n                handlerForType.refCount--;\n                // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n                if (handlerForType.refCount <= 0) {\n                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                  handlerForType.handler = undefined;\n                  delete handlers[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n                }\n\n                // If there are no longer any custom handlers of any type on this element, cleanup everything.\n                if (Object.keys(handlers).length === 0) {\n                  delete el.__sentry_instrumentation_handlers__;\n                }\n              }\n            } catch (e) {\n              // Accessing dom properties is always fragile.\n              // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n            }\n          }\n\n          return originalRemoveEventListener.call(this, type, listener, options);\n        };\n      },\n    );\n  });\n}\n\nlet _oldOnErrorHandler: (typeof WINDOW)['onerror'] | null = null;\n/** JSDoc */\nfunction instrumentError(): void {\n  _oldOnErrorHandler = WINDOW.onerror;\n\n  WINDOW.onerror = function (msg: unknown, url: unknown, line: unknown, column: unknown, error: unknown): boolean {\n    triggerHandlers('error', {\n      column,\n      error,\n      line,\n      msg,\n      url,\n    });\n\n    if (_oldOnErrorHandler && !_oldOnErrorHandler.__SENTRY_LOADER__) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnErrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  };\n\n  WINDOW.onerror.__SENTRY_INSTRUMENTED__ = true;\n}\n\nlet _oldOnUnhandledRejectionHandler: (typeof WINDOW)['onunhandledrejection'] | null = null;\n/** JSDoc */\nfunction instrumentUnhandledRejection(): void {\n  _oldOnUnhandledRejectionHandler = WINDOW.onunhandledrejection;\n\n  WINDOW.onunhandledrejection = function (e: any): boolean {\n    triggerHandlers('unhandledrejection', e);\n\n    if (_oldOnUnhandledRejectionHandler && !_oldOnUnhandledRejectionHandler.__SENTRY_LOADER__) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n    }\n\n    return true;\n  };\n\n  WINDOW.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}