{"ast":null,"code":"/** Node Stack line parser */\n// eslint-disable-next-line complexity\nfunction node(getModule) {\n  const FILENAME_MATCH = /^\\s*[-]{4,}$/;\n  const FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+):(\\d+):(\\d+)?|([^)]+))\\)?/;\n\n  // eslint-disable-next-line complexity\n  return line => {\n    const lineMatch = line.match(FULL_MATCH);\n    if (lineMatch) {\n      let object;\n      let method;\n      let functionName;\n      let typeName;\n      let methodName;\n      if (lineMatch[1]) {\n        functionName = lineMatch[1];\n        let methodStart = functionName.lastIndexOf('.');\n        if (functionName[methodStart - 1] === '.') {\n          methodStart--;\n        }\n        if (methodStart > 0) {\n          object = functionName.slice(0, methodStart);\n          method = functionName.slice(methodStart + 1);\n          const objectEnd = object.indexOf('.Module');\n          if (objectEnd > 0) {\n            functionName = functionName.slice(objectEnd + 1);\n            object = object.slice(0, objectEnd);\n          }\n        }\n        typeName = undefined;\n      }\n      if (method) {\n        typeName = object;\n        methodName = method;\n      }\n      if (method === '<anonymous>') {\n        methodName = undefined;\n        functionName = undefined;\n      }\n      if (functionName === undefined) {\n        methodName = methodName || '<anonymous>';\n        functionName = typeName ? `${typeName}.${methodName}` : methodName;\n      }\n      let filename = lineMatch[2] && lineMatch[2].startsWith('file://') ? lineMatch[2].slice(7) : lineMatch[2];\n      const isNative = lineMatch[5] === 'native';\n      if (!filename && lineMatch[5] && !isNative) {\n        filename = lineMatch[5];\n      }\n      const isInternal = isNative || filename &&\n      // It's not internal if it's an absolute linux path\n      !filename.startsWith('/') &&\n      // It's not internal if it's an absolute windows path\n      !filename.includes(':\\\\') &&\n      // It's not internal if the path is starting with a dot\n      !filename.startsWith('.') &&\n      // It's not internal if the frame has a protocol. In node, this is usually the case if the file got pre-processed with a bundler like webpack\n      !filename.match(/^[a-zA-Z]([a-zA-Z0-9.\\-+])*:\\/\\//); // Schema from: https://stackoverflow.com/a/3641782\n\n      // in_app is all that's not an internal Node function or a module within node_modules\n      // note that isNative appears to return true even for node core libraries\n      // see https://github.com/getsentry/raven-node/issues/176\n\n      const in_app = !isInternal && filename !== undefined && !filename.includes('node_modules/');\n      return {\n        filename,\n        module: getModule ? getModule(filename) : undefined,\n        function: functionName,\n        lineno: parseInt(lineMatch[3], 10) || undefined,\n        colno: parseInt(lineMatch[4], 10) || undefined,\n        in_app\n      };\n    }\n    if (line.match(FILENAME_MATCH)) {\n      return {\n        filename: line\n      };\n    }\n    return undefined;\n  };\n}\nexport { node };","map":{"version":3,"names":["node","getModule","FILENAME_MATCH","FULL_MATCH","line","lineMatch","match","object","method","functionName","typeName","methodName","methodStart","lastIndexOf","slice","objectEnd","indexOf","undefined","filename","startsWith","isNative","isInternal","includes","in_app","module","function","lineno","parseInt","colno"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/node-stack-trace.ts"],"sourcesContent":["// This code was originally forked from https://github.com/felixge/node-stack-trace\n// Since then it has been highly modified to fit our needs.\n\n// Copyright (c) 2011 Felix GeisendÃ¶rfer (felix@debuggable.com)//\n//\n//  Permission is hereby granted, free of charge, to any person obtaining a copy\n//  of this software and associated documentation files (the \"Software\"), to deal\n//  in the Software without restriction, including without limitation the rights\n//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n//  copies of the Software, and to permit persons to whom the Software is\n//  furnished to do so, subject to the following conditions://\n//\n//  The above copyright notice and this permission notice shall be included in\n//  all copies or substantial portions of the Software.//\n//\n//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n//  THE SOFTWARE.\n\nimport type { StackLineParserFn } from '@sentry/types';\n\nexport type GetModuleFn = (filename: string | undefined) => string | undefined;\n\n/** Node Stack line parser */\n// eslint-disable-next-line complexity\nexport function node(getModule?: GetModuleFn): StackLineParserFn {\n  const FILENAME_MATCH = /^\\s*[-]{4,}$/;\n  const FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+):(\\d+):(\\d+)?|([^)]+))\\)?/;\n\n  // eslint-disable-next-line complexity\n  return (line: string) => {\n    const lineMatch = line.match(FULL_MATCH);\n\n    if (lineMatch) {\n      let object: string | undefined;\n      let method: string | undefined;\n      let functionName: string | undefined;\n      let typeName: string | undefined;\n      let methodName: string | undefined;\n\n      if (lineMatch[1]) {\n        functionName = lineMatch[1];\n\n        let methodStart = functionName.lastIndexOf('.');\n        if (functionName[methodStart - 1] === '.') {\n          methodStart--;\n        }\n\n        if (methodStart > 0) {\n          object = functionName.slice(0, methodStart);\n          method = functionName.slice(methodStart + 1);\n          const objectEnd = object.indexOf('.Module');\n          if (objectEnd > 0) {\n            functionName = functionName.slice(objectEnd + 1);\n            object = object.slice(0, objectEnd);\n          }\n        }\n        typeName = undefined;\n      }\n\n      if (method) {\n        typeName = object;\n        methodName = method;\n      }\n\n      if (method === '<anonymous>') {\n        methodName = undefined;\n        functionName = undefined;\n      }\n\n      if (functionName === undefined) {\n        methodName = methodName || '<anonymous>';\n        functionName = typeName ? `${typeName}.${methodName}` : methodName;\n      }\n\n      let filename = lineMatch[2] && lineMatch[2].startsWith('file://') ? lineMatch[2].slice(7) : lineMatch[2];\n      const isNative = lineMatch[5] === 'native';\n\n      if (!filename && lineMatch[5] && !isNative) {\n        filename = lineMatch[5];\n      }\n\n      const isInternal =\n        isNative ||\n        (filename &&\n          // It's not internal if it's an absolute linux path\n          !filename.startsWith('/') &&\n          // It's not internal if it's an absolute windows path\n          !filename.includes(':\\\\') &&\n          // It's not internal if the path is starting with a dot\n          !filename.startsWith('.') &&\n          // It's not internal if the frame has a protocol. In node, this is usually the case if the file got pre-processed with a bundler like webpack\n          !filename.match(/^[a-zA-Z]([a-zA-Z0-9.\\-+])*:\\/\\//)); // Schema from: https://stackoverflow.com/a/3641782\n\n      // in_app is all that's not an internal Node function or a module within node_modules\n      // note that isNative appears to return true even for node core libraries\n      // see https://github.com/getsentry/raven-node/issues/176\n\n      const in_app = !isInternal && filename !== undefined && !filename.includes('node_modules/');\n\n      return {\n        filename,\n        module: getModule ? getModule(filename) : undefined,\n        function: functionName,\n        lineno: parseInt(lineMatch[3], 10) || undefined,\n        colno: parseInt(lineMatch[4], 10) || undefined,\n        in_app,\n      };\n    }\n\n    if (line.match(FILENAME_MATCH)) {\n      return {\n        filename: line,\n      };\n    }\n\n    return undefined;\n  };\n}\n"],"mappings":"AA2BA;AACA;AACA,SAAAA,KAAAC,SAAA;EACA,MAAAC,cAAA;EACA,MAAAC,UAAA;;EAEA;EACA,OAAAC,IAAA;IACA,MAAAC,SAAA,GAAAD,IAAA,CAAAE,KAAA,CAAAH,UAAA;IAEA,IAAAE,SAAA;MACA,IAAAE,MAAA;MACA,IAAAC,MAAA;MACA,IAAAC,YAAA;MACA,IAAAC,QAAA;MACA,IAAAC,UAAA;MAEA,IAAAN,SAAA;QACAI,YAAA,GAAAJ,SAAA;QAEA,IAAAO,WAAA,GAAAH,YAAA,CAAAI,WAAA;QACA,IAAAJ,YAAA,CAAAG,WAAA;UACAA,WAAA;QACA;QAEA,IAAAA,WAAA;UACAL,MAAA,GAAAE,YAAA,CAAAK,KAAA,IAAAF,WAAA;UACAJ,MAAA,GAAAC,YAAA,CAAAK,KAAA,CAAAF,WAAA;UACA,MAAAG,SAAA,GAAAR,MAAA,CAAAS,OAAA;UACA,IAAAD,SAAA;YACAN,YAAA,GAAAA,YAAA,CAAAK,KAAA,CAAAC,SAAA;YACAR,MAAA,GAAAA,MAAA,CAAAO,KAAA,IAAAC,SAAA;UACA;QACA;QACAL,QAAA,GAAAO,SAAA;MACA;MAEA,IAAAT,MAAA;QACAE,QAAA,GAAAH,MAAA;QACAI,UAAA,GAAAH,MAAA;MACA;MAEA,IAAAA,MAAA;QACAG,UAAA,GAAAM,SAAA;QACAR,YAAA,GAAAQ,SAAA;MACA;MAEA,IAAAR,YAAA,KAAAQ,SAAA;QACAN,UAAA,GAAAA,UAAA;QACAF,YAAA,GAAAC,QAAA,MAAAA,QAAA,IAAAC,UAAA,KAAAA,UAAA;MACA;MAEA,IAAAO,QAAA,GAAAb,SAAA,OAAAA,SAAA,IAAAc,UAAA,cAAAd,SAAA,IAAAS,KAAA,MAAAT,SAAA;MACA,MAAAe,QAAA,GAAAf,SAAA;MAEA,KAAAa,QAAA,IAAAb,SAAA,QAAAe,QAAA;QACAF,QAAA,GAAAb,SAAA;MACA;MAEA,MAAAgB,UAAA,GACAD,QAAA,IACAF,QAAA;MACA;MACA,CAAAA,QAAA,CAAAC,UAAA;MACA;MACA,CAAAD,QAAA,CAAAI,QAAA;MACA;MACA,CAAAJ,QAAA,CAAAC,UAAA;MACA;MACA,CAAAD,QAAA,CAAAZ,KAAA;;MAEA;MACA;MACA;;MAEA,MAAAiB,MAAA,IAAAF,UAAA,IAAAH,QAAA,KAAAD,SAAA,KAAAC,QAAA,CAAAI,QAAA;MAEA;QACAJ,QAAA;QACAM,MAAA,EAAAvB,SAAA,GAAAA,SAAA,CAAAiB,QAAA,IAAAD,SAAA;QACAQ,QAAA,EAAAhB,YAAA;QACAiB,MAAA,EAAAC,QAAA,CAAAtB,SAAA,YAAAY,SAAA;QACAW,KAAA,EAAAD,QAAA,CAAAtB,SAAA,YAAAY,SAAA;QACAM;MACA;IACA;IAEA,IAAAnB,IAAA,CAAAE,KAAA,CAAAJ,cAAA;MACA;QACAgB,QAAA,EAAAd;MACA;IACA;IAEA,OAAAa,SAAA;EACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}