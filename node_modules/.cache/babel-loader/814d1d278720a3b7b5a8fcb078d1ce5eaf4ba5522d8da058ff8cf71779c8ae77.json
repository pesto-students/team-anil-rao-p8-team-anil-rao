{"ast":null,"code":"import { logger, dropUndefinedKeys } from '@sentry/utils';\nimport { DEFAULT_ENVIRONMENT } from '../constants.js';\nimport { getCurrentHub } from '../hub.js';\nimport { Span, SpanRecorder } from './span.js';\n\n/** JSDoc */\nclass Transaction extends Span {\n  /**\n   * The reference to the current hub.\n   */\n\n  __init() {\n    this._measurements = {};\n  }\n  __init2() {\n    this._contexts = {};\n  }\n  __init3() {\n    this._frozenDynamicSamplingContext = undefined;\n  }\n\n  /**\n   * This constructor should never be called manually. Those instrumenting tracing should use\n   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n  constructor(transactionContext, hub) {\n    super(transactionContext);\n    Transaction.prototype.__init.call(this);\n    Transaction.prototype.__init2.call(this);\n    Transaction.prototype.__init3.call(this);\n    this._hub = hub || getCurrentHub();\n    this._name = transactionContext.name || '';\n    this.metadata = {\n      source: 'custom',\n      ...transactionContext.metadata,\n      spanMetadata: {}\n    };\n    this._trimEnd = transactionContext.trimEnd;\n\n    // this is because transactions are also spans, and spans have a transaction pointer\n    this.transaction = this;\n\n    // If Dynamic Sampling Context is provided during the creation of the transaction, we freeze it as it usually means\n    // there is incoming Dynamic Sampling Context. (Either through an incoming request, a baggage meta-tag, or other means)\n    const incomingDynamicSamplingContext = this.metadata.dynamicSamplingContext;\n    if (incomingDynamicSamplingContext) {\n      // We shallow copy this in case anything writes to the original reference of the passed in `dynamicSamplingContext`\n      this._frozenDynamicSamplingContext = {\n        ...incomingDynamicSamplingContext\n      };\n    }\n  }\n\n  /** Getter for `name` property */\n  get name() {\n    return this._name;\n  }\n\n  /** Setter for `name` property, which also sets `source` as custom */\n  set name(newName) {\n    this.setName(newName);\n  }\n\n  /**\n   * JSDoc\n   */\n  setName(name) {\n    let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'custom';\n    this._name = name;\n    this.metadata.source = source;\n  }\n\n  /**\n   * Attaches SpanRecorder to the span itself\n   * @param maxlen maximum number of spans that can be recorded\n   */\n  initSpanRecorder() {\n    let maxlen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;\n    if (!this.spanRecorder) {\n      this.spanRecorder = new SpanRecorder(maxlen);\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setContext(key, context) {\n    if (context === null) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._contexts[key];\n    } else {\n      this._contexts[key] = context;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setMeasurement(name, value) {\n    let unit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    this._measurements[name] = {\n      value,\n      unit\n    };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setMetadata(newMetadata) {\n    this.metadata = {\n      ...this.metadata,\n      ...newMetadata\n    };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  finish(endTimestamp) {\n    // This transaction is already finished, so we should not flush it again.\n    if (this.endTimestamp !== undefined) {\n      return undefined;\n    }\n    if (!this.name) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this.name = '<unlabeled transaction>';\n    }\n\n    // just sets the end timestamp\n    super.finish(endTimestamp);\n    const client = this._hub.getClient();\n    if (client && client.emit) {\n      client.emit('finishTransaction', this);\n    }\n    if (this.sampled !== true) {\n      // At this point if `sampled !== true` we want to discard the transaction.\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');\n      if (client) {\n        client.recordDroppedEvent('sample_rate', 'transaction');\n      }\n      return undefined;\n    }\n    const finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(s => s !== this && s.endTimestamp) : [];\n    if (this._trimEnd && finishedSpans.length > 0) {\n      this.endTimestamp = finishedSpans.reduce((prev, current) => {\n        if (prev.endTimestamp && current.endTimestamp) {\n          return prev.endTimestamp > current.endTimestamp ? prev : current;\n        }\n        return prev;\n      }).endTimestamp;\n    }\n    const metadata = this.metadata;\n    const transaction = {\n      contexts: {\n        ...this._contexts,\n        // We don't want to override trace context\n        trace: this.getTraceContext()\n      },\n      spans: finishedSpans,\n      start_timestamp: this.startTimestamp,\n      tags: this.tags,\n      timestamp: this.endTimestamp,\n      transaction: this.name,\n      type: 'transaction',\n      sdkProcessingMetadata: {\n        ...metadata,\n        dynamicSamplingContext: this.getDynamicSamplingContext()\n      },\n      ...(metadata.source && {\n        transaction_info: {\n          source: metadata.source\n        }\n      })\n    };\n    const hasMeasurements = Object.keys(this._measurements).length > 0;\n    if (hasMeasurements) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Measurements] Adding measurements to transaction', JSON.stringify(this._measurements, undefined, 2));\n      transaction.measurements = this._measurements;\n    }\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] Finishing ${this.op} transaction: ${this.name}.`);\n    return this._hub.captureEvent(transaction);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  toContext() {\n    const spanContext = super.toContext();\n    return dropUndefinedKeys({\n      ...spanContext,\n      name: this.name,\n      trimEnd: this._trimEnd\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateWithContext(transactionContext) {\n    super.updateWithContext(transactionContext);\n    this.name = transactionContext.name || '';\n    this._trimEnd = transactionContext.trimEnd;\n    return this;\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @experimental\n   */\n  getDynamicSamplingContext() {\n    if (this._frozenDynamicSamplingContext) {\n      return this._frozenDynamicSamplingContext;\n    }\n    const hub = this._hub || getCurrentHub();\n    const client = hub && hub.getClient();\n    if (!client) return {};\n    const {\n      environment,\n      release\n    } = client.getOptions() || {};\n    const {\n      publicKey: public_key\n    } = client.getDsn() || {};\n    const maybeSampleRate = this.metadata.sampleRate;\n    const sample_rate = maybeSampleRate !== undefined ? maybeSampleRate.toString() : undefined;\n    const {\n      segment: user_segment\n    } = hub.getScope().getUser() || {};\n    const source = this.metadata.source;\n\n    // We don't want to have a transaction name in the DSC if the source is \"url\" because URLs might contain PII\n    const transaction = source && source !== 'url' ? this.name : undefined;\n    const dsc = dropUndefinedKeys({\n      environment: environment || DEFAULT_ENVIRONMENT,\n      release,\n      transaction,\n      user_segment,\n      public_key,\n      trace_id: this.traceId,\n      sample_rate\n    });\n\n    // Uncomment if we want to make DSC immutable\n    // this._frozenDynamicSamplingContext = dsc;\n\n    client.emit && client.emit('createDsc', dsc);\n    return dsc;\n  }\n\n  /**\n   * Override the current hub with a new one.\n   * Used if you want another hub to finish the transaction.\n   *\n   * @internal\n   */\n  setHub(hub) {\n    this._hub = hub;\n  }\n}\nexport { Transaction };","map":{"version":3,"names":["Transaction","Span","__init","_measurements","__init2","_contexts","__init3","_frozenDynamicSamplingContext","undefined","constructor","transactionContext","hub","prototype","call","_hub","getCurrentHub","_name","name","metadata","source","spanMetadata","_trimEnd","trimEnd","transaction","incomingDynamicSamplingContext","dynamicSamplingContext","newName","setName","arguments","length","initSpanRecorder","maxlen","spanRecorder","SpanRecorder","add","setContext","key","context","setMeasurement","value","unit","setMetadata","newMetadata","finish","endTimestamp","__SENTRY_DEBUG__","logger","warn","client","getClient","emit","sampled","log","recordDroppedEvent","finishedSpans","spans","filter","s","reduce","prev","current","contexts","trace","getTraceContext","start_timestamp","startTimestamp","tags","timestamp","type","sdkProcessingMetadata","getDynamicSamplingContext","transaction_info","hasMeasurements","Object","keys","JSON","stringify","measurements","op","captureEvent","toContext","spanContext","dropUndefinedKeys","updateWithContext","environment","release","getOptions","publicKey","public_key","getDsn","maybeSampleRate","sampleRate","sample_rate","toString","segment","user_segment","getScope","getUser","dsc","DEFAULT_ENVIRONMENT","trace_id","traceId","setHub"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/tracing/transaction.ts"],"sourcesContent":["import type {\n  Context,\n  Contexts,\n  DynamicSamplingContext,\n  Event,\n  Measurements,\n  MeasurementUnit,\n  Transaction as TransactionInterface,\n  TransactionContext,\n  TransactionMetadata,\n} from '@sentry/types';\nimport { dropUndefinedKeys, logger } from '@sentry/utils';\n\nimport { DEFAULT_ENVIRONMENT } from '../constants';\nimport type { Hub } from '../hub';\nimport { getCurrentHub } from '../hub';\nimport { Span as SpanClass, SpanRecorder } from './span';\n\n/** JSDoc */\nexport class Transaction extends SpanClass implements TransactionInterface {\n  public metadata: TransactionMetadata;\n\n  /**\n   * The reference to the current hub.\n   */\n  public _hub: Hub;\n\n  private _name: string;\n\n  private _measurements: Measurements = {};\n\n  private _contexts: Contexts = {};\n\n  private _trimEnd?: boolean;\n\n  private _frozenDynamicSamplingContext: Readonly<Partial<DynamicSamplingContext>> | undefined = undefined;\n\n  /**\n   * This constructor should never be called manually. Those instrumenting tracing should use\n   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n  public constructor(transactionContext: TransactionContext, hub?: Hub) {\n    super(transactionContext);\n\n    this._hub = hub || getCurrentHub();\n\n    this._name = transactionContext.name || '';\n\n    this.metadata = {\n      source: 'custom',\n      ...transactionContext.metadata,\n      spanMetadata: {},\n    };\n\n    this._trimEnd = transactionContext.trimEnd;\n\n    // this is because transactions are also spans, and spans have a transaction pointer\n    this.transaction = this;\n\n    // If Dynamic Sampling Context is provided during the creation of the transaction, we freeze it as it usually means\n    // there is incoming Dynamic Sampling Context. (Either through an incoming request, a baggage meta-tag, or other means)\n    const incomingDynamicSamplingContext = this.metadata.dynamicSamplingContext;\n    if (incomingDynamicSamplingContext) {\n      // We shallow copy this in case anything writes to the original reference of the passed in `dynamicSamplingContext`\n      this._frozenDynamicSamplingContext = { ...incomingDynamicSamplingContext };\n    }\n  }\n\n  /** Getter for `name` property */\n  public get name(): string {\n    return this._name;\n  }\n\n  /** Setter for `name` property, which also sets `source` as custom */\n  public set name(newName: string) {\n    this.setName(newName);\n  }\n\n  /**\n   * JSDoc\n   */\n  public setName(name: string, source: TransactionMetadata['source'] = 'custom'): void {\n    this._name = name;\n    this.metadata.source = source;\n  }\n\n  /**\n   * Attaches SpanRecorder to the span itself\n   * @param maxlen maximum number of spans that can be recorded\n   */\n  public initSpanRecorder(maxlen: number = 1000): void {\n    if (!this.spanRecorder) {\n      this.spanRecorder = new SpanRecorder(maxlen);\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setContext(key: string, context: Context | null): void {\n    if (context === null) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._contexts[key];\n    } else {\n      this._contexts[key] = context;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setMeasurement(name: string, value: number, unit: MeasurementUnit = ''): void {\n    this._measurements[name] = { value, unit };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setMetadata(newMetadata: Partial<TransactionMetadata>): void {\n    this.metadata = { ...this.metadata, ...newMetadata };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public finish(endTimestamp?: number): string | undefined {\n    // This transaction is already finished, so we should not flush it again.\n    if (this.endTimestamp !== undefined) {\n      return undefined;\n    }\n\n    if (!this.name) {\n      __DEBUG_BUILD__ && logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this.name = '<unlabeled transaction>';\n    }\n\n    // just sets the end timestamp\n    super.finish(endTimestamp);\n\n    const client = this._hub.getClient();\n    if (client && client.emit) {\n      client.emit('finishTransaction', this);\n    }\n\n    if (this.sampled !== true) {\n      // At this point if `sampled !== true` we want to discard the transaction.\n      __DEBUG_BUILD__ && logger.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');\n\n      if (client) {\n        client.recordDroppedEvent('sample_rate', 'transaction');\n      }\n\n      return undefined;\n    }\n\n    const finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(s => s !== this && s.endTimestamp) : [];\n\n    if (this._trimEnd && finishedSpans.length > 0) {\n      this.endTimestamp = finishedSpans.reduce((prev: SpanClass, current: SpanClass) => {\n        if (prev.endTimestamp && current.endTimestamp) {\n          return prev.endTimestamp > current.endTimestamp ? prev : current;\n        }\n        return prev;\n      }).endTimestamp;\n    }\n\n    const metadata = this.metadata;\n\n    const transaction: Event = {\n      contexts: {\n        ...this._contexts,\n        // We don't want to override trace context\n        trace: this.getTraceContext(),\n      },\n      spans: finishedSpans,\n      start_timestamp: this.startTimestamp,\n      tags: this.tags,\n      timestamp: this.endTimestamp,\n      transaction: this.name,\n      type: 'transaction',\n      sdkProcessingMetadata: {\n        ...metadata,\n        dynamicSamplingContext: this.getDynamicSamplingContext(),\n      },\n      ...(metadata.source && {\n        transaction_info: {\n          source: metadata.source,\n        },\n      }),\n    };\n\n    const hasMeasurements = Object.keys(this._measurements).length > 0;\n\n    if (hasMeasurements) {\n      __DEBUG_BUILD__ &&\n        logger.log(\n          '[Measurements] Adding measurements to transaction',\n          JSON.stringify(this._measurements, undefined, 2),\n        );\n      transaction.measurements = this._measurements;\n    }\n\n    __DEBUG_BUILD__ && logger.log(`[Tracing] Finishing ${this.op} transaction: ${this.name}.`);\n\n    return this._hub.captureEvent(transaction);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public toContext(): TransactionContext {\n    const spanContext = super.toContext();\n\n    return dropUndefinedKeys({\n      ...spanContext,\n      name: this.name,\n      trimEnd: this._trimEnd,\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public updateWithContext(transactionContext: TransactionContext): this {\n    super.updateWithContext(transactionContext);\n\n    this.name = transactionContext.name || '';\n\n    this._trimEnd = transactionContext.trimEnd;\n\n    return this;\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @experimental\n   */\n  public getDynamicSamplingContext(): Readonly<Partial<DynamicSamplingContext>> {\n    if (this._frozenDynamicSamplingContext) {\n      return this._frozenDynamicSamplingContext;\n    }\n\n    const hub: Hub = this._hub || getCurrentHub();\n    const client = hub && hub.getClient();\n\n    if (!client) return {};\n\n    const { environment, release } = client.getOptions() || {};\n    const { publicKey: public_key } = client.getDsn() || {};\n\n    const maybeSampleRate = this.metadata.sampleRate;\n    const sample_rate = maybeSampleRate !== undefined ? maybeSampleRate.toString() : undefined;\n\n    const { segment: user_segment } = hub.getScope().getUser() || {};\n\n    const source = this.metadata.source;\n\n    // We don't want to have a transaction name in the DSC if the source is \"url\" because URLs might contain PII\n    const transaction = source && source !== 'url' ? this.name : undefined;\n\n    const dsc = dropUndefinedKeys({\n      environment: environment || DEFAULT_ENVIRONMENT,\n      release,\n      transaction,\n      user_segment,\n      public_key,\n      trace_id: this.traceId,\n      sample_rate,\n    });\n\n    // Uncomment if we want to make DSC immutable\n    // this._frozenDynamicSamplingContext = dsc;\n\n    client.emit && client.emit('createDsc', dsc);\n\n    return dsc;\n  }\n\n  /**\n   * Override the current hub with a new one.\n   * Used if you want another hub to finish the transaction.\n   *\n   * @internal\n   */\n  public setHub(hub: Hub): void {\n    this._hub = hub;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}