{"ast":null,"code":"import { getCurrentHub } from '@sentry/browser';\nimport { timestampInSeconds } from '@sentry/utils';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport * as React from 'react';\nimport { REACT_MOUNT_OP, REACT_UPDATE_OP, REACT_RENDER_OP } from './constants.js';\nconst _jsxFileName = \"/home/runner/work/sentry-javascript/sentry-javascript/packages/react/src/profiler.tsx\";\nconst UNKNOWN_COMPONENT = 'unknown';\n\n/**\n * The Profiler component leverages Sentry's Tracing integration to generate\n * spans based on component lifecycles.\n */\nclass Profiler extends React.Component {\n  /**\n   * The span of the mount activity\n   * Made protected for the React Native SDK to access\n   */\n  __init() {\n    this._mountSpan = undefined;\n  }\n  /**\n   * The span that represents the duration of time between shouldComponentUpdate and componentDidUpdate\n   */\n  __init2() {\n    this._updateSpan = undefined;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  static __initStatic() {\n    this.defaultProps = {\n      disabled: false,\n      includeRender: true,\n      includeUpdates: true\n    };\n  }\n  constructor(props) {\n    super(props);\n    Profiler.prototype.__init.call(this);\n    Profiler.prototype.__init2.call(this);\n    const {\n      name,\n      disabled = false\n    } = this.props;\n    if (disabled) {\n      return;\n    }\n    const activeTransaction = getActiveTransaction();\n    if (activeTransaction) {\n      this._mountSpan = activeTransaction.startChild({\n        description: `<${name}>`,\n        op: REACT_MOUNT_OP\n      });\n    }\n  }\n\n  // If a component mounted, we can finish the mount activity.\n  componentDidMount() {\n    if (this._mountSpan) {\n      this._mountSpan.finish();\n    }\n  }\n  shouldComponentUpdate(_ref) {\n    let {\n      updateProps,\n      includeUpdates = true\n    } = _ref;\n    // Only generate an update span if includeUpdates is true, if there is a valid mountSpan,\n    // and if the updateProps have changed. It is ok to not do a deep equality check here as it is expensive.\n    // We are just trying to give baseline clues for further investigation.\n    if (includeUpdates && this._mountSpan && updateProps !== this.props.updateProps) {\n      // See what props haved changed between the previous props, and the current props. This is\n      // set as data on the span. We just store the prop keys as the values could be potenially very large.\n      const changedProps = Object.keys(updateProps).filter(k => updateProps[k] !== this.props.updateProps[k]);\n      if (changedProps.length > 0) {\n        const now = timestampInSeconds();\n        this._updateSpan = this._mountSpan.startChild({\n          data: {\n            changedProps\n          },\n          description: `<${this.props.name}>`,\n          op: REACT_UPDATE_OP,\n          startTimestamp: now\n        });\n      }\n    }\n    return true;\n  }\n  componentDidUpdate() {\n    if (this._updateSpan) {\n      this._updateSpan.finish();\n      this._updateSpan = undefined;\n    }\n  }\n\n  // If a component is unmounted, we can say it is no longer on the screen.\n  // This means we can finish the span representing the component render.\n  componentWillUnmount() {\n    const {\n      name,\n      includeRender = true\n    } = this.props;\n    if (this._mountSpan && includeRender) {\n      // If we were able to obtain the spanId of the mount activity, we should set the\n      // next activity as a child to the component mount activity.\n      this._mountSpan.startChild({\n        description: `<${name}>`,\n        endTimestamp: timestampInSeconds(),\n        op: REACT_RENDER_OP,\n        startTimestamp: this._mountSpan.endTimestamp\n      });\n    }\n  }\n  render() {\n    return this.props.children;\n  }\n}\nProfiler.__initStatic();\n\n/**\n * withProfiler is a higher order component that wraps a\n * component in a {@link Profiler} component. It is recommended that\n * the higher order component be used over the regular {@link Profiler} component.\n *\n * @param WrappedComponent component that is wrapped by Profiler\n * @param options the {@link ProfilerProps} you can pass into the Profiler\n */\nfunction withProfiler(WrappedComponent,\n// We do not want to have `updateProps` given in options, it is instead filled through the HOC.\noptions) {\n  const componentDisplayName = options && options.name || WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT;\n  const Wrapped = props => React.createElement(Profiler, {\n    ...options,\n    name: componentDisplayName,\n    updateProps: props,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 146\n    }\n  }, React.createElement(WrappedComponent, {\n    ...props,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 147\n    }\n  }));\n  Wrapped.displayName = `profiler(${componentDisplayName})`;\n\n  // Copy over static methods from Wrapped component to Profiler HOC\n  // See: https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over\n  hoistNonReactStatics(Wrapped, WrappedComponent);\n  return Wrapped;\n}\n\n/**\n *\n * `useProfiler` is a React hook that profiles a React component.\n *\n * Requires React 16.8 or above.\n * @param name displayName of component being profiled\n */\nfunction useProfiler(name) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    disabled: false,\n    hasRenderSpan: true\n  };\n  const [mountSpan] = React.useState(() => {\n    if (options && options.disabled) {\n      return undefined;\n    }\n    const activeTransaction = getActiveTransaction();\n    if (activeTransaction) {\n      return activeTransaction.startChild({\n        description: `<${name}>`,\n        op: REACT_MOUNT_OP\n      });\n    }\n    return undefined;\n  });\n  React.useEffect(() => {\n    if (mountSpan) {\n      mountSpan.finish();\n    }\n    return () => {\n      if (mountSpan && options.hasRenderSpan) {\n        mountSpan.startChild({\n          description: `<${name}>`,\n          endTimestamp: timestampInSeconds(),\n          op: REACT_RENDER_OP,\n          startTimestamp: mountSpan.endTimestamp\n        });\n      }\n    };\n    // We only want this to run once.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n}\n\n/** Grabs active transaction off scope */\nfunction getActiveTransaction() {\n  let hub = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getCurrentHub();\n  if (hub) {\n    const scope = hub.getScope();\n    if (scope) {\n      return scope.getTransaction();\n    }\n  }\n  return undefined;\n}\nexport { Profiler, UNKNOWN_COMPONENT, getActiveTransaction, useProfiler, withProfiler };","map":{"version":3,"names":["_jsxFileName","UNKNOWN_COMPONENT","Profiler","React","Component","__init","_mountSpan","undefined","__init2","_updateSpan","__initStatic","defaultProps","disabled","includeRender","includeUpdates","constructor","props","prototype","call","name","activeTransaction","getActiveTransaction","startChild","description","op","REACT_MOUNT_OP","componentDidMount","finish","shouldComponentUpdate","_ref","updateProps","changedProps","Object","keys","filter","k","length","now","timestampInSeconds","data","REACT_UPDATE_OP","startTimestamp","componentDidUpdate","componentWillUnmount","endTimestamp","REACT_RENDER_OP","render","children","withProfiler","WrappedComponent","options","componentDisplayName","displayName","Wrapped","createElement","__self","__source","fileName","lineNumber","hoistNonReactStatics","useProfiler","arguments","hasRenderSpan","mountSpan","useState","useEffect","hub","getCurrentHub","scope","getScope","getTransaction"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/profiler.tsx"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { Hub } from '@sentry/browser';\nimport { getCurrentHub } from '@sentry/browser';\nimport type { Span, Transaction } from '@sentry/types';\nimport { timestampInSeconds } from '@sentry/utils';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport * as React from 'react';\n\nimport { REACT_MOUNT_OP, REACT_RENDER_OP, REACT_UPDATE_OP } from './constants';\n\nexport const UNKNOWN_COMPONENT = 'unknown';\n\nexport type ProfilerProps = {\n  // The name of the component being profiled.\n  name: string;\n  // If the Profiler is disabled. False by default. This is useful if you want to disable profilers\n  // in certain environments.\n  disabled?: boolean;\n  // If time component is on page should be displayed as spans. True by default.\n  includeRender?: boolean;\n  // If component updates should be displayed as spans. True by default.\n  includeUpdates?: boolean;\n  // Component that is being profiled.\n  children?: React.ReactNode;\n  // props given to component being profiled.\n  updateProps: { [key: string]: unknown };\n};\n\n/**\n * The Profiler component leverages Sentry's Tracing integration to generate\n * spans based on component lifecycles.\n */\nclass Profiler extends React.Component<ProfilerProps> {\n  /**\n   * The span of the mount activity\n   * Made protected for the React Native SDK to access\n   */\n  protected _mountSpan: Span | undefined = undefined;\n  /**\n   * The span that represents the duration of time between shouldComponentUpdate and componentDidUpdate\n   */\n  protected _updateSpan: Span | undefined = undefined;\n\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  public static defaultProps: Partial<ProfilerProps> = {\n    disabled: false,\n    includeRender: true,\n    includeUpdates: true,\n  };\n\n  public constructor(props: ProfilerProps) {\n    super(props);\n    const { name, disabled = false } = this.props;\n\n    if (disabled) {\n      return;\n    }\n\n    const activeTransaction = getActiveTransaction();\n    if (activeTransaction) {\n      this._mountSpan = activeTransaction.startChild({\n        description: `<${name}>`,\n        op: REACT_MOUNT_OP,\n      });\n    }\n  }\n\n  // If a component mounted, we can finish the mount activity.\n  public componentDidMount(): void {\n    if (this._mountSpan) {\n      this._mountSpan.finish();\n    }\n  }\n\n  public shouldComponentUpdate({ updateProps, includeUpdates = true }: ProfilerProps): boolean {\n    // Only generate an update span if includeUpdates is true, if there is a valid mountSpan,\n    // and if the updateProps have changed. It is ok to not do a deep equality check here as it is expensive.\n    // We are just trying to give baseline clues for further investigation.\n    if (includeUpdates && this._mountSpan && updateProps !== this.props.updateProps) {\n      // See what props haved changed between the previous props, and the current props. This is\n      // set as data on the span. We just store the prop keys as the values could be potenially very large.\n      const changedProps = Object.keys(updateProps).filter(k => updateProps[k] !== this.props.updateProps[k]);\n      if (changedProps.length > 0) {\n        const now = timestampInSeconds();\n        this._updateSpan = this._mountSpan.startChild({\n          data: {\n            changedProps,\n          },\n          description: `<${this.props.name}>`,\n          op: REACT_UPDATE_OP,\n          startTimestamp: now,\n        });\n      }\n    }\n\n    return true;\n  }\n\n  public componentDidUpdate(): void {\n    if (this._updateSpan) {\n      this._updateSpan.finish();\n      this._updateSpan = undefined;\n    }\n  }\n\n  // If a component is unmounted, we can say it is no longer on the screen.\n  // This means we can finish the span representing the component render.\n  public componentWillUnmount(): void {\n    const { name, includeRender = true } = this.props;\n\n    if (this._mountSpan && includeRender) {\n      // If we were able to obtain the spanId of the mount activity, we should set the\n      // next activity as a child to the component mount activity.\n      this._mountSpan.startChild({\n        description: `<${name}>`,\n        endTimestamp: timestampInSeconds(),\n        op: REACT_RENDER_OP,\n        startTimestamp: this._mountSpan.endTimestamp,\n      });\n    }\n  }\n\n  public render(): React.ReactNode {\n    return this.props.children;\n  }\n}\n\n/**\n * withProfiler is a higher order component that wraps a\n * component in a {@link Profiler} component. It is recommended that\n * the higher order component be used over the regular {@link Profiler} component.\n *\n * @param WrappedComponent component that is wrapped by Profiler\n * @param options the {@link ProfilerProps} you can pass into the Profiler\n */\nfunction withProfiler<P extends Record<string, any>>(\n  WrappedComponent: React.ComponentType<P>,\n  // We do not want to have `updateProps` given in options, it is instead filled through the HOC.\n  options?: Pick<Partial<ProfilerProps>, Exclude<keyof ProfilerProps, 'updateProps' | 'children'>>,\n): React.FC<P> {\n  const componentDisplayName =\n    (options && options.name) || WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT;\n\n  const Wrapped: React.FC<P> = (props: P) => (\n    <Profiler {...options} name={componentDisplayName} updateProps={props}>\n      <WrappedComponent {...props} />\n    </Profiler>\n  );\n\n  Wrapped.displayName = `profiler(${componentDisplayName})`;\n\n  // Copy over static methods from Wrapped component to Profiler HOC\n  // See: https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over\n  hoistNonReactStatics(Wrapped, WrappedComponent);\n  return Wrapped;\n}\n\n/**\n *\n * `useProfiler` is a React hook that profiles a React component.\n *\n * Requires React 16.8 or above.\n * @param name displayName of component being profiled\n */\nfunction useProfiler(\n  name: string,\n  options: { disabled?: boolean; hasRenderSpan?: boolean } = {\n    disabled: false,\n    hasRenderSpan: true,\n  },\n): void {\n  const [mountSpan] = React.useState(() => {\n    if (options && options.disabled) {\n      return undefined;\n    }\n\n    const activeTransaction = getActiveTransaction();\n    if (activeTransaction) {\n      return activeTransaction.startChild({\n        description: `<${name}>`,\n        op: REACT_MOUNT_OP,\n      });\n    }\n\n    return undefined;\n  });\n\n  React.useEffect(() => {\n    if (mountSpan) {\n      mountSpan.finish();\n    }\n\n    return (): void => {\n      if (mountSpan && options.hasRenderSpan) {\n        mountSpan.startChild({\n          description: `<${name}>`,\n          endTimestamp: timestampInSeconds(),\n          op: REACT_RENDER_OP,\n          startTimestamp: mountSpan.endTimestamp,\n        });\n      }\n    };\n    // We only want this to run once.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n}\n\nexport { withProfiler, Profiler, useProfiler };\n\n/** Grabs active transaction off scope */\nexport function getActiveTransaction<T extends Transaction>(hub: Hub = getCurrentHub()): T | undefined {\n  if (hub) {\n    const scope = hub.getScope();\n    if (scope) {\n      return scope.getTransaction() as T | undefined;\n    }\n  }\n\n  return undefined;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}