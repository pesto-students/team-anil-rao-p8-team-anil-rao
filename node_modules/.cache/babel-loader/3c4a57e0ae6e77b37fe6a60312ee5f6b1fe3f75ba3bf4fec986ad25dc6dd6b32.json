{"ast":null,"code":"import { logger, timestampInSeconds } from '@sentry/utils';\nimport { SpanRecorder } from './span.js';\nimport { Transaction } from './transaction.js';\nconst TRACING_DEFAULTS = {\n  idleTimeout: 1000,\n  finalTimeout: 30000,\n  heartbeatInterval: 5000\n};\nconst FINISH_REASON_TAG = 'finishReason';\nconst IDLE_TRANSACTION_FINISH_REASONS = ['heartbeatFailed', 'idleTimeout', 'documentHidden', 'finalTimeout', 'externalFinish', 'cancelled'];\n\n/**\n * @inheritDoc\n */\nclass IdleTransactionSpanRecorder extends SpanRecorder {\n  constructor(_pushActivity, _popActivity, transactionSpanId, maxlen) {\n    super(maxlen);\n    this._pushActivity = _pushActivity;\n    this._popActivity = _popActivity;\n    this.transactionSpanId = transactionSpanId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  add(span) {\n    // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n    if (span.spanId !== this.transactionSpanId) {\n      // We patch span.finish() to pop an activity after setting an endTimestamp.\n      span.finish = endTimestamp => {\n        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampInSeconds();\n        this._popActivity(span.spanId);\n      };\n\n      // We should only push new activities if the span does not have an end timestamp.\n      if (span.endTimestamp === undefined) {\n        this._pushActivity(span.spanId);\n      }\n    }\n    super.add(span);\n  }\n}\n\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nclass IdleTransaction extends Transaction {\n  // Activities store a list of active spans\n  __init() {\n    this.activities = {};\n  }\n\n  // Track state of activities in previous heartbeat\n\n  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n  __init2() {\n    this._heartbeatCounter = 0;\n  }\n\n  // We should not use heartbeat if we finished a transaction\n  __init3() {\n    this._finished = false;\n  }\n\n  // Idle timeout was canceled and we should finish the transaction with the last span end.\n  __init4() {\n    this._idleTimeoutCanceledPermanently = false;\n  }\n  __init5() {\n    this._beforeFinishCallbacks = [];\n  }\n\n  /**\n   * Timer that tracks Transaction idleTimeout\n   */\n\n  __init6() {\n    this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[4];\n  }\n  constructor(transactionContext, _idleHub) {\n    let _idleTimeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TRACING_DEFAULTS.idleTimeout;\n    let _finalTimeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TRACING_DEFAULTS.finalTimeout;\n    let _heartbeatInterval = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : TRACING_DEFAULTS.heartbeatInterval;\n    let _onScope = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    super(transactionContext, _idleHub);\n    this._idleHub = _idleHub;\n    this._idleTimeout = _idleTimeout;\n    this._finalTimeout = _finalTimeout;\n    this._heartbeatInterval = _heartbeatInterval;\n    this._onScope = _onScope;\n    IdleTransaction.prototype.__init.call(this);\n    IdleTransaction.prototype.__init2.call(this);\n    IdleTransaction.prototype.__init3.call(this);\n    IdleTransaction.prototype.__init4.call(this);\n    IdleTransaction.prototype.__init5.call(this);\n    IdleTransaction.prototype.__init6.call(this);\n    if (_onScope) {\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`);\n      _idleHub.configureScope(scope => scope.setSpan(this));\n    }\n    this._restartIdleTimeout();\n    setTimeout(() => {\n      if (!this._finished) {\n        this.setStatus('deadline_exceeded');\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[3];\n        this.finish();\n      }\n    }, this._finalTimeout);\n  }\n\n  /** {@inheritDoc} */\n  finish() {\n    let endTimestamp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : timestampInSeconds();\n    this._finished = true;\n    this.activities = {};\n    if (this.op === 'ui.action.click') {\n      this.setTag(FINISH_REASON_TAG, this._finishReason);\n    }\n    if (this.spanRecorder) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n      for (const callback of this._beforeFinishCallbacks) {\n        callback(this, endTimestamp);\n      }\n      this.spanRecorder.spans = this.spanRecorder.spans.filter(span => {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanId === this.spanId) {\n          return true;\n        }\n\n        // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n        if (!span.endTimestamp) {\n          span.endTimestamp = endTimestamp;\n          span.setStatus('cancelled');\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n        const keepSpan = span.startTimestamp < endTimestamp;\n        if (!keepSpan) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] discarding Span since it happened after Transaction was finished', JSON.stringify(span, undefined, 2));\n        }\n        return keepSpan;\n      });\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] flushing IdleTransaction');\n    } else {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] No active IdleTransaction');\n    }\n\n    // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n    if (this._onScope) {\n      const scope = this._idleHub.getScope();\n      if (scope.getTransaction() === this) {\n        scope.setSpan(undefined);\n      }\n    }\n    return super.finish(endTimestamp);\n  }\n\n  /**\n   * Register a callback function that gets excecuted before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n  registerBeforeFinishCallback(callback) {\n    this._beforeFinishCallbacks.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  initSpanRecorder(maxlen) {\n    if (!this.spanRecorder) {\n      const pushActivity = id => {\n        if (this._finished) {\n          return;\n        }\n        this._pushActivity(id);\n      };\n      const popActivity = id => {\n        if (this._finished) {\n          return;\n        }\n        this._popActivity(id);\n      };\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);\n\n      // Start heartbeat so that transactions do not run forever.\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('Starting heartbeat');\n      this._pingHeartbeat();\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Cancels the existing idle timeout, if there is one.\n   * @param restartOnChildSpanChange Default is `true`.\n   *                                 If set to false the transaction will end\n   *                                 with the last child span.\n   */\n  cancelIdleTimeout(endTimestamp) {\n    let {\n      restartOnChildSpanChange\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      restartOnChildSpanChange: true\n    };\n    this._idleTimeoutCanceledPermanently = restartOnChildSpanChange === false;\n    if (this._idleTimeoutID) {\n      clearTimeout(this._idleTimeoutID);\n      this._idleTimeoutID = undefined;\n      if (Object.keys(this.activities).length === 0 && this._idleTimeoutCanceledPermanently) {\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];\n        this.finish(endTimestamp);\n      }\n    }\n  }\n\n  /**\n   * Temporary method used to externally set the transaction's `finishReason`\n   *\n   * ** WARNING**\n   * This is for the purpose of experimentation only and will be removed in the near future, do not use!\n   *\n   * @internal\n   *\n   */\n  setFinishReason(reason) {\n    this._finishReason = reason;\n  }\n\n  /**\n   * Restarts idle timeout, if there is no running idle timeout it will start one.\n   */\n  _restartIdleTimeout(endTimestamp) {\n    this.cancelIdleTimeout();\n    this._idleTimeoutID = setTimeout(() => {\n      if (!this._finished && Object.keys(this.activities).length === 0) {\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[1];\n        this.finish(endTimestamp);\n      }\n    }, this._idleTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  _pushActivity(spanId) {\n    this.cancelIdleTimeout(undefined, {\n      restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently\n    });\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] pushActivity: ${spanId}`);\n    this.activities[spanId] = true;\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  _popActivity(spanId) {\n    if (this.activities[spanId]) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] popActivity ${spanId}`);\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this.activities[spanId];\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n    if (Object.keys(this.activities).length === 0) {\n      const endTimestamp = timestampInSeconds();\n      if (this._idleTimeoutCanceledPermanently) {\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];\n        this.finish(endTimestamp);\n      } else {\n        // We need to add the timeout here to have the real endtimestamp of the transaction\n        // Remember timestampInSeconds is in seconds, timeout is in ms\n        this._restartIdleTimeout(endTimestamp + this._idleTimeout / 1000);\n      }\n    }\n  }\n\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n  _beat() {\n    // We should not be running heartbeat if the idle transaction is finished.\n    if (this._finished) {\n      return;\n    }\n    const heartbeatString = Object.keys(this.activities).join('');\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter++;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n    this._prevHeartbeatString = heartbeatString;\n    if (this._heartbeatCounter >= 3) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n      this.setStatus('deadline_exceeded');\n      this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[0];\n      this.finish();\n    } else {\n      this._pingHeartbeat();\n    }\n  }\n\n  /**\n   * Pings the heartbeat\n   */\n  _pingHeartbeat() {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);\n    setTimeout(() => {\n      this._beat();\n    }, this._heartbeatInterval);\n  }\n}\nexport { IdleTransaction, IdleTransactionSpanRecorder, TRACING_DEFAULTS };","map":{"version":3,"names":["TRACING_DEFAULTS","idleTimeout","finalTimeout","heartbeatInterval","FINISH_REASON_TAG","IDLE_TRANSACTION_FINISH_REASONS","IdleTransactionSpanRecorder","SpanRecorder","constructor","_pushActivity","_popActivity","transactionSpanId","maxlen","add","span","spanId","finish","endTimestamp","timestampInSeconds","undefined","IdleTransaction","Transaction","__init","activities","__init2","_heartbeatCounter","__init3","_finished","__init4","_idleTimeoutCanceledPermanently","__init5","_beforeFinishCallbacks","__init6","_finishReason","transactionContext","_idleHub","_idleTimeout","arguments","length","_finalTimeout","_heartbeatInterval","_onScope","prototype","call","__SENTRY_DEBUG__","logger","log","configureScope","scope","setSpan","_restartIdleTimeout","setTimeout","setStatus","op","setTag","spanRecorder","Date","toISOString","callback","spans","filter","JSON","stringify","keepSpan","startTimestamp","getScope","getTransaction","registerBeforeFinishCallback","push","initSpanRecorder","pushActivity","id","popActivity","_pingHeartbeat","cancelIdleTimeout","restartOnChildSpanChange","_idleTimeoutID","clearTimeout","Object","keys","setFinishReason","reason","_beat","heartbeatString","join","_prevHeartbeatString"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/tracing/idletransaction.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type { TransactionContext } from '@sentry/types';\nimport { logger, timestampInSeconds } from '@sentry/utils';\n\nimport type { Hub } from '../hub';\nimport type { Span } from './span';\nimport { SpanRecorder } from './span';\nimport { Transaction } from './transaction';\n\nexport const TRACING_DEFAULTS = {\n  idleTimeout: 1000,\n  finalTimeout: 30000,\n  heartbeatInterval: 5000,\n};\n\nconst FINISH_REASON_TAG = 'finishReason';\n\nconst IDLE_TRANSACTION_FINISH_REASONS = [\n  'heartbeatFailed',\n  'idleTimeout',\n  'documentHidden',\n  'finalTimeout',\n  'externalFinish',\n  'cancelled',\n];\n\n/**\n * @inheritDoc\n */\nexport class IdleTransactionSpanRecorder extends SpanRecorder {\n  public constructor(\n    private readonly _pushActivity: (id: string) => void,\n    private readonly _popActivity: (id: string) => void,\n    public transactionSpanId: string,\n    maxlen?: number,\n  ) {\n    super(maxlen);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public add(span: Span): void {\n    // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n    if (span.spanId !== this.transactionSpanId) {\n      // We patch span.finish() to pop an activity after setting an endTimestamp.\n      span.finish = (endTimestamp?: number) => {\n        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampInSeconds();\n        this._popActivity(span.spanId);\n      };\n\n      // We should only push new activities if the span does not have an end timestamp.\n      if (span.endTimestamp === undefined) {\n        this._pushActivity(span.spanId);\n      }\n    }\n\n    super.add(span);\n  }\n}\n\nexport type BeforeFinishCallback = (transactionSpan: IdleTransaction, endTimestamp: number) => void;\n\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nexport class IdleTransaction extends Transaction {\n  // Activities store a list of active spans\n  public activities: Record<string, boolean> = {};\n\n  // Track state of activities in previous heartbeat\n  private _prevHeartbeatString: string | undefined;\n\n  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n  private _heartbeatCounter: number = 0;\n\n  // We should not use heartbeat if we finished a transaction\n  private _finished: boolean = false;\n\n  // Idle timeout was canceled and we should finish the transaction with the last span end.\n  private _idleTimeoutCanceledPermanently: boolean = false;\n\n  private readonly _beforeFinishCallbacks: BeforeFinishCallback[] = [];\n\n  /**\n   * Timer that tracks Transaction idleTimeout\n   */\n  private _idleTimeoutID: ReturnType<typeof setTimeout> | undefined;\n\n  private _finishReason: (typeof IDLE_TRANSACTION_FINISH_REASONS)[number] = IDLE_TRANSACTION_FINISH_REASONS[4];\n\n  public constructor(\n    transactionContext: TransactionContext,\n    private readonly _idleHub: Hub,\n    /**\n     * The time to wait in ms until the idle transaction will be finished. This timer is started each time\n     * there are no active spans on this transaction.\n     */\n    private readonly _idleTimeout: number = TRACING_DEFAULTS.idleTimeout,\n    /**\n     * The final value in ms that a transaction cannot exceed\n     */\n    private readonly _finalTimeout: number = TRACING_DEFAULTS.finalTimeout,\n    private readonly _heartbeatInterval: number = TRACING_DEFAULTS.heartbeatInterval,\n    // Whether or not the transaction should put itself on the scope when it starts and pop itself off when it ends\n    private readonly _onScope: boolean = false,\n  ) {\n    super(transactionContext, _idleHub);\n\n    if (_onScope) {\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      __DEBUG_BUILD__ && logger.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`);\n      _idleHub.configureScope(scope => scope.setSpan(this));\n    }\n\n    this._restartIdleTimeout();\n    setTimeout(() => {\n      if (!this._finished) {\n        this.setStatus('deadline_exceeded');\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[3];\n        this.finish();\n      }\n    }, this._finalTimeout);\n  }\n\n  /** {@inheritDoc} */\n  public finish(endTimestamp: number = timestampInSeconds()): string | undefined {\n    this._finished = true;\n    this.activities = {};\n\n    if (this.op === 'ui.action.click') {\n      this.setTag(FINISH_REASON_TAG, this._finishReason);\n    }\n\n    if (this.spanRecorder) {\n      __DEBUG_BUILD__ &&\n        logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n\n      for (const callback of this._beforeFinishCallbacks) {\n        callback(this, endTimestamp);\n      }\n\n      this.spanRecorder.spans = this.spanRecorder.spans.filter((span: Span) => {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanId === this.spanId) {\n          return true;\n        }\n\n        // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n        if (!span.endTimestamp) {\n          span.endTimestamp = endTimestamp;\n          span.setStatus('cancelled');\n          __DEBUG_BUILD__ &&\n            logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n\n        const keepSpan = span.startTimestamp < endTimestamp;\n        if (!keepSpan) {\n          __DEBUG_BUILD__ &&\n            logger.log(\n              '[Tracing] discarding Span since it happened after Transaction was finished',\n              JSON.stringify(span, undefined, 2),\n            );\n        }\n        return keepSpan;\n      });\n\n      __DEBUG_BUILD__ && logger.log('[Tracing] flushing IdleTransaction');\n    } else {\n      __DEBUG_BUILD__ && logger.log('[Tracing] No active IdleTransaction');\n    }\n\n    // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n    if (this._onScope) {\n      const scope = this._idleHub.getScope();\n      if (scope.getTransaction() === this) {\n        scope.setSpan(undefined);\n      }\n    }\n\n    return super.finish(endTimestamp);\n  }\n\n  /**\n   * Register a callback function that gets excecuted before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n  public registerBeforeFinishCallback(callback: BeforeFinishCallback): void {\n    this._beforeFinishCallbacks.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public initSpanRecorder(maxlen?: number): void {\n    if (!this.spanRecorder) {\n      const pushActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._pushActivity(id);\n      };\n      const popActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._popActivity(id);\n      };\n\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);\n\n      // Start heartbeat so that transactions do not run forever.\n      __DEBUG_BUILD__ && logger.log('Starting heartbeat');\n      this._pingHeartbeat();\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Cancels the existing idle timeout, if there is one.\n   * @param restartOnChildSpanChange Default is `true`.\n   *                                 If set to false the transaction will end\n   *                                 with the last child span.\n   */\n  public cancelIdleTimeout(\n    endTimestamp?: Parameters<IdleTransaction['finish']>[0],\n    {\n      restartOnChildSpanChange,\n    }: {\n      restartOnChildSpanChange?: boolean;\n    } = {\n      restartOnChildSpanChange: true,\n    },\n  ): void {\n    this._idleTimeoutCanceledPermanently = restartOnChildSpanChange === false;\n    if (this._idleTimeoutID) {\n      clearTimeout(this._idleTimeoutID);\n      this._idleTimeoutID = undefined;\n\n      if (Object.keys(this.activities).length === 0 && this._idleTimeoutCanceledPermanently) {\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];\n        this.finish(endTimestamp);\n      }\n    }\n  }\n\n  /**\n   * Temporary method used to externally set the transaction's `finishReason`\n   *\n   * ** WARNING**\n   * This is for the purpose of experimentation only and will be removed in the near future, do not use!\n   *\n   * @internal\n   *\n   */\n  public setFinishReason(reason: string): void {\n    this._finishReason = reason;\n  }\n\n  /**\n   * Restarts idle timeout, if there is no running idle timeout it will start one.\n   */\n  private _restartIdleTimeout(endTimestamp?: Parameters<IdleTransaction['finish']>[0]): void {\n    this.cancelIdleTimeout();\n    this._idleTimeoutID = setTimeout(() => {\n      if (!this._finished && Object.keys(this.activities).length === 0) {\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[1];\n        this.finish(endTimestamp);\n      }\n    }, this._idleTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  private _pushActivity(spanId: string): void {\n    this.cancelIdleTimeout(undefined, { restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently });\n    __DEBUG_BUILD__ && logger.log(`[Tracing] pushActivity: ${spanId}`);\n    this.activities[spanId] = true;\n    __DEBUG_BUILD__ && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  private _popActivity(spanId: string): void {\n    if (this.activities[spanId]) {\n      __DEBUG_BUILD__ && logger.log(`[Tracing] popActivity ${spanId}`);\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this.activities[spanId];\n      __DEBUG_BUILD__ && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n\n    if (Object.keys(this.activities).length === 0) {\n      const endTimestamp = timestampInSeconds();\n      if (this._idleTimeoutCanceledPermanently) {\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];\n        this.finish(endTimestamp);\n      } else {\n        // We need to add the timeout here to have the real endtimestamp of the transaction\n        // Remember timestampInSeconds is in seconds, timeout is in ms\n        this._restartIdleTimeout(endTimestamp + this._idleTimeout / 1000);\n      }\n    }\n  }\n\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n  private _beat(): void {\n    // We should not be running heartbeat if the idle transaction is finished.\n    if (this._finished) {\n      return;\n    }\n\n    const heartbeatString = Object.keys(this.activities).join('');\n\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter++;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n\n    this._prevHeartbeatString = heartbeatString;\n\n    if (this._heartbeatCounter >= 3) {\n      __DEBUG_BUILD__ && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n      this.setStatus('deadline_exceeded');\n      this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[0];\n      this.finish();\n    } else {\n      this._pingHeartbeat();\n    }\n  }\n\n  /**\n   * Pings the heartbeat\n   */\n  private _pingHeartbeat(): void {\n    __DEBUG_BUILD__ && logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);\n    setTimeout(() => {\n      this._beat();\n    }, this._heartbeatInterval);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}