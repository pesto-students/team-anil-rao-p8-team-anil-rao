{"ast":null,"code":"import { dsnFromString, forEachEnvelopeItem } from '@sentry/utils';\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from '../api.js';\nfunction eventFromEnvelope(env, types) {\n  let event;\n  forEachEnvelopeItem(env, (item, type) => {\n    if (types.includes(type)) {\n      event = Array.isArray(item) ? item[1] : undefined;\n    }\n    // bail out if we found an event\n    return !!event;\n  });\n  return event;\n}\n\n/**\n * Creates a transport that can send events to different DSNs depending on the envelope contents.\n */\nfunction makeMultiplexedTransport(createTransport, matcher) {\n  return options => {\n    const fallbackTransport = createTransport(options);\n    const otherTransports = {};\n    function getTransport(dsn) {\n      if (!otherTransports[dsn]) {\n        const validatedDsn = dsnFromString(dsn);\n        if (!validatedDsn) {\n          return undefined;\n        }\n        const url = getEnvelopeEndpointWithUrlEncodedAuth(validatedDsn);\n        otherTransports[dsn] = createTransport({\n          ...options,\n          url\n        });\n      }\n      return otherTransports[dsn];\n    }\n    async function send(envelope) {\n      function getEvent(types) {\n        const eventTypes = types && types.length ? types : ['event'];\n        return eventFromEnvelope(envelope, eventTypes);\n      }\n      const transports = matcher({\n        envelope,\n        getEvent\n      }).map(dsn => getTransport(dsn)).filter(t => !!t);\n\n      // If we have no transports to send to, use the fallback transport\n      if (transports.length === 0) {\n        transports.push(fallbackTransport);\n      }\n      const results = await Promise.all(transports.map(transport => transport.send(envelope)));\n      return results[0];\n    }\n    async function flush(timeout) {\n      const allTransports = [...Object.keys(otherTransports).map(dsn => otherTransports[dsn]), fallbackTransport];\n      const results = await Promise.all(allTransports.map(transport => transport.flush(timeout)));\n      return results.every(r => r);\n    }\n    return {\n      send,\n      flush\n    };\n  };\n}\nexport { makeMultiplexedTransport };","map":{"version":3,"names":["eventFromEnvelope","env","types","event","forEachEnvelopeItem","item","type","includes","Array","isArray","undefined","makeMultiplexedTransport","createTransport","matcher","options","fallbackTransport","otherTransports","getTransport","dsn","validatedDsn","dsnFromString","url","getEnvelopeEndpointWithUrlEncodedAuth","send","envelope","getEvent","eventTypes","length","transports","map","filter","t","push","results","Promise","all","transport","flush","timeout","allTransports","Object","keys","every","r"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/transports/multiplexed.ts"],"sourcesContent":["import type {\n  BaseTransportOptions,\n  Envelope,\n  EnvelopeItemType,\n  Event,\n  EventItem,\n  Transport,\n  TransportMakeRequestResponse,\n} from '@sentry/types';\nimport { dsnFromString, forEachEnvelopeItem } from '@sentry/utils';\n\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from '../api';\n\ninterface MatchParam {\n  /** The envelope to be sent */\n  envelope: Envelope;\n  /**\n   * A function that returns an event from the envelope if one exists. You can optionally pass an array of envelope item\n   * types to filter by - only envelopes matching the given types will be multiplexed.\n   * Allowed values are: 'event', 'transaction', 'profile', 'replay_event'\n   *\n   * @param types Defaults to ['event']\n   */\n  getEvent(types?: EnvelopeItemType[]): Event | undefined;\n}\n\ntype Matcher = (param: MatchParam) => string[];\n\nfunction eventFromEnvelope(env: Envelope, types: EnvelopeItemType[]): Event | undefined {\n  let event: Event | undefined;\n\n  forEachEnvelopeItem(env, (item, type) => {\n    if (types.includes(type)) {\n      event = Array.isArray(item) ? (item as EventItem)[1] : undefined;\n    }\n    // bail out if we found an event\n    return !!event;\n  });\n\n  return event;\n}\n\n/**\n * Creates a transport that can send events to different DSNs depending on the envelope contents.\n */\nexport function makeMultiplexedTransport<TO extends BaseTransportOptions>(\n  createTransport: (options: TO) => Transport,\n  matcher: Matcher,\n): (options: TO) => Transport {\n  return options => {\n    const fallbackTransport = createTransport(options);\n    const otherTransports: Record<string, Transport> = {};\n\n    function getTransport(dsn: string): Transport | undefined {\n      if (!otherTransports[dsn]) {\n        const validatedDsn = dsnFromString(dsn);\n        if (!validatedDsn) {\n          return undefined;\n        }\n        const url = getEnvelopeEndpointWithUrlEncodedAuth(validatedDsn);\n        otherTransports[dsn] = createTransport({ ...options, url });\n      }\n\n      return otherTransports[dsn];\n    }\n\n    async function send(envelope: Envelope): Promise<void | TransportMakeRequestResponse> {\n      function getEvent(types?: EnvelopeItemType[]): Event | undefined {\n        const eventTypes: EnvelopeItemType[] = types && types.length ? types : ['event'];\n        return eventFromEnvelope(envelope, eventTypes);\n      }\n\n      const transports = matcher({ envelope, getEvent })\n        .map(dsn => getTransport(dsn))\n        .filter((t): t is Transport => !!t);\n\n      // If we have no transports to send to, use the fallback transport\n      if (transports.length === 0) {\n        transports.push(fallbackTransport);\n      }\n\n      const results = await Promise.all(transports.map(transport => transport.send(envelope)));\n\n      return results[0];\n    }\n\n    async function flush(timeout: number | undefined): Promise<boolean> {\n      const allTransports = [...Object.keys(otherTransports).map(dsn => otherTransports[dsn]), fallbackTransport];\n      const results = await Promise.all(allTransports.map(transport => transport.flush(timeout)));\n      return results.every(r => r);\n    }\n\n    return {\n      send,\n      flush,\n    };\n  };\n}\n"],"mappings":";;AA4BA,SAAAA,kBAAAC,GAAA,EAAAC,KAAA;EACA,IAAAC,KAAA;EAEAC,mBAAA,CAAAH,GAAA,GAAAI,IAAA,EAAAC,IAAA;IACA,IAAAJ,KAAA,CAAAK,QAAA,CAAAD,IAAA;MACAH,KAAA,GAAAK,KAAA,CAAAC,OAAA,CAAAJ,IAAA,IAAAA,IAAA,MAAAK,SAAA;IACA;IACA;IACA,SAAAP,KAAA;EACA;EAEA,OAAAA,KAAA;AACA;;AAEA;AACA;AACA;AACA,SAAAQ,yBACAC,eAAA,EACAC,OAAA,EACA;EACA,OAAAC,OAAA;IACA,MAAAC,iBAAA,GAAAH,eAAA,CAAAE,OAAA;IACA,MAAAE,eAAA;IAEA,SAAAC,aAAAC,GAAA;MACA,KAAAF,eAAA,CAAAE,GAAA;QACA,MAAAC,YAAA,GAAAC,aAAA,CAAAF,GAAA;QACA,KAAAC,YAAA;UACA,OAAAT,SAAA;QACA;QACA,MAAAW,GAAA,GAAAC,qCAAA,CAAAH,YAAA;QACAH,eAAA,CAAAE,GAAA,IAAAN,eAAA;UAAA,GAAAE,OAAA;UAAAO;QAAA;MACA;MAEA,OAAAL,eAAA,CAAAE,GAAA;IACA;IAEA,eAAAK,KAAAC,QAAA;MACA,SAAAC,SAAAvB,KAAA;QACA,MAAAwB,UAAA,GAAAxB,KAAA,IAAAA,KAAA,CAAAyB,MAAA,GAAAzB,KAAA;QACA,OAAAF,iBAAA,CAAAwB,QAAA,EAAAE,UAAA;MACA;MAEA,MAAAE,UAAA,GAAAf,OAAA;QAAAW,QAAA;QAAAC;MAAA,GACAI,GAAA,CAAAX,GAAA,IAAAD,YAAA,CAAAC,GAAA,GACAY,MAAA,CAAAC,CAAA,MAAAA,CAAA;;MAEA;MACA,IAAAH,UAAA,CAAAD,MAAA;QACAC,UAAA,CAAAI,IAAA,CAAAjB,iBAAA;MACA;MAEA,MAAAkB,OAAA,SAAAC,OAAA,CAAAC,GAAA,CAAAP,UAAA,CAAAC,GAAA,CAAAO,SAAA,IAAAA,SAAA,CAAAb,IAAA,CAAAC,QAAA;MAEA,OAAAS,OAAA;IACA;IAEA,eAAAI,MAAAC,OAAA;MACA,MAAAC,aAAA,OAAAC,MAAA,CAAAC,IAAA,CAAAzB,eAAA,EAAAa,GAAA,CAAAX,GAAA,IAAAF,eAAA,CAAAE,GAAA,IAAAH,iBAAA;MACA,MAAAkB,OAAA,SAAAC,OAAA,CAAAC,GAAA,CAAAI,aAAA,CAAAV,GAAA,CAAAO,SAAA,IAAAA,SAAA,CAAAC,KAAA,CAAAC,OAAA;MACA,OAAAL,OAAA,CAAAS,KAAA,CAAAC,CAAA,IAAAA,CAAA;IACA;IAEA;MACApB,IAAA;MACAc;IACA;EACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}