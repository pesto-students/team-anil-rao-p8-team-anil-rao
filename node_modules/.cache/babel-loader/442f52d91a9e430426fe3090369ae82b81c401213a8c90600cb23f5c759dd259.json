{"ast":null,"code":"import { arrayify, logger } from '@sentry/utils';\nimport { getCurrentHub } from './hub.js';\nimport { addGlobalEventProcessor } from './scope.js';\nconst installedIntegrations = [];\n\n/** Map of integrations assigned to a client */\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preseve the order of integrations in the array.\n *\n * @private\n */\nfunction filterDuplicates(integrations) {\n  const integrationsByName = {};\n  integrations.forEach(currentInstance => {\n    const {\n      name\n    } = currentInstance;\n    const existingInstance = integrationsByName[name];\n\n    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n    integrationsByName[name] = currentInstance;\n  });\n  return Object.keys(integrationsByName).map(k => integrationsByName[k]);\n}\n\n/** Gets integrations to install */\nfunction getIntegrationsToSetup(options) {\n  const defaultIntegrations = options.defaultIntegrations || [];\n  const userIntegrations = options.integrations;\n\n  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n  defaultIntegrations.forEach(integration => {\n    integration.isDefaultInstance = true;\n  });\n  let integrations;\n  if (Array.isArray(userIntegrations)) {\n    integrations = [...defaultIntegrations, ...userIntegrations];\n  } else if (typeof userIntegrations === 'function') {\n    integrations = arrayify(userIntegrations(defaultIntegrations));\n  } else {\n    integrations = defaultIntegrations;\n  }\n  const finalIntegrations = filterDuplicates(integrations);\n\n  // The `Debug` integration prints copies of the `event` and `hint` which will be passed to `beforeSend` or\n  // `beforeSendTransaction`. It therefore has to run after all other integrations, so that the changes of all event\n  // processors will be reflected in the printed values. For lack of a more elegant way to guarantee that, we therefore\n  // locate it and, assuming it exists, pop it out of its current spot and shove it onto the end of the array.\n  const debugIndex = findIndex(finalIntegrations, integration => integration.name === 'Debug');\n  if (debugIndex !== -1) {\n    const [debugInstance] = finalIntegrations.splice(debugIndex, 1);\n    finalIntegrations.push(debugInstance);\n  }\n  return finalIntegrations;\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nfunction setupIntegrations(integrations) {\n  const integrationIndex = {};\n  integrations.forEach(integration => {\n    // guard against empty provided integrations\n    if (integration) {\n      setupIntegration(integration, integrationIndex);\n    }\n  });\n  return integrationIndex;\n}\n\n/** Setup a single integration.  */\nfunction setupIntegration(integration, integrationIndex) {\n  integrationIndex[integration.name] = integration;\n  if (installedIntegrations.indexOf(integration.name) === -1) {\n    integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n    installedIntegrations.push(integration.name);\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Integration installed: ${integration.name}`);\n  }\n}\n\n// Polyfill for Array.findIndex(), which is not supported in ES5\nfunction findIndex(arr, callback) {\n  for (let i = 0; i < arr.length; i++) {\n    if (callback(arr[i]) === true) {\n      return i;\n    }\n  }\n  return -1;\n}\nexport { getIntegrationsToSetup, installedIntegrations, setupIntegration, setupIntegrations };","map":{"version":3,"names":["installedIntegrations","filterDuplicates","integrations","integrationsByName","forEach","currentInstance","name","existingInstance","isDefaultInstance","Object","keys","map","k","getIntegrationsToSetup","options","defaultIntegrations","userIntegrations","integration","Array","isArray","arrayify","finalIntegrations","debugIndex","findIndex","debugInstance","splice","push","setupIntegrations","integrationIndex","setupIntegration","indexOf","setupOnce","addGlobalEventProcessor","getCurrentHub","__SENTRY_DEBUG__","logger","log","arr","callback","i","length"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/integration.ts"],"sourcesContent":["import type { Integration, Options } from '@sentry/types';\nimport { arrayify, logger } from '@sentry/utils';\n\nimport { getCurrentHub } from './hub';\nimport { addGlobalEventProcessor } from './scope';\n\ndeclare module '@sentry/types' {\n  interface Integration {\n    isDefaultInstance?: boolean;\n  }\n}\n\nexport const installedIntegrations: string[] = [];\n\n/** Map of integrations assigned to a client */\nexport type IntegrationIndex = {\n  [key: string]: Integration;\n};\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preseve the order of integrations in the array.\n *\n * @private\n */\nfunction filterDuplicates(integrations: Integration[]): Integration[] {\n  const integrationsByName: { [key: string]: Integration } = {};\n\n  integrations.forEach(currentInstance => {\n    const { name } = currentInstance;\n\n    const existingInstance = integrationsByName[name];\n\n    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n\n    integrationsByName[name] = currentInstance;\n  });\n\n  return Object.keys(integrationsByName).map(k => integrationsByName[k]);\n}\n\n/** Gets integrations to install */\nexport function getIntegrationsToSetup(options: Options): Integration[] {\n  const defaultIntegrations = options.defaultIntegrations || [];\n  const userIntegrations = options.integrations;\n\n  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n  defaultIntegrations.forEach(integration => {\n    integration.isDefaultInstance = true;\n  });\n\n  let integrations: Integration[];\n\n  if (Array.isArray(userIntegrations)) {\n    integrations = [...defaultIntegrations, ...userIntegrations];\n  } else if (typeof userIntegrations === 'function') {\n    integrations = arrayify(userIntegrations(defaultIntegrations));\n  } else {\n    integrations = defaultIntegrations;\n  }\n\n  const finalIntegrations = filterDuplicates(integrations);\n\n  // The `Debug` integration prints copies of the `event` and `hint` which will be passed to `beforeSend` or\n  // `beforeSendTransaction`. It therefore has to run after all other integrations, so that the changes of all event\n  // processors will be reflected in the printed values. For lack of a more elegant way to guarantee that, we therefore\n  // locate it and, assuming it exists, pop it out of its current spot and shove it onto the end of the array.\n  const debugIndex = findIndex(finalIntegrations, integration => integration.name === 'Debug');\n  if (debugIndex !== -1) {\n    const [debugInstance] = finalIntegrations.splice(debugIndex, 1);\n    finalIntegrations.push(debugInstance);\n  }\n\n  return finalIntegrations;\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nexport function setupIntegrations(integrations: Integration[]): IntegrationIndex {\n  const integrationIndex: IntegrationIndex = {};\n\n  integrations.forEach(integration => {\n    // guard against empty provided integrations\n    if (integration) {\n      setupIntegration(integration, integrationIndex);\n    }\n  });\n\n  return integrationIndex;\n}\n\n/** Setup a single integration.  */\nexport function setupIntegration(integration: Integration, integrationIndex: IntegrationIndex): void {\n  integrationIndex[integration.name] = integration;\n\n  if (installedIntegrations.indexOf(integration.name) === -1) {\n    integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n    installedIntegrations.push(integration.name);\n    __DEBUG_BUILD__ && logger.log(`Integration installed: ${integration.name}`);\n  }\n}\n\n// Polyfill for Array.findIndex(), which is not supported in ES5\nfunction findIndex<T>(arr: T[], callback: (item: T) => boolean): number {\n  for (let i = 0; i < arr.length; i++) {\n    if (callback(arr[i]) === true) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n"],"mappings":";;;AAYA,MAAAA,qBAAA;;AAEA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA,SAAAC,iBAAAC,YAAA;EACA,MAAAC,kBAAA;EAEAD,YAAA,CAAAE,OAAA,CAAAC,eAAA;IACA;MAAAC;IAAA,IAAAD,eAAA;IAEA,MAAAE,gBAAA,GAAAJ,kBAAA,CAAAG,IAAA;;IAEA;IACA;IACA,IAAAC,gBAAA,KAAAA,gBAAA,CAAAC,iBAAA,IAAAH,eAAA,CAAAG,iBAAA;MACA;IACA;IAEAL,kBAAA,CAAAG,IAAA,IAAAD,eAAA;EACA;EAEA,OAAAI,MAAA,CAAAC,IAAA,CAAAP,kBAAA,EAAAQ,GAAA,CAAAC,CAAA,IAAAT,kBAAA,CAAAS,CAAA;AACA;;AAEA;AACA,SAAAC,uBAAAC,OAAA;EACA,MAAAC,mBAAA,GAAAD,OAAA,CAAAC,mBAAA;EACA,MAAAC,gBAAA,GAAAF,OAAA,CAAAZ,YAAA;;EAEA;EACAa,mBAAA,CAAAX,OAAA,CAAAa,WAAA;IACAA,WAAA,CAAAT,iBAAA;EACA;EAEA,IAAAN,YAAA;EAEA,IAAAgB,KAAA,CAAAC,OAAA,CAAAH,gBAAA;IACAd,YAAA,OAAAa,mBAAA,KAAAC,gBAAA;EACA,kBAAAA,gBAAA;IACAd,YAAA,GAAAkB,QAAA,CAAAJ,gBAAA,CAAAD,mBAAA;EACA;IACAb,YAAA,GAAAa,mBAAA;EACA;EAEA,MAAAM,iBAAA,GAAApB,gBAAA,CAAAC,YAAA;;EAEA;EACA;EACA;EACA;EACA,MAAAoB,UAAA,GAAAC,SAAA,CAAAF,iBAAA,EAAAJ,WAAA,IAAAA,WAAA,CAAAX,IAAA;EACA,IAAAgB,UAAA;IACA,OAAAE,aAAA,IAAAH,iBAAA,CAAAI,MAAA,CAAAH,UAAA;IACAD,iBAAA,CAAAK,IAAA,CAAAF,aAAA;EACA;EAEA,OAAAH,iBAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAAM,kBAAAzB,YAAA;EACA,MAAA0B,gBAAA;EAEA1B,YAAA,CAAAE,OAAA,CAAAa,WAAA;IACA;IACA,IAAAA,WAAA;MACAY,gBAAA,CAAAZ,WAAA,EAAAW,gBAAA;IACA;EACA;EAEA,OAAAA,gBAAA;AACA;;AAEA;AACA,SAAAC,iBAAAZ,WAAA,EAAAW,gBAAA;EACAA,gBAAA,CAAAX,WAAA,CAAAX,IAAA,IAAAW,WAAA;EAEA,IAAAjB,qBAAA,CAAA8B,OAAA,CAAAb,WAAA,CAAAX,IAAA;IACAW,WAAA,CAAAc,SAAA,CAAAC,uBAAA,EAAAC,aAAA;IACAjC,qBAAA,CAAA0B,IAAA,CAAAT,WAAA,CAAAX,IAAA;IACA,QAAA4B,gBAAA,oBAAAA,gBAAA,KAAAC,MAAA,CAAAC,GAAA,2BAAAnB,WAAA,CAAAX,IAAA;EACA;AACA;;AAEA;AACA,SAAAiB,UAAAc,GAAA,EAAAC,QAAA;EACA,SAAAC,CAAA,MAAAA,CAAA,GAAAF,GAAA,CAAAG,MAAA,EAAAD,CAAA;IACA,IAAAD,QAAA,CAAAD,GAAA,CAAAE,CAAA;MACA,OAAAA,CAAA;IACA;EACA;EAEA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}