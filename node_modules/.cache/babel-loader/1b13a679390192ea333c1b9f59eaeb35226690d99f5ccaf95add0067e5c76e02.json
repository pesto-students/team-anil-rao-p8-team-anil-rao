{"ast":null,"code":"import _toConsumableArray from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n/**\n * Recursively traverses an object to update an existing nested key.\n * Note: The provided key path must include existing properties,\n * the function will not create objects while traversing.\n *\n * @param obj An object to update\n * @param value The value to update the nested key with\n * @param keyPath The path to the key to update ex. fizz.buzz.foo\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setNestedKey(obj, keyPath, value) {\n  // Ex. foo.bar.zoop will extract foo and bar.zoop\n  var match = keyPath.match(/([a-z_]+)\\.(.*)/i);\n  // The match will be null when there's no more recursing to do, i.e., when we've reached the right level of the object\n  if (match === null) {\n    obj[keyPath] = value;\n  } else {\n    // `match[1]` is the initial segment of the path, and `match[2]` is the remainder of the path\n    var innerObj = obj[match[1]];\n    setNestedKey(innerObj, match[2], value);\n  }\n}\n\n/**\n * Enforces inclusion of a given integration with specified options in an integration array originally determined by the\n * user, by either including the given default instance or by patching an existing user instance with the given options.\n *\n * Ideally this would happen when integrations are set up, but there isn't currently a mechanism there for merging\n * options from a default integration instance with those from a user-provided instance of the same integration, only\n * for allowing the user to override a default instance entirely. (TODO: Fix that.)\n *\n * @param defaultIntegrationInstance An instance of the integration with the correct options already set\n * @param userIntegrations Integrations defined by the user.\n * @param forcedOptions Options with which to patch an existing user-derived instance on the integration.\n * @returns A final integrations array.\n */\nfunction addOrUpdateIntegration(defaultIntegrationInstance, userIntegrations) {\n  var forcedOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return Array.isArray(userIntegrations) ? addOrUpdateIntegrationInArray(defaultIntegrationInstance, userIntegrations, forcedOptions) : addOrUpdateIntegrationInFunction(defaultIntegrationInstance,\n  // Somehow TS can't figure out that not being an array makes this necessarily a function\n  userIntegrations, forcedOptions);\n}\nfunction addOrUpdateIntegrationInArray(defaultIntegrationInstance, userIntegrations, forcedOptions) {\n  var userInstance = userIntegrations.find(function (integration) {\n    return integration.name === defaultIntegrationInstance.name;\n  });\n  if (userInstance) {\n    for (var _i = 0, _Object$entries = Object.entries(forcedOptions); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        keyPath = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n      setNestedKey(userInstance, keyPath, value);\n    }\n    return userIntegrations;\n  }\n  return [].concat(_toConsumableArray(userIntegrations), [defaultIntegrationInstance]);\n}\nfunction addOrUpdateIntegrationInFunction(defaultIntegrationInstance, userIntegrationsFunc, forcedOptions) {\n  var wrapper = function wrapper(defaultIntegrations) {\n    var userFinalIntegrations = userIntegrationsFunc(defaultIntegrations);\n\n    // There are instances where we want the user to be able to prevent an integration from appearing at all, which they\n    // would do by providing a function which filters out the integration in question. If that's happened in one of\n    // those cases, don't add our default back in.\n    if (defaultIntegrationInstance.allowExclusionByUser) {\n      var userFinalInstance = userFinalIntegrations.find(function (integration) {\n        return integration.name === defaultIntegrationInstance.name;\n      });\n      if (!userFinalInstance) {\n        return userFinalIntegrations;\n      }\n    }\n    return addOrUpdateIntegrationInArray(defaultIntegrationInstance, userFinalIntegrations, forcedOptions);\n  };\n  return wrapper;\n}\nexport { addOrUpdateIntegration };","map":{"version":3,"names":["setNestedKey","obj","keyPath","value","match","innerObj","addOrUpdateIntegration","defaultIntegrationInstance","userIntegrations","forcedOptions","arguments","length","undefined","Array","isArray","addOrUpdateIntegrationInArray","addOrUpdateIntegrationInFunction","userInstance","find","integration","name","_i","_Object$entries","Object","entries","_Object$entries$_i","_slicedToArray","concat","_toConsumableArray","userIntegrationsFunc","wrapper","defaultIntegrations","userFinalIntegrations","allowExclusionByUser","userFinalInstance"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/userIntegrations.ts"],"sourcesContent":["import type { Integration } from '@sentry/types';\n\nexport type UserIntegrationsFunction = (integrations: Integration[]) => Integration[];\nexport type UserIntegrations = Integration[] | UserIntegrationsFunction;\nexport type IntegrationWithExclusionOption = Integration & {\n  /**\n   * Allow the user to exclude this integration by not returning it from a function provided as the `integrations` option\n   * in `Sentry.init()`. Meant to be used with default integrations, the idea being that if a user has actively filtered\n   * an integration out, we should be able to respect that choice if we wish.\n   */\n  allowExclusionByUser?: boolean;\n};\n\ntype ForcedIntegrationOptions = {\n  [keyPath: string]: unknown;\n};\n\n/**\n * Recursively traverses an object to update an existing nested key.\n * Note: The provided key path must include existing properties,\n * the function will not create objects while traversing.\n *\n * @param obj An object to update\n * @param value The value to update the nested key with\n * @param keyPath The path to the key to update ex. fizz.buzz.foo\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setNestedKey(obj: Record<string, any>, keyPath: string, value: unknown): void {\n  // Ex. foo.bar.zoop will extract foo and bar.zoop\n  const match = keyPath.match(/([a-z_]+)\\.(.*)/i);\n  // The match will be null when there's no more recursing to do, i.e., when we've reached the right level of the object\n  if (match === null) {\n    obj[keyPath] = value;\n  } else {\n    // `match[1]` is the initial segment of the path, and `match[2]` is the remainder of the path\n    const innerObj = obj[match[1]];\n    setNestedKey(innerObj, match[2], value);\n  }\n}\n\n/**\n * Enforces inclusion of a given integration with specified options in an integration array originally determined by the\n * user, by either including the given default instance or by patching an existing user instance with the given options.\n *\n * Ideally this would happen when integrations are set up, but there isn't currently a mechanism there for merging\n * options from a default integration instance with those from a user-provided instance of the same integration, only\n * for allowing the user to override a default instance entirely. (TODO: Fix that.)\n *\n * @param defaultIntegrationInstance An instance of the integration with the correct options already set\n * @param userIntegrations Integrations defined by the user.\n * @param forcedOptions Options with which to patch an existing user-derived instance on the integration.\n * @returns A final integrations array.\n */\nexport function addOrUpdateIntegration<T extends UserIntegrations>(\n  defaultIntegrationInstance: Integration,\n  userIntegrations: T,\n  forcedOptions: ForcedIntegrationOptions = {},\n): T {\n  return (\n    Array.isArray(userIntegrations)\n      ? addOrUpdateIntegrationInArray(defaultIntegrationInstance, userIntegrations, forcedOptions)\n      : addOrUpdateIntegrationInFunction(\n          defaultIntegrationInstance,\n          // Somehow TS can't figure out that not being an array makes this necessarily a function\n          userIntegrations as UserIntegrationsFunction,\n          forcedOptions,\n        )\n  ) as T;\n}\n\nfunction addOrUpdateIntegrationInArray(\n  defaultIntegrationInstance: Integration,\n  userIntegrations: Integration[],\n  forcedOptions: ForcedIntegrationOptions,\n): Integration[] {\n  const userInstance = userIntegrations.find(integration => integration.name === defaultIntegrationInstance.name);\n\n  if (userInstance) {\n    for (const [keyPath, value] of Object.entries(forcedOptions)) {\n      setNestedKey(userInstance, keyPath, value);\n    }\n\n    return userIntegrations;\n  }\n\n  return [...userIntegrations, defaultIntegrationInstance];\n}\n\nfunction addOrUpdateIntegrationInFunction(\n  defaultIntegrationInstance: IntegrationWithExclusionOption,\n  userIntegrationsFunc: UserIntegrationsFunction,\n  forcedOptions: ForcedIntegrationOptions,\n): UserIntegrationsFunction {\n  const wrapper: UserIntegrationsFunction = defaultIntegrations => {\n    const userFinalIntegrations = userIntegrationsFunc(defaultIntegrations);\n\n    // There are instances where we want the user to be able to prevent an integration from appearing at all, which they\n    // would do by providing a function which filters out the integration in question. If that's happened in one of\n    // those cases, don't add our default back in.\n    if (defaultIntegrationInstance.allowExclusionByUser) {\n      const userFinalInstance = userFinalIntegrations.find(\n        integration => integration.name === defaultIntegrationInstance.name,\n      );\n      if (!userFinalInstance) {\n        return userFinalIntegrations;\n      }\n    }\n\n    return addOrUpdateIntegrationInArray(defaultIntegrationInstance, userFinalIntegrations, forcedOptions);\n  };\n\n  return wrapper;\n}\n"],"mappings":";;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAAA,aAAAC,GAAA,EAAAC,OAAA,EAAAC,KAAA;EACA;EACA,IAAAC,KAAA,GAAAF,OAAA,CAAAE,KAAA;EACA;EACA,IAAAA,KAAA;IACAH,GAAA,CAAAC,OAAA,IAAAC,KAAA;EACA;IACA;IACA,IAAAE,QAAA,GAAAJ,GAAA,CAAAG,KAAA;IACAJ,YAAA,CAAAK,QAAA,EAAAD,KAAA,KAAAD,KAAA;EACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAAG,uBACAC,0BAAA,EACAC,gBAAA,EAEA;EAAA,IADAC,aAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA;EAEA,OACAG,KAAA,CAAAC,OAAA,CAAAN,gBAAA,IACAO,6BAAA,CAAAR,0BAAA,EAAAC,gBAAA,EAAAC,aAAA,IACAO,gCAAA,CACAT,0BAAA;EACA;EACAC,gBAAA,EACAC,aACA;AAEA;AAEA,SAAAM,8BACAR,0BAAA,EACAC,gBAAA,EACAC,aAAA,EACA;EACA,IAAAQ,YAAA,GAAAT,gBAAA,CAAAU,IAAA,WAAAC,WAAA;IAAA,OAAAA,WAAA,CAAAC,IAAA,KAAAb,0BAAA,CAAAa,IAAA;EAAA;EAEA,IAAAH,YAAA;IACA,SAAAI,EAAA,MAAAC,eAAA,GAAAC,MAAA,CAAAC,OAAA,CAAAf,aAAA,GAAAY,EAAA,GAAAC,eAAA,CAAAX,MAAA,EAAAU,EAAA;MAAA,IAAAI,kBAAA,GAAAC,cAAA,CAAAJ,eAAA,CAAAD,EAAA;QAAAnB,OAAA,GAAAuB,kBAAA;QAAAtB,KAAA,GAAAsB,kBAAA;MACAzB,YAAA,CAAAiB,YAAA,EAAAf,OAAA,EAAAC,KAAA;IACA;IAEA,OAAAK,gBAAA;EACA;EAEA,UAAAmB,MAAA,CAAAC,kBAAA,CAAApB,gBAAA,IAAAD,0BAAA;AACA;AAEA,SAAAS,iCACAT,0BAAA,EACAsB,oBAAA,EACApB,aAAA,EACA;EACA,IAAAqB,OAAA,YAAAA,QAAAC,mBAAA;IACA,IAAAC,qBAAA,GAAAH,oBAAA,CAAAE,mBAAA;;IAEA;IACA;IACA;IACA,IAAAxB,0BAAA,CAAA0B,oBAAA;MACA,IAAAC,iBAAA,GAAAF,qBAAA,CAAAd,IAAA,CACA,UAAAC,WAAA;QAAA,OAAAA,WAAA,CAAAC,IAAA,KAAAb,0BAAA,CAAAa,IAAA;MAAA,CACA;MACA,KAAAc,iBAAA;QACA,OAAAF,qBAAA;MACA;IACA;IAEA,OAAAjB,6BAAA,CAAAR,0BAAA,EAAAyB,qBAAA,EAAAvB,aAAA;EACA;EAEA,OAAAqB,OAAA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}