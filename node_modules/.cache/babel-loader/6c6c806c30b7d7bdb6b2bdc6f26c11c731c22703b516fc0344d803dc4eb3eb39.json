{"ast":null,"code":"import _slicedToArray from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { makeDsn, logger, checkOrSetAlreadyCaught, isPrimitive, resolvedSyncPromise, addItemToEnvelope, createAttachmentEnvelopeItem, SyncPromise, rejectedSyncPromise, SentryError, isThenable, isPlainObject } from '@sentry/utils';\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from './api.js';\nimport { createEventEnvelope, createSessionEnvelope } from './envelope.js';\nimport { setupIntegrations as _setupIntegrations, setupIntegration } from './integration.js';\nimport { updateSession } from './session.js';\nimport { prepareEvent } from './utils/prepareEvent.js';\nvar ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event, it is passed through\n * {@link BaseClient._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(options);\n *   }\n *\n *   // ...\n * }\n */\nvar BaseClient = /*#__PURE__*/function () {\n  /**\n   * Initializes this client instance.\n   *\n   * @param options Options for the client.\n   */\n  function BaseClient(options) {\n    _classCallCheck(this, BaseClient);\n    BaseClient.prototype.__init.call(this);\n    BaseClient.prototype.__init2.call(this);\n    BaseClient.prototype.__init3.call(this);\n    BaseClient.prototype.__init4.call(this);\n    BaseClient.prototype.__init5.call(this);\n    this._options = options;\n    if (options.dsn) {\n      this._dsn = makeDsn(options.dsn);\n    } else {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('No DSN provided, client will not do anything.');\n    }\n    if (this._dsn) {\n      var url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);\n      this._transport = options.transport(_objectSpread(_objectSpread({\n        recordDroppedEvent: this.recordDroppedEvent.bind(this)\n      }, options.transportOptions), {}, {\n        url: url\n      }));\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  _createClass(BaseClient, [{\n    key: \"__init\",\n    value: /** Options passed to the SDK. */\n\n    /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n\n    /** Array of set up integrations. */\n    function __init() {\n      this._integrations = {};\n    }\n\n    /** Indicates whether this client's integrations have been set up. */\n  }, {\n    key: \"__init2\",\n    value: function __init2() {\n      this._integrationsInitialized = false;\n    }\n\n    /** Number of calls being processed */\n  }, {\n    key: \"__init3\",\n    value: function __init3() {\n      this._numProcessing = 0;\n    }\n\n    /** Holds flushable  */\n  }, {\n    key: \"__init4\",\n    value: function __init4() {\n      this._outcomes = {};\n    }\n\n    // eslint-disable-next-line @typescript-eslint/ban-types\n  }, {\n    key: \"__init5\",\n    value: function __init5() {\n      this._hooks = {};\n    }\n  }, {\n    key: \"captureException\",\n    value: function captureException(exception, hint, scope) {\n      var _this = this;\n      // ensure we haven't captured this very object before\n      if (checkOrSetAlreadyCaught(exception)) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(ALREADY_SEEN_ERROR);\n        return;\n      }\n      var eventId = hint && hint.event_id;\n      this._process(this.eventFromException(exception, hint).then(function (event) {\n        return _this._captureEvent(event, hint, scope);\n      }).then(function (result) {\n        eventId = result;\n      }));\n      return eventId;\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"captureMessage\",\n    value: function captureMessage(message,\n    // eslint-disable-next-line deprecation/deprecation\n    level, hint, scope) {\n      var _this2 = this;\n      var eventId = hint && hint.event_id;\n      var promisedEvent = isPrimitive(message) ? this.eventFromMessage(String(message), level, hint) : this.eventFromException(message, hint);\n      this._process(promisedEvent.then(function (event) {\n        return _this2._captureEvent(event, hint, scope);\n      }).then(function (result) {\n        eventId = result;\n      }));\n      return eventId;\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"captureEvent\",\n    value: function captureEvent(event, hint, scope) {\n      // ensure we haven't captured this very object before\n      if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(ALREADY_SEEN_ERROR);\n        return;\n      }\n      var eventId = hint && hint.event_id;\n      this._process(this._captureEvent(event, hint, scope).then(function (result) {\n        eventId = result;\n      }));\n      return eventId;\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"captureSession\",\n    value: function captureSession(session) {\n      if (!this._isEnabled()) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('SDK not enabled, will not capture session.');\n        return;\n      }\n      if (!(typeof session.release === 'string')) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Discarded session because of missing or non-string release');\n      } else {\n        this.sendSession(session);\n        // After sending, we set init false to indicate it's not the first occurrence\n        updateSession(session, {\n          init: false\n        });\n      }\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"getDsn\",\n    value: function getDsn() {\n      return this._dsn;\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      return this._options;\n    }\n\n    /**\n     * @see SdkMetadata in @sentry/types\n     *\n     * @return The metadata of the SDK\n     */\n  }, {\n    key: \"getSdkMetadata\",\n    value: function getSdkMetadata() {\n      return this._options._metadata;\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"getTransport\",\n    value: function getTransport() {\n      return this._transport;\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"flush\",\n    value: function flush(timeout) {\n      var transport = this._transport;\n      if (transport) {\n        return this._isClientDoneProcessing(timeout).then(function (clientFinished) {\n          return transport.flush(timeout).then(function (transportFlushed) {\n            return clientFinished && transportFlushed;\n          });\n        });\n      } else {\n        return resolvedSyncPromise(true);\n      }\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"close\",\n    value: function close(timeout) {\n      var _this3 = this;\n      return this.flush(timeout).then(function (result) {\n        _this3.getOptions().enabled = false;\n        return result;\n      });\n    }\n\n    /**\n     * Sets up the integrations\n     */\n  }, {\n    key: \"setupIntegrations\",\n    value: function setupIntegrations() {\n      if (this._isEnabled() && !this._integrationsInitialized) {\n        this._integrations = _setupIntegrations(this._options.integrations);\n        this._integrationsInitialized = true;\n      }\n    }\n\n    /**\n     * Gets an installed integration by its `id`.\n     *\n     * @returns The installed integration or `undefined` if no integration with that `id` was installed.\n     */\n  }, {\n    key: \"getIntegrationById\",\n    value: function getIntegrationById(integrationId) {\n      return this._integrations[integrationId];\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"getIntegration\",\n    value: function getIntegration(integration) {\n      try {\n        return this._integrations[integration.id] || null;\n      } catch (_oO) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(\"Cannot retrieve integration \".concat(integration.id, \" from the current Client\"));\n        return null;\n      }\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"addIntegration\",\n    value: function addIntegration(integration) {\n      setupIntegration(integration, this._integrations);\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"sendEvent\",\n    value: function sendEvent(event) {\n      var _this4 = this;\n      var hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (this._dsn) {\n        var env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);\n        var _iterator = _createForOfIteratorHelper(hint.attachments || []),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var attachment = _step.value;\n            env = addItemToEnvelope(env, createAttachmentEnvelopeItem(attachment, this._options.transportOptions && this._options.transportOptions.textEncoder));\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        var promise = this._sendEnvelope(env);\n        if (promise) {\n          promise.then(function (sendResponse) {\n            return _this4.emit('afterSendEvent', event, sendResponse);\n          }, null);\n        }\n      }\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"sendSession\",\n    value: function sendSession(session) {\n      if (this._dsn) {\n        var env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);\n        void this._sendEnvelope(env);\n      }\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"recordDroppedEvent\",\n    value: function recordDroppedEvent(reason, category, _event) {\n      // Note: we use `event` in replay, where we overwrite this hook.\n\n      if (this._options.sendClientReports) {\n        // We want to track each category (error, transaction, session, replay_event) separately\n        // but still keep the distinction between different type of outcomes.\n        // We could use nested maps, but it's much easier to read and type this way.\n        // A correct type for map-based implementation if we want to go that route\n        // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n        // With typescript 4.1 we could even use template literal types\n        var key = \"\".concat(reason, \":\").concat(category);\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(\"Adding outcome: \\\"\".concat(key, \"\\\"\"));\n\n        // The following works because undefined + 1 === NaN and NaN is falsy\n        this._outcomes[key] = this._outcomes[key] + 1 || 1;\n      }\n    }\n\n    // Keep on() & emit() signatures in sync with types' client.ts interface\n\n    /** @inheritdoc */\n\n    /** @inheritdoc */\n  }, {\n    key: \"on\",\n    value: function on(hook, callback) {\n      if (!this._hooks[hook]) {\n        this._hooks[hook] = [];\n      }\n\n      // @ts-ignore We assue the types are correct\n      this._hooks[hook].push(callback);\n    }\n\n    /** @inheritdoc */\n\n    /** @inheritdoc */\n  }, {\n    key: \"emit\",\n    value: function emit(hook) {\n      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        rest[_key - 1] = arguments[_key];\n      }\n      if (this._hooks[hook]) {\n        // @ts-ignore we cannot enforce the callback to match the hook\n        this._hooks[hook].forEach(function (callback) {\n          return callback.apply(void 0, rest);\n        });\n      }\n    }\n\n    /** Updates existing session based on the provided event */\n  }, {\n    key: \"_updateSessionFromEvent\",\n    value: function _updateSessionFromEvent(session, event) {\n      var crashed = false;\n      var errored = false;\n      var exceptions = event.exception && event.exception.values;\n      if (exceptions) {\n        errored = true;\n        var _iterator2 = _createForOfIteratorHelper(exceptions),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var ex = _step2.value;\n            var mechanism = ex.mechanism;\n            if (mechanism && mechanism.handled === false) {\n              crashed = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      // A session is updated and that session update is sent in only one of the two following scenarios:\n      // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n      // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n      var sessionNonTerminal = session.status === 'ok';\n      var shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;\n      if (shouldUpdateAndSend) {\n        updateSession(session, _objectSpread(_objectSpread({}, crashed && {\n          status: 'crashed'\n        }), {}, {\n          errors: session.errors || Number(errored || crashed)\n        }));\n        this.captureSession(session);\n      }\n    }\n\n    /**\n     * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n     * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n     *\n     * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n     * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n     * `true`.\n     * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n     * `false` otherwise\n     */\n  }, {\n    key: \"_isClientDoneProcessing\",\n    value: function _isClientDoneProcessing(timeout) {\n      var _this5 = this;\n      return new SyncPromise(function (resolve) {\n        var ticked = 0;\n        var tick = 1;\n        var interval = setInterval(function () {\n          if (_this5._numProcessing == 0) {\n            clearInterval(interval);\n            resolve(true);\n          } else {\n            ticked += tick;\n            if (timeout && ticked >= timeout) {\n              clearInterval(interval);\n              resolve(false);\n            }\n          }\n        }, tick);\n      });\n    }\n\n    /** Determines whether this SDK is enabled and a valid Dsn is present. */\n  }, {\n    key: \"_isEnabled\",\n    value: function _isEnabled() {\n      return this.getOptions().enabled !== false && this._dsn !== undefined;\n    }\n\n    /**\n     * Adds common information to events.\n     *\n     * The information includes release and environment from `options`,\n     * breadcrumbs and context (extra, tags and user) from the scope.\n     *\n     * Information that is already present in the event is never overwritten. For\n     * nested objects, such as the context, keys are merged.\n     *\n     * @param event The original event.\n     * @param hint May contain additional information about the original exception.\n     * @param scope A scope containing event metadata.\n     * @returns A new event with more information.\n     */\n  }, {\n    key: \"_prepareEvent\",\n    value: function _prepareEvent(event, hint, scope) {\n      var options = this.getOptions();\n      var integrations = Object.keys(this._integrations);\n      if (!hint.integrations && integrations.length > 0) {\n        hint.integrations = integrations;\n      }\n      return prepareEvent(options, event, hint, scope);\n    }\n\n    /**\n     * Processes the event and logs an error in case of rejection\n     * @param event\n     * @param hint\n     * @param scope\n     */\n  }, {\n    key: \"_captureEvent\",\n    value: function _captureEvent(event) {\n      var hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var scope = arguments.length > 2 ? arguments[2] : undefined;\n      return this._processEvent(event, hint, scope).then(function (finalEvent) {\n        return finalEvent.event_id;\n      }, function (reason) {\n        if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n          // If something's gone wrong, log the error as a warning. If it's just us having used a `SentryError` for\n          // control flow, log just the message (no stack) as a log-level log.\n          var sentryError = reason;\n          if (sentryError.logLevel === 'log') {\n            logger.log(sentryError.message);\n          } else {\n            logger.warn(sentryError);\n          }\n        }\n        return undefined;\n      });\n    }\n\n    /**\n     * Processes an event (either error or message) and sends it to Sentry.\n     *\n     * This also adds breadcrumbs and context information to the event. However,\n     * platform specific meta data (such as the User's IP address) must be added\n     * by the SDK implementor.\n     *\n     *\n     * @param event The event to send to Sentry.\n     * @param hint May contain additional information about the original exception.\n     * @param scope A scope containing event metadata.\n     * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n     */\n  }, {\n    key: \"_processEvent\",\n    value: function _processEvent(event, hint, scope) {\n      var _this6 = this;\n      var options = this.getOptions();\n      var sampleRate = options.sampleRate;\n      if (!this._isEnabled()) {\n        return rejectedSyncPromise(new SentryError('SDK not enabled, will not capture event.', 'log'));\n      }\n      var isTransaction = isTransactionEvent(event);\n      var isError = isErrorEvent(event);\n      var eventType = event.type || 'error';\n      var beforeSendLabel = \"before send for type `\".concat(eventType, \"`\");\n\n      // 1.0 === 100% events are sent\n      // 0.0 === 0% events are sent\n      // Sampling for transaction happens somewhere else\n      if (isError && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n        this.recordDroppedEvent('sample_rate', 'error', event);\n        return rejectedSyncPromise(new SentryError(\"Discarding event because it's not included in the random sample (sampling rate = \".concat(sampleRate, \")\"), 'log'));\n      }\n      var dataCategory = eventType === 'replay_event' ? 'replay' : eventType;\n      return this._prepareEvent(event, hint, scope).then(function (prepared) {\n        if (prepared === null) {\n          _this6.recordDroppedEvent('event_processor', dataCategory, event);\n          throw new SentryError('An event processor returned `null`, will not send event.', 'log');\n        }\n        var isInternalException = hint.data && hint.data.__sentry__ === true;\n        if (isInternalException) {\n          return prepared;\n        }\n        var result = processBeforeSend(options, prepared, hint);\n        return _validateBeforeSendResult(result, beforeSendLabel);\n      }).then(function (processedEvent) {\n        if (processedEvent === null) {\n          _this6.recordDroppedEvent('before_send', dataCategory, event);\n          throw new SentryError(\"\".concat(beforeSendLabel, \" returned `null`, will not send event.\"), 'log');\n        }\n        var session = scope && scope.getSession();\n        if (!isTransaction && session) {\n          _this6._updateSessionFromEvent(session, processedEvent);\n        }\n\n        // None of the Sentry built event processor will update transaction name,\n        // so if the transaction name has been changed by an event processor, we know\n        // it has to come from custom event processor added by a user\n        var transactionInfo = processedEvent.transaction_info;\n        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {\n          var source = 'custom';\n          processedEvent.transaction_info = _objectSpread(_objectSpread({}, transactionInfo), {}, {\n            source: source\n          });\n        }\n        _this6.sendEvent(processedEvent, hint);\n        return processedEvent;\n      }).then(null, function (reason) {\n        if (reason instanceof SentryError) {\n          throw reason;\n        }\n        _this6.captureException(reason, {\n          data: {\n            __sentry__: true\n          },\n          originalException: reason\n        });\n        throw new SentryError(\"Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: \".concat(reason));\n      });\n    }\n\n    /**\n     * Occupies the client with processing and event\n     */\n  }, {\n    key: \"_process\",\n    value: function _process(promise) {\n      var _this7 = this;\n      this._numProcessing++;\n      void promise.then(function (value) {\n        _this7._numProcessing--;\n        return value;\n      }, function (reason) {\n        _this7._numProcessing--;\n        return reason;\n      });\n    }\n\n    /**\n     * @inheritdoc\n     */\n  }, {\n    key: \"_sendEnvelope\",\n    value: function _sendEnvelope(envelope) {\n      if (this._transport && this._dsn) {\n        this.emit('beforeEnvelope', envelope);\n        return this._transport.send(envelope).then(null, function (reason) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Error while sending event:', reason);\n        });\n      } else {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Transport disabled');\n      }\n    }\n\n    /**\n     * Clears outcomes on this client and returns them.\n     */\n  }, {\n    key: \"_clearOutcomes\",\n    value: function _clearOutcomes() {\n      var outcomes = this._outcomes;\n      this._outcomes = {};\n      return Object.keys(outcomes).map(function (key) {\n        var _key$split = key.split(':'),\n          _key$split2 = _slicedToArray(_key$split, 2),\n          reason = _key$split2[0],\n          category = _key$split2[1];\n        return {\n          reason: reason,\n          category: category,\n          quantity: outcomes[key]\n        };\n      });\n    }\n\n    /**\n     * @inheritDoc\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  }]);\n  return BaseClient;\n}();\n/**\n * Verifies that return value of configured `beforeSend` or `beforeSendTransaction` is of expected type, and returns the value if so.\n */\nfunction _validateBeforeSendResult(beforeSendResult, beforeSendLabel) {\n  var invalidValueError = \"\".concat(beforeSendLabel, \" must return `null` or a valid event.\");\n  if (isThenable(beforeSendResult)) {\n    return beforeSendResult.then(function (event) {\n      if (!isPlainObject(event) && event !== null) {\n        throw new SentryError(invalidValueError);\n      }\n      return event;\n    }, function (e) {\n      throw new SentryError(\"\".concat(beforeSendLabel, \" rejected with \").concat(e));\n    });\n  } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {\n    throw new SentryError(invalidValueError);\n  }\n  return beforeSendResult;\n}\n\n/**\n * Process the matching `beforeSendXXX` callback.\n */\nfunction processBeforeSend(options, event, hint) {\n  var beforeSend = options.beforeSend,\n    beforeSendTransaction = options.beforeSendTransaction;\n  if (isErrorEvent(event) && beforeSend) {\n    return beforeSend(event, hint);\n  }\n  if (isTransactionEvent(event) && beforeSendTransaction) {\n    return beforeSendTransaction(event, hint);\n  }\n  return event;\n}\nfunction isErrorEvent(event) {\n  return event.type === undefined;\n}\nfunction isTransactionEvent(event) {\n  return event.type === 'transaction';\n}\nexport { BaseClient };","map":{"version":3,"names":["ALREADY_SEEN_ERROR","BaseClient","options","_classCallCheck","prototype","__init","call","__init2","__init3","__init4","__init5","_options","dsn","_dsn","makeDsn","__SENTRY_DEBUG__","logger","warn","url","getEnvelopeEndpointWithUrlEncodedAuth","_transport","transport","_objectSpread","recordDroppedEvent","bind","transportOptions","_createClass","key","value","_integrations","_integrationsInitialized","_numProcessing","_outcomes","_hooks","captureException","exception","hint","scope","_this","checkOrSetAlreadyCaught","log","eventId","event_id","_process","eventFromException","then","event","_captureEvent","result","captureMessage","message","level","_this2","promisedEvent","isPrimitive","eventFromMessage","String","captureEvent","originalException","captureSession","session","_isEnabled","release","sendSession","updateSession","init","getDsn","getOptions","getSdkMetadata","_metadata","getTransport","flush","timeout","_isClientDoneProcessing","clientFinished","transportFlushed","resolvedSyncPromise","close","_this3","enabled","setupIntegrations","integrations","getIntegrationById","integrationId","getIntegration","integration","id","_oO","concat","addIntegration","setupIntegration","sendEvent","_this4","arguments","length","undefined","env","createEventEnvelope","tunnel","_iterator","_createForOfIteratorHelper","attachments","_step","s","n","done","attachment","addItemToEnvelope","createAttachmentEnvelopeItem","textEncoder","err","e","f","promise","_sendEnvelope","sendResponse","emit","createSessionEnvelope","reason","category","_event","sendClientReports","on","hook","callback","push","_len","rest","Array","_key","forEach","apply","_updateSessionFromEvent","crashed","errored","exceptions","values","_iterator2","_step2","ex","mechanism","handled","sessionNonTerminal","status","shouldUpdateAndSend","errors","Number","_this5","SyncPromise","resolve","ticked","tick","interval","setInterval","clearInterval","_prepareEvent","Object","keys","prepareEvent","_processEvent","finalEvent","sentryError","logLevel","_this6","sampleRate","rejectedSyncPromise","SentryError","isTransaction","isTransactionEvent","isError","isErrorEvent","eventType","type","beforeSendLabel","Math","random","dataCategory","prepared","isInternalException","data","__sentry__","processBeforeSend","_validateBeforeSendResult","processedEvent","getSession","transactionInfo","transaction_info","transaction","source","_this7","envelope","send","error","_clearOutcomes","outcomes","map","_key$split","split","_key$split2","_slicedToArray","quantity","beforeSendResult","invalidValueError","isThenable","isPlainObject","beforeSend","beforeSendTransaction"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/baseclient.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type {\n  Breadcrumb,\n  BreadcrumbHint,\n  Client,\n  ClientOptions,\n  DataCategory,\n  DsnComponents,\n  DynamicSamplingContext,\n  Envelope,\n  ErrorEvent,\n  Event,\n  EventDropReason,\n  EventHint,\n  Integration,\n  IntegrationClass,\n  Outcome,\n  SdkMetadata,\n  Session,\n  SessionAggregates,\n  Severity,\n  SeverityLevel,\n  Transaction,\n  TransactionEvent,\n  Transport,\n  TransportMakeRequestResponse,\n} from '@sentry/types';\nimport {\n  addItemToEnvelope,\n  checkOrSetAlreadyCaught,\n  createAttachmentEnvelopeItem,\n  isPlainObject,\n  isPrimitive,\n  isThenable,\n  logger,\n  makeDsn,\n  rejectedSyncPromise,\n  resolvedSyncPromise,\n  SentryError,\n  SyncPromise,\n} from '@sentry/utils';\n\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from './api';\nimport { createEventEnvelope, createSessionEnvelope } from './envelope';\nimport type { IntegrationIndex } from './integration';\nimport { setupIntegration, setupIntegrations } from './integration';\nimport type { Scope } from './scope';\nimport { updateSession } from './session';\nimport { prepareEvent } from './utils/prepareEvent';\n\nconst ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event, it is passed through\n * {@link BaseClient._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(options);\n *   }\n *\n *   // ...\n * }\n */\nexport abstract class BaseClient<O extends ClientOptions> implements Client<O> {\n  /** Options passed to the SDK. */\n  protected readonly _options: O;\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n  protected readonly _dsn?: DsnComponents;\n\n  protected readonly _transport?: Transport;\n\n  /** Array of set up integrations. */\n  protected _integrations: IntegrationIndex = {};\n\n  /** Indicates whether this client's integrations have been set up. */\n  protected _integrationsInitialized: boolean = false;\n\n  /** Number of calls being processed */\n  protected _numProcessing: number = 0;\n\n  /** Holds flushable  */\n  private _outcomes: { [key: string]: number } = {};\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  private _hooks: Record<string, Function[]> = {};\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param options Options for the client.\n   */\n  protected constructor(options: O) {\n    this._options = options;\n\n    if (options.dsn) {\n      this._dsn = makeDsn(options.dsn);\n    } else {\n      __DEBUG_BUILD__ && logger.warn('No DSN provided, client will not do anything.');\n    }\n\n    if (this._dsn) {\n      const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);\n      this._transport = options.transport({\n        recordDroppedEvent: this.recordDroppedEvent.bind(this),\n        ...options.transportOptions,\n        url,\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined {\n    // ensure we haven't captured this very object before\n    if (checkOrSetAlreadyCaught(exception)) {\n      __DEBUG_BUILD__ && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId: string | undefined = hint && hint.event_id;\n\n    this._process(\n      this.eventFromException(exception, hint)\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureMessage(\n    message: string,\n    // eslint-disable-next-line deprecation/deprecation\n    level?: Severity | SeverityLevel,\n    hint?: EventHint,\n    scope?: Scope,\n  ): string | undefined {\n    let eventId: string | undefined = hint && hint.event_id;\n\n    const promisedEvent = isPrimitive(message)\n      ? this.eventFromMessage(String(message), level, hint)\n      : this.eventFromException(message, hint);\n\n    this._process(\n      promisedEvent\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined {\n    // ensure we haven't captured this very object before\n    if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n      __DEBUG_BUILD__ && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId: string | undefined = hint && hint.event_id;\n\n    this._process(\n      this._captureEvent(event, hint, scope).then(result => {\n        eventId = result;\n      }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureSession(session: Session): void {\n    if (!this._isEnabled()) {\n      __DEBUG_BUILD__ && logger.warn('SDK not enabled, will not capture session.');\n      return;\n    }\n\n    if (!(typeof session.release === 'string')) {\n      __DEBUG_BUILD__ && logger.warn('Discarded session because of missing or non-string release');\n    } else {\n      this.sendSession(session);\n      // After sending, we set init false to indicate it's not the first occurrence\n      updateSession(session, { init: false });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getDsn(): DsnComponents | undefined {\n    return this._dsn;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getOptions(): O {\n    return this._options;\n  }\n\n  /**\n   * @see SdkMetadata in @sentry/types\n   *\n   * @return The metadata of the SDK\n   */\n  public getSdkMetadata(): SdkMetadata | undefined {\n    return this._options._metadata;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getTransport(): Transport | undefined {\n    return this._transport;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public flush(timeout?: number): PromiseLike<boolean> {\n    const transport = this._transport;\n    if (transport) {\n      return this._isClientDoneProcessing(timeout).then(clientFinished => {\n        return transport.flush(timeout).then(transportFlushed => clientFinished && transportFlushed);\n      });\n    } else {\n      return resolvedSyncPromise(true);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      return result;\n    });\n  }\n\n  /**\n   * Sets up the integrations\n   */\n  public setupIntegrations(): void {\n    if (this._isEnabled() && !this._integrationsInitialized) {\n      this._integrations = setupIntegrations(this._options.integrations);\n      this._integrationsInitialized = true;\n    }\n  }\n\n  /**\n   * Gets an installed integration by its `id`.\n   *\n   * @returns The installed integration or `undefined` if no integration with that `id` was installed.\n   */\n  public getIntegrationById(integrationId: string): Integration | undefined {\n    return this._integrations[integrationId];\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null {\n    try {\n      return (this._integrations[integration.id] as T) || null;\n    } catch (_oO) {\n      __DEBUG_BUILD__ && logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public addIntegration(integration: Integration): void {\n    setupIntegration(integration, this._integrations);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(event: Event, hint: EventHint = {}): void {\n    if (this._dsn) {\n      let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);\n\n      for (const attachment of hint.attachments || []) {\n        env = addItemToEnvelope(\n          env,\n          createAttachmentEnvelopeItem(\n            attachment,\n            this._options.transportOptions && this._options.transportOptions.textEncoder,\n          ),\n        );\n      }\n\n      const promise = this._sendEnvelope(env);\n      if (promise) {\n        promise.then(sendResponse => this.emit('afterSendEvent', event, sendResponse), null);\n      }\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendSession(session: Session | SessionAggregates): void {\n    if (this._dsn) {\n      const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);\n      void this._sendEnvelope(env);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public recordDroppedEvent(reason: EventDropReason, category: DataCategory, _event?: Event): void {\n    // Note: we use `event` in replay, where we overwrite this hook.\n\n    if (this._options.sendClientReports) {\n      // We want to track each category (error, transaction, session, replay_event) separately\n      // but still keep the distinction between different type of outcomes.\n      // We could use nested maps, but it's much easier to read and type this way.\n      // A correct type for map-based implementation if we want to go that route\n      // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n      // With typescript 4.1 we could even use template literal types\n      const key = `${reason}:${category}`;\n      __DEBUG_BUILD__ && logger.log(`Adding outcome: \"${key}\"`);\n\n      // The following works because undefined + 1 === NaN and NaN is falsy\n      this._outcomes[key] = this._outcomes[key] + 1 || 1;\n    }\n  }\n\n  // Keep on() & emit() signatures in sync with types' client.ts interface\n\n  /** @inheritdoc */\n  public on(hook: 'startTransaction' | 'finishTransaction', callback: (transaction: Transaction) => void): void;\n\n  /** @inheritdoc */\n  public on(hook: 'beforeEnvelope', callback: (envelope: Envelope) => void): void;\n\n  /** @inheritdoc */\n  public on(\n    hook: 'afterSendEvent',\n    callback: (event: Event, sendResponse: TransportMakeRequestResponse | void) => void,\n  ): void;\n\n  /** @inheritdoc */\n  public on(hook: 'beforeAddBreadcrumb', callback: (breadcrumb: Breadcrumb, hint?: BreadcrumbHint) => void): void;\n\n  /** @inheritdoc */\n  public on(hook: 'createDsc', callback: (dsc: DynamicSamplingContext) => void): void;\n\n  /** @inheritdoc */\n  public on(hook: string, callback: unknown): void {\n    if (!this._hooks[hook]) {\n      this._hooks[hook] = [];\n    }\n\n    // @ts-ignore We assue the types are correct\n    this._hooks[hook].push(callback);\n  }\n\n  /** @inheritdoc */\n  public emit(hook: 'startTransaction' | 'finishTransaction', transaction: Transaction): void;\n\n  /** @inheritdoc */\n  public emit(hook: 'beforeEnvelope', envelope: Envelope): void;\n\n  /** @inheritdoc */\n  public emit(hook: 'afterSendEvent', event: Event, sendResponse: TransportMakeRequestResponse | void): void;\n\n  /** @inheritdoc */\n  public emit(hook: 'beforeAddBreadcrumb', breadcrumb: Breadcrumb, hint?: BreadcrumbHint): void;\n\n  /** @inheritdoc */\n  public emit(hook: 'createDsc', dsc: DynamicSamplingContext): void;\n\n  /** @inheritdoc */\n  public emit(hook: string, ...rest: unknown[]): void {\n    if (this._hooks[hook]) {\n      // @ts-ignore we cannot enforce the callback to match the hook\n      this._hooks[hook].forEach(callback => callback(...rest));\n    }\n  }\n\n  /** Updates existing session based on the provided event */\n  protected _updateSessionFromEvent(session: Session, event: Event): void {\n    let crashed = false;\n    let errored = false;\n    const exceptions = event.exception && event.exception.values;\n\n    if (exceptions) {\n      errored = true;\n\n      for (const ex of exceptions) {\n        const mechanism = ex.mechanism;\n        if (mechanism && mechanism.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    const sessionNonTerminal = session.status === 'ok';\n    const shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);\n\n    if (shouldUpdateAndSend) {\n      updateSession(session, {\n        ...(crashed && { status: 'crashed' }),\n        errors: session.errors || Number(errored || crashed),\n      });\n      this.captureSession(session);\n    }\n  }\n\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n  protected _isClientDoneProcessing(timeout?: number): PromiseLike<boolean> {\n    return new SyncPromise(resolve => {\n      let ticked: number = 0;\n      const tick: number = 1;\n\n      const interval = setInterval(() => {\n        if (this._numProcessing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  }\n\n  /** Determines whether this SDK is enabled and a valid Dsn is present. */\n  protected _isEnabled(): boolean {\n    return this.getOptions().enabled !== false && this._dsn !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n  protected _prepareEvent(event: Event, hint: EventHint, scope?: Scope): PromiseLike<Event | null> {\n    const options = this.getOptions();\n    const integrations = Object.keys(this._integrations);\n    if (!hint.integrations && integrations.length > 0) {\n      hint.integrations = integrations;\n    }\n    return prepareEvent(options, event, hint, scope);\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n  protected _captureEvent(event: Event, hint: EventHint = {}, scope?: Scope): PromiseLike<string | undefined> {\n    return this._processEvent(event, hint, scope).then(\n      finalEvent => {\n        return finalEvent.event_id;\n      },\n      reason => {\n        if (__DEBUG_BUILD__) {\n          // If something's gone wrong, log the error as a warning. If it's just us having used a `SentryError` for\n          // control flow, log just the message (no stack) as a log-level log.\n          const sentryError = reason as SentryError;\n          if (sentryError.logLevel === 'log') {\n            logger.log(sentryError.message);\n          } else {\n            logger.warn(sentryError);\n          }\n        }\n        return undefined;\n      },\n    );\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n  protected _processEvent(event: Event, hint: EventHint, scope?: Scope): PromiseLike<Event> {\n    const options = this.getOptions();\n    const { sampleRate } = options;\n\n    if (!this._isEnabled()) {\n      return rejectedSyncPromise(new SentryError('SDK not enabled, will not capture event.', 'log'));\n    }\n\n    const isTransaction = isTransactionEvent(event);\n    const isError = isErrorEvent(event);\n    const eventType = event.type || 'error';\n    const beforeSendLabel = `before send for type \\`${eventType}\\``;\n\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    if (isError && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      this.recordDroppedEvent('sample_rate', 'error', event);\n      return rejectedSyncPromise(\n        new SentryError(\n          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,\n          'log',\n        ),\n      );\n    }\n\n    const dataCategory: DataCategory = eventType === 'replay_event' ? 'replay' : eventType;\n\n    return this._prepareEvent(event, hint, scope)\n      .then(prepared => {\n        if (prepared === null) {\n          this.recordDroppedEvent('event_processor', dataCategory, event);\n          throw new SentryError('An event processor returned `null`, will not send event.', 'log');\n        }\n\n        const isInternalException = hint.data && (hint.data as { __sentry__: boolean }).__sentry__ === true;\n        if (isInternalException) {\n          return prepared;\n        }\n\n        const result = processBeforeSend(options, prepared, hint);\n        return _validateBeforeSendResult(result, beforeSendLabel);\n      })\n      .then(processedEvent => {\n        if (processedEvent === null) {\n          this.recordDroppedEvent('before_send', dataCategory, event);\n          throw new SentryError(`${beforeSendLabel} returned \\`null\\`, will not send event.`, 'log');\n        }\n\n        const session = scope && scope.getSession();\n        if (!isTransaction && session) {\n          this._updateSessionFromEvent(session, processedEvent);\n        }\n\n        // None of the Sentry built event processor will update transaction name,\n        // so if the transaction name has been changed by an event processor, we know\n        // it has to come from custom event processor added by a user\n        const transactionInfo = processedEvent.transaction_info;\n        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {\n          const source = 'custom';\n          processedEvent.transaction_info = {\n            ...transactionInfo,\n            source,\n          };\n        }\n\n        this.sendEvent(processedEvent, hint);\n        return processedEvent;\n      })\n      .then(null, reason => {\n        if (reason instanceof SentryError) {\n          throw reason;\n        }\n\n        this.captureException(reason, {\n          data: {\n            __sentry__: true,\n          },\n          originalException: reason,\n        });\n        throw new SentryError(\n          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`,\n        );\n      });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n  protected _process<T>(promise: PromiseLike<T>): void {\n    this._numProcessing++;\n    void promise.then(\n      value => {\n        this._numProcessing--;\n        return value;\n      },\n      reason => {\n        this._numProcessing--;\n        return reason;\n      },\n    );\n  }\n\n  /**\n   * @inheritdoc\n   */\n  protected _sendEnvelope(envelope: Envelope): PromiseLike<void | TransportMakeRequestResponse> | void {\n    if (this._transport && this._dsn) {\n      this.emit('beforeEnvelope', envelope);\n\n      return this._transport.send(envelope).then(null, reason => {\n        __DEBUG_BUILD__ && logger.error('Error while sending event:', reason);\n      });\n    } else {\n      __DEBUG_BUILD__ && logger.error('Transport disabled');\n    }\n  }\n\n  /**\n   * Clears outcomes on this client and returns them.\n   */\n  protected _clearOutcomes(): Outcome[] {\n    const outcomes = this._outcomes;\n    this._outcomes = {};\n    return Object.keys(outcomes).map(key => {\n      const [reason, category] = key.split(':') as [EventDropReason, DataCategory];\n      return {\n        reason,\n        category,\n        quantity: outcomes[key],\n      };\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public abstract eventFromException(_exception: any, _hint?: EventHint): PromiseLike<Event>;\n\n  /**\n   * @inheritDoc\n   */\n  public abstract eventFromMessage(\n    _message: string,\n    // eslint-disable-next-line deprecation/deprecation\n    _level?: Severity | SeverityLevel,\n    _hint?: EventHint,\n  ): PromiseLike<Event>;\n}\n\n/**\n * Verifies that return value of configured `beforeSend` or `beforeSendTransaction` is of expected type, and returns the value if so.\n */\nfunction _validateBeforeSendResult(\n  beforeSendResult: PromiseLike<Event | null> | Event | null,\n  beforeSendLabel: string,\n): PromiseLike<Event | null> | Event | null {\n  const invalidValueError = `${beforeSendLabel} must return \\`null\\` or a valid event.`;\n  if (isThenable(beforeSendResult)) {\n    return beforeSendResult.then(\n      event => {\n        if (!isPlainObject(event) && event !== null) {\n          throw new SentryError(invalidValueError);\n        }\n        return event;\n      },\n      e => {\n        throw new SentryError(`${beforeSendLabel} rejected with ${e}`);\n      },\n    );\n  } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {\n    throw new SentryError(invalidValueError);\n  }\n  return beforeSendResult;\n}\n\n/**\n * Process the matching `beforeSendXXX` callback.\n */\nfunction processBeforeSend(\n  options: ClientOptions,\n  event: Event,\n  hint: EventHint,\n): PromiseLike<Event | null> | Event | null {\n  const { beforeSend, beforeSendTransaction } = options;\n\n  if (isErrorEvent(event) && beforeSend) {\n    return beforeSend(event, hint);\n  }\n\n  if (isTransactionEvent(event) && beforeSendTransaction) {\n    return beforeSendTransaction(event, hint);\n  }\n\n  return event;\n}\n\nfunction isErrorEvent(event: Event): event is ErrorEvent {\n  return event.type === undefined;\n}\n\nfunction isTransactionEvent(event: Event): event is TransactionEvent {\n  return event.type === 'transaction';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}