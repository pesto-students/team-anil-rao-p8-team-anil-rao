{"ast":null,"code":"import _classCallCheck from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { dropUndefinedKeys } from '@sentry/utils';\nimport { getCurrentHub } from './hub.js';\n\n/**\n * @inheritdoc\n */\nvar SessionFlusher = /*#__PURE__*/function () {\n  function SessionFlusher(client, attrs) {\n    var _this = this;\n    _classCallCheck(this, SessionFlusher);\n    SessionFlusher.prototype.__init.call(this);\n    SessionFlusher.prototype.__init2.call(this);\n    SessionFlusher.prototype.__init3.call(this);\n    this._client = client;\n    // Call to setInterval, so that flush is called every 60 seconds\n    this._intervalId = setInterval(function () {\n      return _this.flush();\n    }, this.flushTimeout * 1000);\n    this._sessionAttrs = attrs;\n  }\n\n  /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSession` */\n  _createClass(SessionFlusher, [{\n    key: \"__init\",\n    value: function __init() {\n      this.flushTimeout = 60;\n    }\n  }, {\n    key: \"__init2\",\n    value: function __init2() {\n      this._pendingAggregates = {};\n    }\n  }, {\n    key: \"__init3\",\n    value: function __init3() {\n      this._isEnabled = true;\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      var sessionAggregates = this.getSessionAggregates();\n      if (sessionAggregates.aggregates.length === 0) {\n        return;\n      }\n      this._pendingAggregates = {};\n      this._client.sendSession(sessionAggregates);\n    }\n\n    /** Massages the entries in `pendingAggregates` and returns aggregated sessions */\n  }, {\n    key: \"getSessionAggregates\",\n    value: function getSessionAggregates() {\n      var _this2 = this;\n      var aggregates = Object.keys(this._pendingAggregates).map(function (key) {\n        return _this2._pendingAggregates[parseInt(key)];\n      });\n      var sessionAggregates = {\n        attrs: this._sessionAttrs,\n        aggregates: aggregates\n      };\n      return dropUndefinedKeys(sessionAggregates);\n    }\n\n    /** JSDoc */\n  }, {\n    key: \"close\",\n    value: function close() {\n      clearInterval(this._intervalId);\n      this._isEnabled = false;\n      this.flush();\n    }\n\n    /**\n     * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then\n     * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to\n     * `_incrementSessionStatusCount` along with the start date\n     */\n  }, {\n    key: \"incrementSessionStatusCount\",\n    value: function incrementSessionStatusCount() {\n      if (!this._isEnabled) {\n        return;\n      }\n      var scope = getCurrentHub().getScope();\n      var requestSession = scope.getRequestSession();\n      if (requestSession && requestSession.status) {\n        this._incrementSessionStatusCount(requestSession.status, new Date());\n        // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in\n        // case captureRequestSession is called more than once to prevent double count\n        scope.setRequestSession(undefined);\n        /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n      }\n    }\n\n    /**\n     * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of\n     * the session received\n     */\n  }, {\n    key: \"_incrementSessionStatusCount\",\n    value: function _incrementSessionStatusCount(status, date) {\n      // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys\n      var sessionStartedTrunc = new Date(date).setSeconds(0, 0);\n      this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};\n\n      // corresponds to aggregated sessions in one specific minute bucket\n      // for example, {\"started\":\"2021-03-16T08:00:00.000Z\",\"exited\":4, \"errored\": 1}\n      var aggregationCounts = this._pendingAggregates[sessionStartedTrunc];\n      if (!aggregationCounts.started) {\n        aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();\n      }\n      switch (status) {\n        case 'errored':\n          aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;\n          return aggregationCounts.errored;\n        case 'ok':\n          aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;\n          return aggregationCounts.exited;\n        default:\n          aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;\n          return aggregationCounts.crashed;\n      }\n    }\n  }]);\n  return SessionFlusher;\n}();\nexport { SessionFlusher };","map":{"version":3,"names":["SessionFlusher","client","attrs","_this","_classCallCheck","prototype","__init","call","__init2","__init3","_client","_intervalId","setInterval","flush","flushTimeout","_sessionAttrs","_createClass","key","value","_pendingAggregates","_isEnabled","sessionAggregates","getSessionAggregates","aggregates","length","sendSession","_this2","Object","keys","map","parseInt","dropUndefinedKeys","close","clearInterval","incrementSessionStatusCount","scope","getCurrentHub","getScope","requestSession","getRequestSession","status","_incrementSessionStatusCount","Date","setRequestSession","undefined","date","sessionStartedTrunc","setSeconds","aggregationCounts","started","toISOString","errored","exited","crashed"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/sessionflusher.ts"],"sourcesContent":["import type {\n  AggregationCounts,\n  Client,\n  RequestSessionStatus,\n  SessionAggregates,\n  SessionFlusherLike,\n} from '@sentry/types';\nimport { dropUndefinedKeys } from '@sentry/utils';\n\nimport { getCurrentHub } from './hub';\n\ntype ReleaseHealthAttributes = {\n  environment?: string;\n  release: string;\n};\n\n/**\n * @inheritdoc\n */\nexport class SessionFlusher implements SessionFlusherLike {\n  public readonly flushTimeout: number = 60;\n  private _pendingAggregates: Record<number, AggregationCounts> = {};\n  private _sessionAttrs: ReleaseHealthAttributes;\n  private _intervalId: ReturnType<typeof setInterval>;\n  private _isEnabled: boolean = true;\n  private _client: Client;\n\n  public constructor(client: Client, attrs: ReleaseHealthAttributes) {\n    this._client = client;\n    // Call to setInterval, so that flush is called every 60 seconds\n    this._intervalId = setInterval(() => this.flush(), this.flushTimeout * 1000);\n    this._sessionAttrs = attrs;\n  }\n\n  /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSession` */\n  public flush(): void {\n    const sessionAggregates = this.getSessionAggregates();\n    if (sessionAggregates.aggregates.length === 0) {\n      return;\n    }\n    this._pendingAggregates = {};\n    this._client.sendSession(sessionAggregates);\n  }\n\n  /** Massages the entries in `pendingAggregates` and returns aggregated sessions */\n  public getSessionAggregates(): SessionAggregates {\n    const aggregates: AggregationCounts[] = Object.keys(this._pendingAggregates).map((key: string) => {\n      return this._pendingAggregates[parseInt(key)];\n    });\n\n    const sessionAggregates: SessionAggregates = {\n      attrs: this._sessionAttrs,\n      aggregates,\n    };\n    return dropUndefinedKeys(sessionAggregates);\n  }\n\n  /** JSDoc */\n  public close(): void {\n    clearInterval(this._intervalId);\n    this._isEnabled = false;\n    this.flush();\n  }\n\n  /**\n   * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then\n   * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to\n   * `_incrementSessionStatusCount` along with the start date\n   */\n  public incrementSessionStatusCount(): void {\n    if (!this._isEnabled) {\n      return;\n    }\n    const scope = getCurrentHub().getScope();\n    const requestSession = scope.getRequestSession();\n\n    if (requestSession && requestSession.status) {\n      this._incrementSessionStatusCount(requestSession.status, new Date());\n      // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in\n      // case captureRequestSession is called more than once to prevent double count\n      scope.setRequestSession(undefined);\n      /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n    }\n  }\n\n  /**\n   * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of\n   * the session received\n   */\n  private _incrementSessionStatusCount(status: RequestSessionStatus, date: Date): number {\n    // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys\n    const sessionStartedTrunc = new Date(date).setSeconds(0, 0);\n    this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};\n\n    // corresponds to aggregated sessions in one specific minute bucket\n    // for example, {\"started\":\"2021-03-16T08:00:00.000Z\",\"exited\":4, \"errored\": 1}\n    const aggregationCounts: AggregationCounts = this._pendingAggregates[sessionStartedTrunc];\n    if (!aggregationCounts.started) {\n      aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();\n    }\n\n    switch (status) {\n      case 'errored':\n        aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;\n        return aggregationCounts.errored;\n      case 'ok':\n        aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;\n        return aggregationCounts.exited;\n      default:\n        aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;\n        return aggregationCounts.crashed;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}