{"ast":null,"code":"import { uuid4, dateTimestampInSeconds, resolvedSyncPromise, truncate, GLOBAL_OBJ, normalize } from '@sentry/utils';\nimport { DEFAULT_ENVIRONMENT } from '../constants.js';\nimport { Scope } from '../scope.js';\n\n/**\n * Adds common information to events.\n *\n * The information includes release and environment from `options`,\n * breadcrumbs and context (extra, tags and user) from the scope.\n *\n * Information that is already present in the event is never overwritten. For\n * nested objects, such as the context, keys are merged.\n *\n * Note: This also triggers callbacks for `addGlobalEventProcessor`, but not `beforeSend`.\n *\n * @param event The original event.\n * @param hint May contain additional information about the original exception.\n * @param scope A scope containing event metadata.\n * @returns A new event with more information.\n * @hidden\n */\nfunction prepareEvent(options, event, hint, scope) {\n  const {\n    normalizeDepth = 3,\n    normalizeMaxBreadth = 1000\n  } = options;\n  const prepared = {\n    ...event,\n    event_id: event.event_id || hint.event_id || uuid4(),\n    timestamp: event.timestamp || dateTimestampInSeconds()\n  };\n  const integrations = hint.integrations || options.integrations.map(i => i.name);\n  applyClientOptions(prepared, options);\n  applyIntegrationsMetadata(prepared, integrations);\n\n  // Only put debug IDs onto frames for error events.\n  if (event.type === undefined) {\n    applyDebugIds(prepared, options.stackParser);\n  }\n\n  // If we have scope given to us, use it as the base for further modifications.\n  // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n  let finalScope = scope;\n  if (hint.captureContext) {\n    finalScope = Scope.clone(finalScope).update(hint.captureContext);\n  }\n\n  // We prepare the result here with a resolved Event.\n  let result = resolvedSyncPromise(prepared);\n\n  // This should be the last thing called, since we want that\n  // {@link Hub.addEventProcessor} gets the finished prepared event.\n  //\n  // We need to check for the existence of `finalScope.getAttachments`\n  // because `getAttachments` can be undefined if users are using an older version\n  // of `@sentry/core` that does not have the `getAttachments` method.\n  // See: https://github.com/getsentry/sentry-javascript/issues/5229\n  if (finalScope) {\n    // Collect attachments from the hint and scope\n    if (finalScope.getAttachments) {\n      const attachments = [...(hint.attachments || []), ...finalScope.getAttachments()];\n      if (attachments.length) {\n        hint.attachments = attachments;\n      }\n    }\n\n    // In case we have a hub we reassign it.\n    result = finalScope.applyToEvent(prepared, hint);\n  }\n  return result.then(evt => {\n    if (evt) {\n      // We apply the debug_meta field only after all event processors have ran, so that if any event processors modified\n      // file names (e.g.the RewriteFrames integration) the filename -> debug ID relationship isn't destroyed.\n      // This should not cause any PII issues, since we're only moving data that is already on the event and not adding\n      // any new data\n      applyDebugMeta(evt);\n    }\n    if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n    }\n    return evt;\n  });\n}\n\n/**\n *  Enhances event using the client configuration.\n *  It takes care of all \"static\" values like environment, release and `dist`,\n *  as well as truncating overly long values.\n * @param event event instance to be enhanced\n */\nfunction applyClientOptions(event, options) {\n  const {\n    environment,\n    release,\n    dist,\n    maxValueLength = 250\n  } = options;\n  if (!('environment' in event)) {\n    event.environment = 'environment' in options ? environment : DEFAULT_ENVIRONMENT;\n  }\n  if (event.release === undefined && release !== undefined) {\n    event.release = release;\n  }\n  if (event.dist === undefined && dist !== undefined) {\n    event.dist = dist;\n  }\n  if (event.message) {\n    event.message = truncate(event.message, maxValueLength);\n  }\n  const exception = event.exception && event.exception.values && event.exception.values[0];\n  if (exception && exception.value) {\n    exception.value = truncate(exception.value, maxValueLength);\n  }\n  const request = event.request;\n  if (request && request.url) {\n    request.url = truncate(request.url, maxValueLength);\n  }\n}\nconst debugIdStackParserCache = new WeakMap();\n\n/**\n * Puts debug IDs into the stack frames of an error event.\n */\nfunction applyDebugIds(event, stackParser) {\n  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n  if (!debugIdMap) {\n    return;\n  }\n  let debugIdStackFramesCache;\n  const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);\n  if (cachedDebugIdStackFrameCache) {\n    debugIdStackFramesCache = cachedDebugIdStackFrameCache;\n  } else {\n    debugIdStackFramesCache = new Map();\n    debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);\n  }\n\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = Object.keys(debugIdMap).reduce((acc, debugIdStackTrace) => {\n    let parsedStack;\n    const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);\n    if (cachedParsedStack) {\n      parsedStack = cachedParsedStack;\n    } else {\n      parsedStack = stackParser(debugIdStackTrace);\n      debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);\n    }\n    for (let i = parsedStack.length - 1; i >= 0; i--) {\n      const stackFrame = parsedStack[i];\n      if (stackFrame.filename) {\n        acc[stackFrame.filename] = debugIdMap[debugIdStackTrace];\n        break;\n      }\n    }\n    return acc;\n  }, {});\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception.values.forEach(exception => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace.frames.forEach(frame => {\n        if (frame.filename) {\n          frame.debug_id = filenameDebugIdMap[frame.filename];\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n}\n\n/**\n * Moves debug IDs from the stack frames of an error event into the debug_meta field.\n */\nfunction applyDebugMeta(event) {\n  // Extract debug IDs and filenames from the stack frames on the event.\n  const filenameDebugIdMap = {};\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception.values.forEach(exception => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace.frames.forEach(frame => {\n        if (frame.debug_id) {\n          if (frame.abs_path) {\n            filenameDebugIdMap[frame.abs_path] = frame.debug_id;\n          } else if (frame.filename) {\n            filenameDebugIdMap[frame.filename] = frame.debug_id;\n          }\n          delete frame.debug_id;\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n  if (Object.keys(filenameDebugIdMap).length === 0) {\n    return;\n  }\n\n  // Fill debug_meta information\n  event.debug_meta = event.debug_meta || {};\n  event.debug_meta.images = event.debug_meta.images || [];\n  const images = event.debug_meta.images;\n  Object.keys(filenameDebugIdMap).forEach(filename => {\n    images.push({\n      type: 'sourcemap',\n      code_file: filename,\n      debug_id: filenameDebugIdMap[filename]\n    });\n  });\n}\n\n/**\n * This function adds all used integrations to the SDK info in the event.\n * @param event The event that will be filled with all integrations.\n */\nfunction applyIntegrationsMetadata(event, integrationNames) {\n  if (integrationNames.length > 0) {\n    event.sdk = event.sdk || {};\n    event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationNames];\n  }\n}\n\n/**\n * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n * Normalized keys:\n * - `breadcrumbs.data`\n * - `user`\n * - `contexts`\n * - `extra`\n * @param event Event\n * @returns Normalized event\n */\nfunction normalizeEvent(event, depth, maxBreadth) {\n  if (!event) {\n    return null;\n  }\n  const normalized = {\n    ...event,\n    ...(event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(b => ({\n        ...b,\n        ...(b.data && {\n          data: normalize(b.data, depth, maxBreadth)\n        })\n      }))\n    }),\n    ...(event.user && {\n      user: normalize(event.user, depth, maxBreadth)\n    }),\n    ...(event.contexts && {\n      contexts: normalize(event.contexts, depth, maxBreadth)\n    }),\n    ...(event.extra && {\n      extra: normalize(event.extra, depth, maxBreadth)\n    })\n  };\n\n  // event.contexts.trace stores information about a Transaction. Similarly,\n  // event.spans[] stores information about child Spans. Given that a\n  // Transaction is conceptually a Span, normalization should apply to both\n  // Transactions and Spans consistently.\n  // For now the decision is to skip normalization of Transactions and Spans,\n  // so this block overwrites the normalized event to add back the original\n  // Transaction information prior to normalization.\n  if (event.contexts && event.contexts.trace && normalized.contexts) {\n    normalized.contexts.trace = event.contexts.trace;\n\n    // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n    if (event.contexts.trace.data) {\n      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n    }\n  }\n\n  // event.spans[].data may contain circular/dangerous data so we need to normalize it\n  if (event.spans) {\n    normalized.spans = event.spans.map(span => {\n      // We cannot use the spread operator here because `toJSON` on `span` is non-enumerable\n      if (span.data) {\n        span.data = normalize(span.data, depth, maxBreadth);\n      }\n      return span;\n    });\n  }\n  return normalized;\n}\nexport { applyDebugIds, applyDebugMeta, prepareEvent };","map":{"version":3,"names":["prepareEvent","options","event","hint","scope","normalizeDepth","normalizeMaxBreadth","prepared","event_id","uuid4","timestamp","dateTimestampInSeconds","integrations","map","i","name","applyClientOptions","applyIntegrationsMetadata","type","undefined","applyDebugIds","stackParser","finalScope","captureContext","Scope","clone","update","result","resolvedSyncPromise","getAttachments","attachments","length","applyToEvent","then","evt","applyDebugMeta","normalizeEvent","environment","release","dist","maxValueLength","DEFAULT_ENVIRONMENT","message","truncate","exception","values","value","request","url","debugIdStackParserCache","WeakMap","debugIdMap","GLOBAL_OBJ","_sentryDebugIds","debugIdStackFramesCache","cachedDebugIdStackFrameCache","get","Map","set","filenameDebugIdMap","Object","keys","reduce","acc","debugIdStackTrace","parsedStack","cachedParsedStack","stackFrame","filename","forEach","stacktrace","frames","frame","debug_id","e","abs_path","debug_meta","images","push","code_file","integrationNames","sdk","depth","maxBreadth","normalized","breadcrumbs","b","data","normalize","user","contexts","extra","trace","spans","span"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/utils/prepareEvent.ts"],"sourcesContent":["import type { ClientOptions, Event, EventHint, StackFrame, StackParser } from '@sentry/types';\nimport { dateTimestampInSeconds, GLOBAL_OBJ, normalize, resolvedSyncPromise, truncate, uuid4 } from '@sentry/utils';\n\nimport { DEFAULT_ENVIRONMENT } from '../constants';\nimport { Scope } from '../scope';\n\n/**\n * Adds common information to events.\n *\n * The information includes release and environment from `options`,\n * breadcrumbs and context (extra, tags and user) from the scope.\n *\n * Information that is already present in the event is never overwritten. For\n * nested objects, such as the context, keys are merged.\n *\n * Note: This also triggers callbacks for `addGlobalEventProcessor`, but not `beforeSend`.\n *\n * @param event The original event.\n * @param hint May contain additional information about the original exception.\n * @param scope A scope containing event metadata.\n * @returns A new event with more information.\n * @hidden\n */\nexport function prepareEvent(\n  options: ClientOptions,\n  event: Event,\n  hint: EventHint,\n  scope?: Scope,\n): PromiseLike<Event | null> {\n  const { normalizeDepth = 3, normalizeMaxBreadth = 1_000 } = options;\n  const prepared: Event = {\n    ...event,\n    event_id: event.event_id || hint.event_id || uuid4(),\n    timestamp: event.timestamp || dateTimestampInSeconds(),\n  };\n  const integrations = hint.integrations || options.integrations.map(i => i.name);\n\n  applyClientOptions(prepared, options);\n  applyIntegrationsMetadata(prepared, integrations);\n\n  // Only put debug IDs onto frames for error events.\n  if (event.type === undefined) {\n    applyDebugIds(prepared, options.stackParser);\n  }\n\n  // If we have scope given to us, use it as the base for further modifications.\n  // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n  let finalScope = scope;\n  if (hint.captureContext) {\n    finalScope = Scope.clone(finalScope).update(hint.captureContext);\n  }\n\n  // We prepare the result here with a resolved Event.\n  let result = resolvedSyncPromise<Event | null>(prepared);\n\n  // This should be the last thing called, since we want that\n  // {@link Hub.addEventProcessor} gets the finished prepared event.\n  //\n  // We need to check for the existence of `finalScope.getAttachments`\n  // because `getAttachments` can be undefined if users are using an older version\n  // of `@sentry/core` that does not have the `getAttachments` method.\n  // See: https://github.com/getsentry/sentry-javascript/issues/5229\n  if (finalScope) {\n    // Collect attachments from the hint and scope\n    if (finalScope.getAttachments) {\n      const attachments = [...(hint.attachments || []), ...finalScope.getAttachments()];\n\n      if (attachments.length) {\n        hint.attachments = attachments;\n      }\n    }\n\n    // In case we have a hub we reassign it.\n    result = finalScope.applyToEvent(prepared, hint);\n  }\n\n  return result.then(evt => {\n    if (evt) {\n      // We apply the debug_meta field only after all event processors have ran, so that if any event processors modified\n      // file names (e.g.the RewriteFrames integration) the filename -> debug ID relationship isn't destroyed.\n      // This should not cause any PII issues, since we're only moving data that is already on the event and not adding\n      // any new data\n      applyDebugMeta(evt);\n    }\n\n    if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n    }\n    return evt;\n  });\n}\n\n/**\n *  Enhances event using the client configuration.\n *  It takes care of all \"static\" values like environment, release and `dist`,\n *  as well as truncating overly long values.\n * @param event event instance to be enhanced\n */\nfunction applyClientOptions(event: Event, options: ClientOptions): void {\n  const { environment, release, dist, maxValueLength = 250 } = options;\n\n  if (!('environment' in event)) {\n    event.environment = 'environment' in options ? environment : DEFAULT_ENVIRONMENT;\n  }\n\n  if (event.release === undefined && release !== undefined) {\n    event.release = release;\n  }\n\n  if (event.dist === undefined && dist !== undefined) {\n    event.dist = dist;\n  }\n\n  if (event.message) {\n    event.message = truncate(event.message, maxValueLength);\n  }\n\n  const exception = event.exception && event.exception.values && event.exception.values[0];\n  if (exception && exception.value) {\n    exception.value = truncate(exception.value, maxValueLength);\n  }\n\n  const request = event.request;\n  if (request && request.url) {\n    request.url = truncate(request.url, maxValueLength);\n  }\n}\n\nconst debugIdStackParserCache = new WeakMap<StackParser, Map<string, StackFrame[]>>();\n\n/**\n * Puts debug IDs into the stack frames of an error event.\n */\nexport function applyDebugIds(event: Event, stackParser: StackParser): void {\n  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n\n  if (!debugIdMap) {\n    return;\n  }\n\n  let debugIdStackFramesCache: Map<string, StackFrame[]>;\n  const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);\n  if (cachedDebugIdStackFrameCache) {\n    debugIdStackFramesCache = cachedDebugIdStackFrameCache;\n  } else {\n    debugIdStackFramesCache = new Map<string, StackFrame[]>();\n    debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);\n  }\n\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = Object.keys(debugIdMap).reduce<Record<string, string>>((acc, debugIdStackTrace) => {\n    let parsedStack: StackFrame[];\n    const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);\n    if (cachedParsedStack) {\n      parsedStack = cachedParsedStack;\n    } else {\n      parsedStack = stackParser(debugIdStackTrace);\n      debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);\n    }\n\n    for (let i = parsedStack.length - 1; i >= 0; i--) {\n      const stackFrame = parsedStack[i];\n      if (stackFrame.filename) {\n        acc[stackFrame.filename] = debugIdMap[debugIdStackTrace];\n        break;\n      }\n    }\n    return acc;\n  }, {});\n\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event!.exception!.values!.forEach(exception => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace!.frames!.forEach(frame => {\n        if (frame.filename) {\n          frame.debug_id = filenameDebugIdMap[frame.filename];\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n}\n\n/**\n * Moves debug IDs from the stack frames of an error event into the debug_meta field.\n */\nexport function applyDebugMeta(event: Event): void {\n  // Extract debug IDs and filenames from the stack frames on the event.\n  const filenameDebugIdMap: Record<string, string> = {};\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception!.values!.forEach(exception => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace!.frames!.forEach(frame => {\n        if (frame.debug_id) {\n          if (frame.abs_path) {\n            filenameDebugIdMap[frame.abs_path] = frame.debug_id;\n          } else if (frame.filename) {\n            filenameDebugIdMap[frame.filename] = frame.debug_id;\n          }\n          delete frame.debug_id;\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n\n  if (Object.keys(filenameDebugIdMap).length === 0) {\n    return;\n  }\n\n  // Fill debug_meta information\n  event.debug_meta = event.debug_meta || {};\n  event.debug_meta.images = event.debug_meta.images || [];\n  const images = event.debug_meta.images;\n  Object.keys(filenameDebugIdMap).forEach(filename => {\n    images.push({\n      type: 'sourcemap',\n      code_file: filename,\n      debug_id: filenameDebugIdMap[filename],\n    });\n  });\n}\n\n/**\n * This function adds all used integrations to the SDK info in the event.\n * @param event The event that will be filled with all integrations.\n */\nfunction applyIntegrationsMetadata(event: Event, integrationNames: string[]): void {\n  if (integrationNames.length > 0) {\n    event.sdk = event.sdk || {};\n    event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationNames];\n  }\n}\n\n/**\n * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n * Normalized keys:\n * - `breadcrumbs.data`\n * - `user`\n * - `contexts`\n * - `extra`\n * @param event Event\n * @returns Normalized event\n */\nfunction normalizeEvent(event: Event | null, depth: number, maxBreadth: number): Event | null {\n  if (!event) {\n    return null;\n  }\n\n  const normalized: Event = {\n    ...event,\n    ...(event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(b => ({\n        ...b,\n        ...(b.data && {\n          data: normalize(b.data, depth, maxBreadth),\n        }),\n      })),\n    }),\n    ...(event.user && {\n      user: normalize(event.user, depth, maxBreadth),\n    }),\n    ...(event.contexts && {\n      contexts: normalize(event.contexts, depth, maxBreadth),\n    }),\n    ...(event.extra && {\n      extra: normalize(event.extra, depth, maxBreadth),\n    }),\n  };\n\n  // event.contexts.trace stores information about a Transaction. Similarly,\n  // event.spans[] stores information about child Spans. Given that a\n  // Transaction is conceptually a Span, normalization should apply to both\n  // Transactions and Spans consistently.\n  // For now the decision is to skip normalization of Transactions and Spans,\n  // so this block overwrites the normalized event to add back the original\n  // Transaction information prior to normalization.\n  if (event.contexts && event.contexts.trace && normalized.contexts) {\n    normalized.contexts.trace = event.contexts.trace;\n\n    // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n    if (event.contexts.trace.data) {\n      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n    }\n  }\n\n  // event.spans[].data may contain circular/dangerous data so we need to normalize it\n  if (event.spans) {\n    normalized.spans = event.spans.map(span => {\n      // We cannot use the spread operator here because `toJSON` on `span` is non-enumerable\n      if (span.data) {\n        span.data = normalize(span.data, depth, maxBreadth);\n      }\n      return span;\n    });\n  }\n\n  return normalized;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}