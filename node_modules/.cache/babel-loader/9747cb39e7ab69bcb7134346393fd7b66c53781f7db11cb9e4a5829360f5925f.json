{"ast":null,"code":"import _slicedToArray from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { isString } from './is.js';\nimport { logger } from './logger.js';\nvar BAGGAGE_HEADER_NAME = 'baggage';\nvar SENTRY_BAGGAGE_KEY_PREFIX = 'sentry-';\nvar SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;\n\n/**\n * Max length of a serialized baggage string\n *\n * https://www.w3.org/TR/baggage/#limits\n */\nvar MAX_BAGGAGE_STRING_LENGTH = 8192;\n\n/**\n * Takes a baggage header and turns it into Dynamic Sampling Context, by extracting all the \"sentry-\" prefixed values\n * from it.\n *\n * @param baggageHeader A very bread definition of a baggage header as it might appear in various frameworks.\n * @returns The Dynamic Sampling Context that was found on `baggageHeader`, if there was any, `undefined` otherwise.\n */\nfunction baggageHeaderToDynamicSamplingContext(\n// Very liberal definition of what any incoming header might look like\nbaggageHeader) {\n  if (!isString(baggageHeader) && !Array.isArray(baggageHeader)) {\n    return undefined;\n  }\n\n  // Intermediary object to store baggage key value pairs of incoming baggage headers on.\n  // It is later used to read Sentry-DSC-values from.\n  var baggageObject = {};\n  if (Array.isArray(baggageHeader)) {\n    // Combine all baggage headers into one object containing the baggage values so we can later read the Sentry-DSC-values from it\n    baggageObject = baggageHeader.reduce(function (acc, curr) {\n      var currBaggageObject = baggageHeaderToObject(curr);\n      return _objectSpread(_objectSpread({}, acc), currBaggageObject);\n    }, {});\n  } else {\n    // Return undefined if baggage header is an empty string (technically an empty baggage header is not spec conform but\n    // this is how we choose to handle it)\n    if (!baggageHeader) {\n      return undefined;\n    }\n    baggageObject = baggageHeaderToObject(baggageHeader);\n  }\n\n  // Read all \"sentry-\" prefixed values out of the baggage object and put it onto a dynamic sampling context object.\n  var dynamicSamplingContext = Object.entries(baggageObject).reduce(function (acc, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      key = _ref2[0],\n      value = _ref2[1];\n    if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {\n      var nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);\n      acc[nonPrefixedKey] = value;\n    }\n    return acc;\n  }, {});\n\n  // Only return a dynamic sampling context object if there are keys in it.\n  // A keyless object means there were no sentry values on the header, which means that there is no DSC.\n  if (Object.keys(dynamicSamplingContext).length > 0) {\n    return dynamicSamplingContext;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Turns a Dynamic Sampling Object into a baggage header by prefixing all the keys on the object with \"sentry-\".\n *\n * @param dynamicSamplingContext The Dynamic Sampling Context to turn into a header. For convenience and compatibility\n * with the `getDynamicSamplingContext` method on the Transaction class ,this argument can also be `undefined`. If it is\n * `undefined` the function will return `undefined`.\n * @returns a baggage header, created from `dynamicSamplingContext`, or `undefined` either if `dynamicSamplingContext`\n * was `undefined`, or if `dynamicSamplingContext` didn't contain any values.\n */\nfunction dynamicSamplingContextToSentryBaggageHeader(\n// this also takes undefined for convenience and bundle size in other places\ndynamicSamplingContext) {\n  // Prefix all DSC keys with \"sentry-\" and put them into a new object\n  var sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce(function (acc, _ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n      dscKey = _ref4[0],\n      dscValue = _ref4[1];\n    if (dscValue) {\n      acc[\"\".concat(SENTRY_BAGGAGE_KEY_PREFIX).concat(dscKey)] = dscValue;\n    }\n    return acc;\n  }, {});\n  return objectToBaggageHeader(sentryPrefixedDSC);\n}\n\n/**\n * Will parse a baggage header, which is a simple key-value map, into a flat object.\n *\n * @param baggageHeader The baggage header to parse.\n * @returns a flat object containing all the key-value pairs from `baggageHeader`.\n */\nfunction baggageHeaderToObject(baggageHeader) {\n  return baggageHeader.split(',').map(function (baggageEntry) {\n    return baggageEntry.split('=').map(function (keyOrValue) {\n      return decodeURIComponent(keyOrValue.trim());\n    });\n  }).reduce(function (acc, _ref5) {\n    var _ref6 = _slicedToArray(_ref5, 2),\n      key = _ref6[0],\n      value = _ref6[1];\n    acc[key] = value;\n    return acc;\n  }, {});\n}\n\n/**\n * Turns a flat object (key-value pairs) into a baggage header, which is also just key-value pairs.\n *\n * @param object The object to turn into a baggage header.\n * @returns a baggage header string, or `undefined` if the object didn't have any values, since an empty baggage header\n * is not spec compliant.\n */\nfunction objectToBaggageHeader(object) {\n  if (Object.keys(object).length === 0) {\n    // An empty baggage header is not spec compliant: We return undefined.\n    return undefined;\n  }\n  return Object.entries(object).reduce(function (baggageHeader, _ref7, currentIndex) {\n    var _ref8 = _slicedToArray(_ref7, 2),\n      objectKey = _ref8[0],\n      objectValue = _ref8[1];\n    var baggageEntry = \"\".concat(encodeURIComponent(objectKey), \"=\").concat(encodeURIComponent(objectValue));\n    var newBaggageHeader = currentIndex === 0 ? baggageEntry : \"\".concat(baggageHeader, \",\").concat(baggageEntry);\n    if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(\"Not adding key: \".concat(objectKey, \" with val: \").concat(objectValue, \" to baggage header due to exceeding baggage size limits.\"));\n      return baggageHeader;\n    } else {\n      return newBaggageHeader;\n    }\n  }, '');\n}\nexport { BAGGAGE_HEADER_NAME, MAX_BAGGAGE_STRING_LENGTH, SENTRY_BAGGAGE_KEY_PREFIX, SENTRY_BAGGAGE_KEY_PREFIX_REGEX, baggageHeaderToDynamicSamplingContext, dynamicSamplingContextToSentryBaggageHeader };","map":{"version":3,"names":["BAGGAGE_HEADER_NAME","SENTRY_BAGGAGE_KEY_PREFIX","SENTRY_BAGGAGE_KEY_PREFIX_REGEX","MAX_BAGGAGE_STRING_LENGTH","baggageHeaderToDynamicSamplingContext","baggageHeader","isString","Array","isArray","undefined","baggageObject","reduce","acc","curr","currBaggageObject","baggageHeaderToObject","_objectSpread","dynamicSamplingContext","Object","entries","_ref","_ref2","_slicedToArray","key","value","match","nonPrefixedKey","slice","length","keys","dynamicSamplingContextToSentryBaggageHeader","sentryPrefixedDSC","_ref3","_ref4","dscKey","dscValue","concat","objectToBaggageHeader","split","map","baggageEntry","keyOrValue","decodeURIComponent","trim","_ref5","_ref6","object","_ref7","currentIndex","_ref8","objectKey","objectValue","encodeURIComponent","newBaggageHeader","__SENTRY_DEBUG__","logger","warn"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/baggage.ts"],"sourcesContent":["import type { DynamicSamplingContext } from '@sentry/types';\n\nimport { isString } from './is';\nimport { logger } from './logger';\n\nexport const BAGGAGE_HEADER_NAME = 'baggage';\n\nexport const SENTRY_BAGGAGE_KEY_PREFIX = 'sentry-';\n\nexport const SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;\n\n/**\n * Max length of a serialized baggage string\n *\n * https://www.w3.org/TR/baggage/#limits\n */\nexport const MAX_BAGGAGE_STRING_LENGTH = 8192;\n\n/**\n * Takes a baggage header and turns it into Dynamic Sampling Context, by extracting all the \"sentry-\" prefixed values\n * from it.\n *\n * @param baggageHeader A very bread definition of a baggage header as it might appear in various frameworks.\n * @returns The Dynamic Sampling Context that was found on `baggageHeader`, if there was any, `undefined` otherwise.\n */\nexport function baggageHeaderToDynamicSamplingContext(\n  // Very liberal definition of what any incoming header might look like\n  baggageHeader: string | string[] | number | null | undefined | boolean,\n): Partial<DynamicSamplingContext> | undefined {\n  if (!isString(baggageHeader) && !Array.isArray(baggageHeader)) {\n    return undefined;\n  }\n\n  // Intermediary object to store baggage key value pairs of incoming baggage headers on.\n  // It is later used to read Sentry-DSC-values from.\n  let baggageObject: Readonly<Record<string, string>> = {};\n\n  if (Array.isArray(baggageHeader)) {\n    // Combine all baggage headers into one object containing the baggage values so we can later read the Sentry-DSC-values from it\n    baggageObject = baggageHeader.reduce<Record<string, string>>((acc, curr) => {\n      const currBaggageObject = baggageHeaderToObject(curr);\n      return {\n        ...acc,\n        ...currBaggageObject,\n      };\n    }, {});\n  } else {\n    // Return undefined if baggage header is an empty string (technically an empty baggage header is not spec conform but\n    // this is how we choose to handle it)\n    if (!baggageHeader) {\n      return undefined;\n    }\n\n    baggageObject = baggageHeaderToObject(baggageHeader);\n  }\n\n  // Read all \"sentry-\" prefixed values out of the baggage object and put it onto a dynamic sampling context object.\n  const dynamicSamplingContext = Object.entries(baggageObject).reduce<Record<string, string>>((acc, [key, value]) => {\n    if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {\n      const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);\n      acc[nonPrefixedKey] = value;\n    }\n    return acc;\n  }, {});\n\n  // Only return a dynamic sampling context object if there are keys in it.\n  // A keyless object means there were no sentry values on the header, which means that there is no DSC.\n  if (Object.keys(dynamicSamplingContext).length > 0) {\n    return dynamicSamplingContext as Partial<DynamicSamplingContext>;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Turns a Dynamic Sampling Object into a baggage header by prefixing all the keys on the object with \"sentry-\".\n *\n * @param dynamicSamplingContext The Dynamic Sampling Context to turn into a header. For convenience and compatibility\n * with the `getDynamicSamplingContext` method on the Transaction class ,this argument can also be `undefined`. If it is\n * `undefined` the function will return `undefined`.\n * @returns a baggage header, created from `dynamicSamplingContext`, or `undefined` either if `dynamicSamplingContext`\n * was `undefined`, or if `dynamicSamplingContext` didn't contain any values.\n */\nexport function dynamicSamplingContextToSentryBaggageHeader(\n  // this also takes undefined for convenience and bundle size in other places\n  dynamicSamplingContext: Partial<DynamicSamplingContext>,\n): string | undefined {\n  // Prefix all DSC keys with \"sentry-\" and put them into a new object\n  const sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce<Record<string, string>>(\n    (acc, [dscKey, dscValue]) => {\n      if (dscValue) {\n        acc[`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`] = dscValue;\n      }\n      return acc;\n    },\n    {},\n  );\n\n  return objectToBaggageHeader(sentryPrefixedDSC);\n}\n\n/**\n * Will parse a baggage header, which is a simple key-value map, into a flat object.\n *\n * @param baggageHeader The baggage header to parse.\n * @returns a flat object containing all the key-value pairs from `baggageHeader`.\n */\nfunction baggageHeaderToObject(baggageHeader: string): Record<string, string> {\n  return baggageHeader\n    .split(',')\n    .map(baggageEntry => baggageEntry.split('=').map(keyOrValue => decodeURIComponent(keyOrValue.trim())))\n    .reduce<Record<string, string>>((acc, [key, value]) => {\n      acc[key] = value;\n      return acc;\n    }, {});\n}\n\n/**\n * Turns a flat object (key-value pairs) into a baggage header, which is also just key-value pairs.\n *\n * @param object The object to turn into a baggage header.\n * @returns a baggage header string, or `undefined` if the object didn't have any values, since an empty baggage header\n * is not spec compliant.\n */\nfunction objectToBaggageHeader(object: Record<string, string>): string | undefined {\n  if (Object.keys(object).length === 0) {\n    // An empty baggage header is not spec compliant: We return undefined.\n    return undefined;\n  }\n\n  return Object.entries(object).reduce((baggageHeader, [objectKey, objectValue], currentIndex) => {\n    const baggageEntry = `${encodeURIComponent(objectKey)}=${encodeURIComponent(objectValue)}`;\n    const newBaggageHeader = currentIndex === 0 ? baggageEntry : `${baggageHeader},${baggageEntry}`;\n    if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {\n      __DEBUG_BUILD__ &&\n        logger.warn(\n          `Not adding key: ${objectKey} with val: ${objectValue} to baggage header due to exceeding baggage size limits.`,\n        );\n      return baggageHeader;\n    } else {\n      return newBaggageHeader;\n    }\n  }, '');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}