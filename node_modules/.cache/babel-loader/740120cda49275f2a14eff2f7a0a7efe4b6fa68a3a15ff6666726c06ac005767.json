{"ast":null,"code":"import _slicedToArray from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { isString } from './is.js';\nimport { logger, CONSOLE_LEVELS } from './logger.js';\nimport { fill } from './object.js';\nimport { getFunctionName } from './stacktrace.js';\nimport { supportsNativeFetch } from './supports.js';\nimport { getGlobalObject } from './worldwide.js';\nimport { supportsHistory } from './vendor/supportsHistory.js';\n\n// eslint-disable-next-line deprecation/deprecation\nvar WINDOW = getGlobalObject();\nvar SENTRY_XHR_DATA_KEY = '__sentry_xhr_v2__';\n\n/**\n * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.\n *  - Console API\n *  - Fetch API\n *  - XHR API\n *  - History API\n *  - DOM API (click/typing)\n *  - Error API\n *  - UnhandledRejection API\n */\n\nvar handlers = {};\nvar instrumented = {};\n\n/** Instruments given API */\nfunction instrument(type) {\n  if (instrumented[type]) {\n    return;\n  }\n  instrumented[type] = true;\n  switch (type) {\n    case 'console':\n      instrumentConsole();\n      break;\n    case 'dom':\n      instrumentDOM();\n      break;\n    case 'xhr':\n      instrumentXHR();\n      break;\n    case 'fetch':\n      instrumentFetch();\n      break;\n    case 'history':\n      instrumentHistory();\n      break;\n    case 'error':\n      instrumentError();\n      break;\n    case 'unhandledrejection':\n      instrumentUnhandledRejection();\n      break;\n    default:\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('unknown instrumentation type:', type);\n      return;\n  }\n}\n\n/**\n * Add handler that will be called when given type of instrumentation triggers.\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addInstrumentationHandler(type, callback) {\n  handlers[type] = handlers[type] || [];\n  handlers[type].push(callback);\n  instrument(type);\n}\n\n/** JSDoc */\nfunction triggerHandlers(type, data) {\n  if (!type || !handlers[type]) {\n    return;\n  }\n  var _iterator = _createForOfIteratorHelper(handlers[type] || []),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var handler = _step.value;\n      try {\n        handler(data);\n      } catch (e) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error(\"Error while triggering instrumentation handler.\\nType: \".concat(type, \"\\nName: \").concat(getFunctionName(handler), \"\\nError:\"), e);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\n/** JSDoc */\nfunction instrumentConsole() {\n  if (!('console' in WINDOW)) {\n    return;\n  }\n  CONSOLE_LEVELS.forEach(function (level) {\n    if (!(level in WINDOW.console)) {\n      return;\n    }\n    fill(WINDOW.console, level, function (originalConsoleMethod) {\n      return function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        triggerHandlers('console', {\n          args: args,\n          level: level\n        });\n\n        // this fails for some browsers. :(\n        if (originalConsoleMethod) {\n          originalConsoleMethod.apply(WINDOW.console, args);\n        }\n      };\n    });\n  });\n}\n\n/** JSDoc */\nfunction instrumentFetch() {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n  fill(WINDOW, 'fetch', function (originalFetch) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      var _parseFetchArgs = parseFetchArgs(args),\n        method = _parseFetchArgs.method,\n        url = _parseFetchArgs.url;\n      var handlerData = {\n        args: args,\n        fetchData: {\n          method: method,\n          url: url\n        },\n        startTimestamp: Date.now()\n      };\n      triggerHandlers('fetch', _objectSpread({}, handlerData));\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalFetch.apply(WINDOW, args).then(function (response) {\n        triggerHandlers('fetch', _objectSpread(_objectSpread({}, handlerData), {}, {\n          endTimestamp: Date.now(),\n          response: response\n        }));\n        return response;\n      }, function (error) {\n        triggerHandlers('fetch', _objectSpread(_objectSpread({}, handlerData), {}, {\n          endTimestamp: Date.now(),\n          error: error\n        }));\n        // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n        //       it means the sentry.javascript SDK caught an error invoking your application code.\n        //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n        throw error;\n      });\n    };\n  });\n}\nfunction hasProp(obj, prop) {\n  return !!obj && typeof obj === 'object' && !!obj[prop];\n}\nfunction getUrlFromResource(resource) {\n  if (typeof resource === 'string') {\n    return resource;\n  }\n  if (!resource) {\n    return '';\n  }\n  if (hasProp(resource, 'url')) {\n    return resource.url;\n  }\n  if (resource.toString) {\n    return resource.toString();\n  }\n  return '';\n}\n\n/**\n * Parses the fetch arguments to find the used Http method and the url of the request\n */\nfunction parseFetchArgs(fetchArgs) {\n  if (fetchArgs.length === 0) {\n    return {\n      method: 'GET',\n      url: ''\n    };\n  }\n  if (fetchArgs.length === 2) {\n    var _fetchArgs = _slicedToArray(fetchArgs, 2),\n      url = _fetchArgs[0],\n      options = _fetchArgs[1];\n    return {\n      url: getUrlFromResource(url),\n      method: hasProp(options, 'method') ? String(options.method).toUpperCase() : 'GET'\n    };\n  }\n  var arg = fetchArgs[0];\n  return {\n    url: getUrlFromResource(arg),\n    method: hasProp(arg, 'method') ? String(arg.method).toUpperCase() : 'GET'\n  };\n}\n\n/** JSDoc */\nfunction instrumentXHR() {\n  if (!('XMLHttpRequest' in WINDOW)) {\n    return;\n  }\n  var xhrproto = XMLHttpRequest.prototype;\n  fill(xhrproto, 'open', function (originalOpen) {\n    return function () {\n      var _this = this;\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      var url = args[1];\n      var xhrInfo = this[SENTRY_XHR_DATA_KEY] = {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        method: isString(args[0]) ? args[0].toUpperCase() : args[0],\n        url: args[1],\n        request_headers: {}\n      };\n\n      // if Sentry key appears in URL, don't capture it as a request\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (isString(url) && xhrInfo.method === 'POST' && url.match(/sentry_key/)) {\n        this.__sentry_own_request__ = true;\n      }\n      var onreadystatechangeHandler = function onreadystatechangeHandler() {\n        // For whatever reason, this is not the same instance here as from the outer method\n        var xhrInfo = _this[SENTRY_XHR_DATA_KEY];\n        if (!xhrInfo) {\n          return;\n        }\n        if (_this.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = _this.status;\n          } catch (e) {\n            /* do nothing */\n          }\n          triggerHandlers('xhr', {\n            args: args,\n            endTimestamp: Date.now(),\n            startTimestamp: Date.now(),\n            xhr: _this\n          });\n        }\n      };\n      if ('onreadystatechange' in this && typeof this.onreadystatechange === 'function') {\n        fill(this, 'onreadystatechange', function (original) {\n          return function () {\n            onreadystatechangeHandler();\n            for (var _len4 = arguments.length, readyStateArgs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n              readyStateArgs[_key4] = arguments[_key4];\n            }\n            return original.apply(this, readyStateArgs);\n          };\n        });\n      } else {\n        this.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      // Intercepting `setRequestHeader` to access the request headers of XHR instance.\n      // This will only work for user/library defined headers, not for the default/browser-assigned headers.\n      // Request cookies are also unavailable for XHR, as `Cookie` header can't be defined by `setRequestHeader`.\n      fill(this, 'setRequestHeader', function (original) {\n        return function () {\n          for (var _len5 = arguments.length, setRequestHeaderArgs = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n            setRequestHeaderArgs[_key5] = arguments[_key5];\n          }\n          var header = setRequestHeaderArgs[0],\n            value = setRequestHeaderArgs[1];\n          var xhrInfo = this[SENTRY_XHR_DATA_KEY];\n          if (xhrInfo) {\n            xhrInfo.request_headers[header.toLowerCase()] = value;\n          }\n          return original.apply(this, setRequestHeaderArgs);\n        };\n      });\n      return originalOpen.apply(this, args);\n    };\n  });\n  fill(xhrproto, 'send', function (originalSend) {\n    return function () {\n      var sentryXhrData = this[SENTRY_XHR_DATA_KEY];\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      if (sentryXhrData && args[0] !== undefined) {\n        sentryXhrData.body = args[0];\n      }\n      triggerHandlers('xhr', {\n        args: args,\n        startTimestamp: Date.now(),\n        xhr: this\n      });\n      return originalSend.apply(this, args);\n    };\n  });\n}\nvar lastHref;\n\n/** JSDoc */\nfunction instrumentHistory() {\n  if (!supportsHistory()) {\n    return;\n  }\n  var oldOnPopState = WINDOW.onpopstate;\n  WINDOW.onpopstate = function () {\n    var to = WINDOW.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    var from = lastHref;\n    lastHref = to;\n    triggerHandlers('history', {\n      from: from,\n      to: to\n    });\n    if (oldOnPopState) {\n      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.\n      // https://github.com/getsentry/sentry-javascript/issues/3344\n      // https://github.com/bugsnag/bugsnag-js/issues/469\n      try {\n        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n          args[_key7] = arguments[_key7];\n        }\n        return oldOnPopState.apply(this, args);\n      } catch (_oO) {\n        // no-empty\n      }\n    }\n  };\n\n  /** @hidden */\n  function historyReplacementFunction(originalHistoryFunction) {\n    return function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      var url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        var from = lastHref;\n        var to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        triggerHandlers('history', {\n          from: from,\n          to: to\n        });\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n  fill(WINDOW.history, 'pushState', historyReplacementFunction);\n  fill(WINDOW.history, 'replaceState', historyReplacementFunction);\n}\nvar debounceDuration = 1000;\nvar debounceTimerID;\nvar lastCapturedEvent;\n\n/**\n * Decide whether the current event should finish the debounce of previously captured one.\n * @param previous previously captured event\n * @param current event to be captured\n */\nfunction shouldShortcircuitPreviousDebounce(previous, current) {\n  // If there was no previous event, it should always be swapped for the new one.\n  if (!previous) {\n    return true;\n  }\n\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (previous.type !== current.type) {\n    return true;\n  }\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (previous.target !== current.target) {\n      return true;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return false;\n}\n\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(event) {\n  // We are only interested in filtering `keypress` events for now.\n  if (event.type !== 'keypress') {\n    return false;\n  }\n  try {\n    var target = event.target;\n    if (!target || !target.tagName) {\n      return true;\n    }\n\n    // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n    // e.g.tabbing through elements, hotkeys, etc.\n    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n      return false;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n  return true;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param handler function that will be triggered\n * @param globalListener indicates whether event was captured by the global event listener\n * @returns wrapped breadcrumb events handler\n * @hidden\n */\nfunction makeDOMEventHandler(handler) {\n  var globalListener = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return function (event) {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || lastCapturedEvent === event) {\n      return;\n    }\n\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event)) {\n      return;\n    }\n    var name = event.type === 'keypress' ? 'input' : event.type;\n\n    // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.\n    if (debounceTimerID === undefined) {\n      handler({\n        event: event,\n        name: name,\n        global: globalListener\n      });\n      lastCapturedEvent = event;\n    }\n    // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {\n      handler({\n        event: event,\n        name: name,\n        global: globalListener\n      });\n      lastCapturedEvent = event;\n    }\n\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = WINDOW.setTimeout(function () {\n      debounceTimerID = undefined;\n    }, debounceDuration);\n  };\n}\n\n/** JSDoc */\nfunction instrumentDOM() {\n  if (!('document' in WINDOW)) {\n    return;\n  }\n\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  var triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  var globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  WINDOW.document.addEventListener('click', globalDOMEventHandler, false);\n  WINDOW.document.addEventListener('keypress', globalDOMEventHandler, false);\n\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach(function (target) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    var proto = WINDOW[target] && WINDOW[target].prototype;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n    fill(proto, 'addEventListener', function (originalAddEventListener) {\n      return function (type, listener, options) {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            var el = this;\n            var _handlers = el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {};\n            var handlerForType = _handlers[type] = _handlers[type] || {\n              refCount: 0\n            };\n            if (!handlerForType.handler) {\n              var handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n            handlerForType.refCount++;\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n    fill(proto, 'removeEventListener', function (originalRemoveEventListener) {\n      return function (type, listener, options) {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            var el = this;\n            var _handlers2 = el.__sentry_instrumentation_handlers__ || {};\n            var handlerForType = _handlers2[type];\n            if (handlerForType) {\n              handlerForType.refCount--;\n              // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n              if (handlerForType.refCount <= 0) {\n                originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                handlerForType.handler = undefined;\n                delete _handlers2[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n              }\n\n              // If there are no longer any custom handlers of any type on this element, cleanup everything.\n              if (Object.keys(_handlers2).length === 0) {\n                delete el.__sentry_instrumentation_handlers__;\n              }\n            }\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n        return originalRemoveEventListener.call(this, type, listener, options);\n      };\n    });\n  });\n}\nvar _oldOnErrorHandler = null;\n/** JSDoc */\nfunction instrumentError() {\n  _oldOnErrorHandler = WINDOW.onerror;\n  WINDOW.onerror = function (msg, url, line, column, error) {\n    triggerHandlers('error', {\n      column: column,\n      error: error,\n      line: line,\n      msg: msg,\n      url: url\n    });\n    if (_oldOnErrorHandler && !_oldOnErrorHandler.__SENTRY_LOADER__) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnErrorHandler.apply(this, arguments);\n    }\n    return false;\n  };\n  WINDOW.onerror.__SENTRY_INSTRUMENTED__ = true;\n}\nvar _oldOnUnhandledRejectionHandler = null;\n/** JSDoc */\nfunction instrumentUnhandledRejection() {\n  _oldOnUnhandledRejectionHandler = WINDOW.onunhandledrejection;\n  WINDOW.onunhandledrejection = function (e) {\n    triggerHandlers('unhandledrejection', e);\n    if (_oldOnUnhandledRejectionHandler && !_oldOnUnhandledRejectionHandler.__SENTRY_LOADER__) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n    }\n    return true;\n  };\n  WINDOW.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;\n}\nexport { SENTRY_XHR_DATA_KEY, addInstrumentationHandler, parseFetchArgs };","map":{"version":3,"names":["WINDOW","getGlobalObject","SENTRY_XHR_DATA_KEY","handlers","instrumented","instrument","type","instrumentConsole","instrumentDOM","instrumentXHR","instrumentFetch","instrumentHistory","instrumentError","instrumentUnhandledRejection","__SENTRY_DEBUG__","logger","warn","addInstrumentationHandler","callback","push","triggerHandlers","data","_iterator","_createForOfIteratorHelper","_step","s","n","done","handler","value","e","error","concat","getFunctionName","err","f","CONSOLE_LEVELS","forEach","level","console","fill","originalConsoleMethod","_len","arguments","length","args","Array","_key","apply","supportsNativeFetch","originalFetch","_len2","_key2","_parseFetchArgs","parseFetchArgs","method","url","handlerData","fetchData","startTimestamp","Date","now","_objectSpread","then","response","endTimestamp","hasProp","obj","prop","getUrlFromResource","resource","toString","fetchArgs","_fetchArgs","_slicedToArray","options","String","toUpperCase","arg","xhrproto","XMLHttpRequest","prototype","originalOpen","_this","_len3","_key3","xhrInfo","isString","request_headers","match","__sentry_own_request__","onreadystatechangeHandler","readyState","status_code","status","xhr","onreadystatechange","original","_len4","readyStateArgs","_key4","addEventListener","_len5","setRequestHeaderArgs","_key5","header","toLowerCase","originalSend","sentryXhrData","_len6","_key6","undefined","body","lastHref","supportsHistory","oldOnPopState","onpopstate","to","location","href","from","_len7","_key7","_oO","historyReplacementFunction","originalHistoryFunction","_len8","_key8","history","debounceDuration","debounceTimerID","lastCapturedEvent","shouldShortcircuitPreviousDebounce","previous","current","target","shouldSkipDOMEvent","event","tagName","isContentEditable","makeDOMEventHandler","globalListener","name","global","clearTimeout","setTimeout","triggerDOMHandler","bind","globalDOMEventHandler","document","proto","hasOwnProperty","originalAddEventListener","listener","el","__sentry_instrumentation_handlers__","handlerForType","refCount","call","originalRemoveEventListener","Object","keys","_oldOnErrorHandler","onerror","msg","line","column","__SENTRY_LOADER__","__SENTRY_INSTRUMENTED__","_oldOnUnhandledRejectionHandler","onunhandledrejection"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/instrument.ts"],"sourcesContent":["/* eslint-disable max-lines */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\nimport type {\n  HandlerDataFetch,\n  HandlerDataXhr,\n  SentryWrappedXMLHttpRequest,\n  SentryXhrData,\n  WrappedFunction,\n} from '@sentry/types';\n\nimport { isString } from './is';\nimport { CONSOLE_LEVELS, logger } from './logger';\nimport { fill } from './object';\nimport { getFunctionName } from './stacktrace';\nimport { supportsHistory, supportsNativeFetch } from './supports';\nimport { getGlobalObject } from './worldwide';\n\n// eslint-disable-next-line deprecation/deprecation\nconst WINDOW = getGlobalObject<Window>();\n\nexport const SENTRY_XHR_DATA_KEY = '__sentry_xhr_v2__';\n\nexport type InstrumentHandlerType =\n  | 'console'\n  | 'dom'\n  | 'fetch'\n  | 'history'\n  | 'sentry'\n  | 'xhr'\n  | 'error'\n  | 'unhandledrejection';\nexport type InstrumentHandlerCallback = (data: any) => void;\n\n/**\n * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.\n *  - Console API\n *  - Fetch API\n *  - XHR API\n *  - History API\n *  - DOM API (click/typing)\n *  - Error API\n *  - UnhandledRejection API\n */\n\nconst handlers: { [key in InstrumentHandlerType]?: InstrumentHandlerCallback[] } = {};\nconst instrumented: { [key in InstrumentHandlerType]?: boolean } = {};\n\n/** Instruments given API */\nfunction instrument(type: InstrumentHandlerType): void {\n  if (instrumented[type]) {\n    return;\n  }\n\n  instrumented[type] = true;\n\n  switch (type) {\n    case 'console':\n      instrumentConsole();\n      break;\n    case 'dom':\n      instrumentDOM();\n      break;\n    case 'xhr':\n      instrumentXHR();\n      break;\n    case 'fetch':\n      instrumentFetch();\n      break;\n    case 'history':\n      instrumentHistory();\n      break;\n    case 'error':\n      instrumentError();\n      break;\n    case 'unhandledrejection':\n      instrumentUnhandledRejection();\n      break;\n    default:\n      __DEBUG_BUILD__ && logger.warn('unknown instrumentation type:', type);\n      return;\n  }\n}\n\n/**\n * Add handler that will be called when given type of instrumentation triggers.\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addInstrumentationHandler(type: InstrumentHandlerType, callback: InstrumentHandlerCallback): void {\n  handlers[type] = handlers[type] || [];\n  (handlers[type] as InstrumentHandlerCallback[]).push(callback);\n  instrument(type);\n}\n\n/** JSDoc */\nfunction triggerHandlers(type: InstrumentHandlerType, data: any): void {\n  if (!type || !handlers[type]) {\n    return;\n  }\n\n  for (const handler of handlers[type] || []) {\n    try {\n      handler(data);\n    } catch (e) {\n      __DEBUG_BUILD__ &&\n        logger.error(\n          `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`,\n          e,\n        );\n    }\n  }\n}\n\n/** JSDoc */\nfunction instrumentConsole(): void {\n  if (!('console' in WINDOW)) {\n    return;\n  }\n\n  CONSOLE_LEVELS.forEach(function (level: string): void {\n    if (!(level in WINDOW.console)) {\n      return;\n    }\n\n    fill(WINDOW.console, level, function (originalConsoleMethod: () => any): Function {\n      return function (...args: any[]): void {\n        triggerHandlers('console', { args, level });\n\n        // this fails for some browsers. :(\n        if (originalConsoleMethod) {\n          originalConsoleMethod.apply(WINDOW.console, args);\n        }\n      };\n    });\n  });\n}\n\n/** JSDoc */\nfunction instrumentFetch(): void {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n\n  fill(WINDOW, 'fetch', function (originalFetch: () => void): () => void {\n    return function (...args: any[]): void {\n      const { method, url } = parseFetchArgs(args);\n\n      const handlerData: HandlerDataFetch = {\n        args,\n        fetchData: {\n          method,\n          url,\n        },\n        startTimestamp: Date.now(),\n      };\n\n      triggerHandlers('fetch', {\n        ...handlerData,\n      });\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalFetch.apply(WINDOW, args).then(\n        (response: Response) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            response,\n          });\n          return response;\n        },\n        (error: Error) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            error,\n          });\n          // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n          //       it means the sentry.javascript SDK caught an error invoking your application code.\n          //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n          throw error;\n        },\n      );\n    };\n  });\n}\n\nfunction hasProp<T extends string>(obj: unknown, prop: T): obj is Record<string, string> {\n  return !!obj && typeof obj === 'object' && !!(obj as Record<string, string>)[prop];\n}\n\ntype FetchResource = string | { toString(): string } | { url: string };\n\nfunction getUrlFromResource(resource: FetchResource): string {\n  if (typeof resource === 'string') {\n    return resource;\n  }\n\n  if (!resource) {\n    return '';\n  }\n\n  if (hasProp(resource, 'url')) {\n    return resource.url;\n  }\n\n  if (resource.toString) {\n    return resource.toString();\n  }\n\n  return '';\n}\n\n/**\n * Parses the fetch arguments to find the used Http method and the url of the request\n */\nexport function parseFetchArgs(fetchArgs: unknown[]): { method: string; url: string } {\n  if (fetchArgs.length === 0) {\n    return { method: 'GET', url: '' };\n  }\n\n  if (fetchArgs.length === 2) {\n    const [url, options] = fetchArgs as [FetchResource, object];\n\n    return {\n      url: getUrlFromResource(url),\n      method: hasProp(options, 'method') ? String(options.method).toUpperCase() : 'GET',\n    };\n  }\n\n  const arg = fetchArgs[0];\n  return {\n    url: getUrlFromResource(arg as FetchResource),\n    method: hasProp(arg, 'method') ? String(arg.method).toUpperCase() : 'GET',\n  };\n}\n\n/** JSDoc */\nfunction instrumentXHR(): void {\n  if (!('XMLHttpRequest' in WINDOW)) {\n    return;\n  }\n\n  const xhrproto = XMLHttpRequest.prototype;\n\n  fill(xhrproto, 'open', function (originalOpen: () => void): () => void {\n    return function (this: XMLHttpRequest & SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      const url = args[1];\n      const xhrInfo: SentryXhrData = (this[SENTRY_XHR_DATA_KEY] = {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        method: isString(args[0]) ? args[0].toUpperCase() : args[0],\n        url: args[1],\n        request_headers: {},\n      });\n\n      // if Sentry key appears in URL, don't capture it as a request\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (isString(url) && xhrInfo.method === 'POST' && url.match(/sentry_key/)) {\n        this.__sentry_own_request__ = true;\n      }\n\n      const onreadystatechangeHandler: () => void = () => {\n        // For whatever reason, this is not the same instance here as from the outer method\n        const xhrInfo = this[SENTRY_XHR_DATA_KEY];\n\n        if (!xhrInfo) {\n          return;\n        }\n\n        if (this.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = this.status;\n          } catch (e) {\n            /* do nothing */\n          }\n\n          triggerHandlers('xhr', {\n            args: args as [string, string],\n            endTimestamp: Date.now(),\n            startTimestamp: Date.now(),\n            xhr: this,\n          } as HandlerDataXhr);\n        }\n      };\n\n      if ('onreadystatechange' in this && typeof this.onreadystatechange === 'function') {\n        fill(this, 'onreadystatechange', function (original: WrappedFunction): Function {\n          return function (this: SentryWrappedXMLHttpRequest, ...readyStateArgs: any[]): void {\n            onreadystatechangeHandler();\n            return original.apply(this, readyStateArgs);\n          };\n        });\n      } else {\n        this.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      // Intercepting `setRequestHeader` to access the request headers of XHR instance.\n      // This will only work for user/library defined headers, not for the default/browser-assigned headers.\n      // Request cookies are also unavailable for XHR, as `Cookie` header can't be defined by `setRequestHeader`.\n      fill(this, 'setRequestHeader', function (original: WrappedFunction): Function {\n        return function (this: SentryWrappedXMLHttpRequest, ...setRequestHeaderArgs: unknown[]): void {\n          const [header, value] = setRequestHeaderArgs as [string, string];\n\n          const xhrInfo = this[SENTRY_XHR_DATA_KEY];\n\n          if (xhrInfo) {\n            xhrInfo.request_headers[header.toLowerCase()] = value;\n          }\n\n          return original.apply(this, setRequestHeaderArgs);\n        };\n      });\n\n      return originalOpen.apply(this, args);\n    };\n  });\n\n  fill(xhrproto, 'send', function (originalSend: () => void): () => void {\n    return function (this: XMLHttpRequest & SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      const sentryXhrData = this[SENTRY_XHR_DATA_KEY];\n      if (sentryXhrData && args[0] !== undefined) {\n        sentryXhrData.body = args[0];\n      }\n\n      triggerHandlers('xhr', {\n        args,\n        startTimestamp: Date.now(),\n        xhr: this,\n      });\n\n      return originalSend.apply(this, args);\n    };\n  });\n}\n\nlet lastHref: string;\n\n/** JSDoc */\nfunction instrumentHistory(): void {\n  if (!supportsHistory()) {\n    return;\n  }\n\n  const oldOnPopState = WINDOW.onpopstate;\n  WINDOW.onpopstate = function (this: WindowEventHandlers, ...args: any[]): any {\n    const to = WINDOW.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n    triggerHandlers('history', {\n      from,\n      to,\n    });\n    if (oldOnPopState) {\n      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.\n      // https://github.com/getsentry/sentry-javascript/issues/3344\n      // https://github.com/bugsnag/bugsnag-js/issues/469\n      try {\n        return oldOnPopState.apply(this, args);\n      } catch (_oO) {\n        // no-empty\n      }\n    }\n  };\n\n  /** @hidden */\n  function historyReplacementFunction(originalHistoryFunction: () => void): () => void {\n    return function (this: History, ...args: any[]): void {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        triggerHandlers('history', {\n          from,\n          to,\n        });\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(WINDOW.history, 'pushState', historyReplacementFunction);\n  fill(WINDOW.history, 'replaceState', historyReplacementFunction);\n}\n\nconst debounceDuration = 1000;\nlet debounceTimerID: number | undefined;\nlet lastCapturedEvent: Event | undefined;\n\n/**\n * Decide whether the current event should finish the debounce of previously captured one.\n * @param previous previously captured event\n * @param current event to be captured\n */\nfunction shouldShortcircuitPreviousDebounce(previous: Event | undefined, current: Event): boolean {\n  // If there was no previous event, it should always be swapped for the new one.\n  if (!previous) {\n    return true;\n  }\n\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (previous.type !== current.type) {\n    return true;\n  }\n\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (previous.target !== current.target) {\n      return true;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return false;\n}\n\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(event: Event): boolean {\n  // We are only interested in filtering `keypress` events for now.\n  if (event.type !== 'keypress') {\n    return false;\n  }\n\n  try {\n    const target = event.target as HTMLElement;\n\n    if (!target || !target.tagName) {\n      return true;\n    }\n\n    // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n    // e.g.tabbing through elements, hotkeys, etc.\n    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n      return false;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  return true;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param handler function that will be triggered\n * @param globalListener indicates whether event was captured by the global event listener\n * @returns wrapped breadcrumb events handler\n * @hidden\n */\nfunction makeDOMEventHandler(handler: Function, globalListener: boolean = false): (event: Event) => void {\n  return (event: Event): void => {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || lastCapturedEvent === event) {\n      return;\n    }\n\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event)) {\n      return;\n    }\n\n    const name = event.type === 'keypress' ? 'input' : event.type;\n\n    // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.\n    if (debounceTimerID === undefined) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n    // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = WINDOW.setTimeout(() => {\n      debounceTimerID = undefined;\n    }, debounceDuration);\n  };\n}\n\ntype AddEventListener = (\n  type: string,\n  listener: EventListenerOrEventListenerObject,\n  options?: boolean | AddEventListenerOptions,\n) => void;\ntype RemoveEventListener = (\n  type: string,\n  listener: EventListenerOrEventListenerObject,\n  options?: boolean | EventListenerOptions,\n) => void;\n\ntype InstrumentedElement = Element & {\n  __sentry_instrumentation_handlers__?: {\n    [key in 'click' | 'keypress']?: {\n      handler?: Function;\n      /** The number of custom listeners attached to this element */\n      refCount: number;\n    };\n  };\n};\n\n/** JSDoc */\nfunction instrumentDOM(): void {\n  if (!('document' in WINDOW)) {\n    return;\n  }\n\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  const triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  WINDOW.document.addEventListener('click', globalDOMEventHandler, false);\n  WINDOW.document.addEventListener('keypress', globalDOMEventHandler, false);\n\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach((target: string) => {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const proto = (WINDOW as any)[target] && (WINDOW as any)[target].prototype;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n\n    fill(proto, 'addEventListener', function (originalAddEventListener: AddEventListener): AddEventListener {\n      return function (\n        this: Element,\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: boolean | AddEventListenerOptions,\n      ): AddEventListener {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            const el = this as InstrumentedElement;\n            const handlers = (el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {});\n            const handlerForType = (handlers[type] = handlers[type] || { refCount: 0 });\n\n            if (!handlerForType.handler) {\n              const handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n\n            handlerForType.refCount++;\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n\n    fill(\n      proto,\n      'removeEventListener',\n      function (originalRemoveEventListener: RemoveEventListener): RemoveEventListener {\n        return function (\n          this: Element,\n          type: string,\n          listener: EventListenerOrEventListenerObject,\n          options?: boolean | EventListenerOptions,\n        ): () => void {\n          if (type === 'click' || type == 'keypress') {\n            try {\n              const el = this as InstrumentedElement;\n              const handlers = el.__sentry_instrumentation_handlers__ || {};\n              const handlerForType = handlers[type];\n\n              if (handlerForType) {\n                handlerForType.refCount--;\n                // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n                if (handlerForType.refCount <= 0) {\n                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                  handlerForType.handler = undefined;\n                  delete handlers[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n                }\n\n                // If there are no longer any custom handlers of any type on this element, cleanup everything.\n                if (Object.keys(handlers).length === 0) {\n                  delete el.__sentry_instrumentation_handlers__;\n                }\n              }\n            } catch (e) {\n              // Accessing dom properties is always fragile.\n              // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n            }\n          }\n\n          return originalRemoveEventListener.call(this, type, listener, options);\n        };\n      },\n    );\n  });\n}\n\nlet _oldOnErrorHandler: (typeof WINDOW)['onerror'] | null = null;\n/** JSDoc */\nfunction instrumentError(): void {\n  _oldOnErrorHandler = WINDOW.onerror;\n\n  WINDOW.onerror = function (msg: unknown, url: unknown, line: unknown, column: unknown, error: unknown): boolean {\n    triggerHandlers('error', {\n      column,\n      error,\n      line,\n      msg,\n      url,\n    });\n\n    if (_oldOnErrorHandler && !_oldOnErrorHandler.__SENTRY_LOADER__) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnErrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  };\n\n  WINDOW.onerror.__SENTRY_INSTRUMENTED__ = true;\n}\n\nlet _oldOnUnhandledRejectionHandler: (typeof WINDOW)['onunhandledrejection'] | null = null;\n/** JSDoc */\nfunction instrumentUnhandledRejection(): void {\n  _oldOnUnhandledRejectionHandler = WINDOW.onunhandledrejection;\n\n  WINDOW.onunhandledrejection = function (e: any): boolean {\n    triggerHandlers('unhandledrejection', e);\n\n    if (_oldOnUnhandledRejectionHandler && !_oldOnUnhandledRejectionHandler.__SENTRY_LOADER__) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n    }\n\n    return true;\n  };\n\n  WINDOW.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}