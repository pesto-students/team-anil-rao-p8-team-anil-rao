{"ast":null,"code":"import _regeneratorRuntime from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * Polyfill for the optional chain operator, `?.`, given previous conversion of the expression into an array of values,\n * descriptors, and functions, for situations in which at least one part of the expression is async.\n *\n * Adapted from Sucrase (https://github.com/alangpierce/sucrase) See\n * https://github.com/alangpierce/sucrase/blob/265887868966917f3b924ce38dfad01fbab1329f/src/transformers/OptionalChainingNullishTransformer.ts#L15\n *\n * @param ops Array result of expression conversion\n * @returns The value of the expression\n */\nfunction _asyncOptionalChain(_x) {\n  return _asyncOptionalChain2.apply(this, arguments);\n} // Sucrase version:\n// async function _asyncOptionalChain(ops) {\n//   let lastAccessLHS = undefined;\n//   let value = ops[0];\n//   let i = 1;\n//   while (i < ops.length) {\n//     const op = ops[i];\n//     const fn = ops[i + 1];\n//     i += 2;\n//     if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n//       return undefined;\n//     }\n//     if (op === 'access' || op === 'optionalAccess') {\n//       lastAccessLHS = value;\n//       value = await fn(value);\n//     } else if (op === 'call' || op === 'optionalCall') {\n//       value = await fn((...args) => value.call(lastAccessLHS, ...args));\n//       lastAccessLHS = undefined;\n//     }\n//   }\n//   return value;\n// }\nfunction _asyncOptionalChain2() {\n  _asyncOptionalChain2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(ops) {\n    var lastAccessLHS, value, i, op, fn;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          lastAccessLHS = undefined;\n          value = ops[0];\n          i = 1;\n        case 3:\n          if (!(i < ops.length)) {\n            _context.next = 23;\n            break;\n          }\n          op = ops[i];\n          fn = ops[i + 1];\n          i += 2;\n          // by checking for loose equality to `null`, we catch both `null` and `undefined`\n          if (!((op === 'optionalAccess' || op === 'optionalCall') && value == null)) {\n            _context.next = 9;\n            break;\n          }\n          return _context.abrupt(\"return\");\n        case 9:\n          if (!(op === 'access' || op === 'optionalAccess')) {\n            _context.next = 16;\n            break;\n          }\n          lastAccessLHS = value;\n          _context.next = 13;\n          return fn(value);\n        case 13:\n          value = _context.sent;\n          _context.next = 21;\n          break;\n        case 16:\n          if (!(op === 'call' || op === 'optionalCall')) {\n            _context.next = 21;\n            break;\n          }\n          _context.next = 19;\n          return fn(function () {\n            var _value;\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n            return (_value = value).call.apply(_value, [lastAccessLHS].concat(args));\n          });\n        case 19:\n          value = _context.sent;\n          lastAccessLHS = undefined;\n        case 21:\n          _context.next = 3;\n          break;\n        case 23:\n          return _context.abrupt(\"return\", value);\n        case 24:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _asyncOptionalChain2.apply(this, arguments);\n}\nexport { _asyncOptionalChain };","map":{"version":3,"names":["_asyncOptionalChain","_x","_asyncOptionalChain2","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","ops","lastAccessLHS","value","i","op","fn","wrap","_callee$","_context","prev","next","undefined","length","abrupt","sent","_value","_len","args","Array","_key","call","concat","stop"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/buildPolyfills/_asyncOptionalChain.ts"],"sourcesContent":["// https://github.com/alangpierce/sucrase/tree/265887868966917f3b924ce38dfad01fbab1329f\n//\n// The MIT License (MIT)\n//\n// Copyright (c) 2012-2018 various contributors (see AUTHORS)\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nimport type { GenericFunction } from './types';\n\n/**\n * Polyfill for the optional chain operator, `?.`, given previous conversion of the expression into an array of values,\n * descriptors, and functions, for situations in which at least one part of the expression is async.\n *\n * Adapted from Sucrase (https://github.com/alangpierce/sucrase) See\n * https://github.com/alangpierce/sucrase/blob/265887868966917f3b924ce38dfad01fbab1329f/src/transformers/OptionalChainingNullishTransformer.ts#L15\n *\n * @param ops Array result of expression conversion\n * @returns The value of the expression\n */\nexport async function _asyncOptionalChain(ops: unknown[]): Promise<unknown> {\n  let lastAccessLHS: unknown = undefined;\n  let value = ops[0];\n  let i = 1;\n  while (i < ops.length) {\n    const op = ops[i] as string;\n    const fn = ops[i + 1] as (intermediateValue: unknown) => Promise<unknown>;\n    i += 2;\n    // by checking for loose equality to `null`, we catch both `null` and `undefined`\n    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n      // really we're meaning to return `undefined` as an actual value here, but it saves bytes not to write it\n      return;\n    }\n    if (op === 'access' || op === 'optionalAccess') {\n      lastAccessLHS = value;\n      value = await fn(value);\n    } else if (op === 'call' || op === 'optionalCall') {\n      value = await fn((...args: unknown[]) => (value as GenericFunction).call(lastAccessLHS, ...args));\n      lastAccessLHS = undefined;\n    }\n  }\n  return value;\n}\n\n// Sucrase version:\n// async function _asyncOptionalChain(ops) {\n//   let lastAccessLHS = undefined;\n//   let value = ops[0];\n//   let i = 1;\n//   while (i < ops.length) {\n//     const op = ops[i];\n//     const fn = ops[i + 1];\n//     i += 2;\n//     if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n//       return undefined;\n//     }\n//     if (op === 'access' || op === 'optionalAccess') {\n//       lastAccessLHS = value;\n//       value = await fn(value);\n//     } else if (op === 'call' || op === 'optionalCall') {\n//       value = await fn((...args) => value.call(lastAccessLHS, ...args));\n//       lastAccessLHS = undefined;\n//     }\n//   }\n//   return value;\n// }\n"],"mappings":";;AA0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA,SAUAA,oBAAAC,EAAA;EAAA,OAAAC,oBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA,EAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA,SAAAF,qBAAA;EAAAA,oBAAA,GAAAG,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CA7CA,SAAAC,QAAAC,GAAA;IAAA,IAAAC,aAAA,EAAAC,KAAA,EAAAC,CAAA,EAAAC,EAAA,EAAAC,EAAA;IAAA,OAAAR,mBAAA,GAAAS,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UACAT,aAAA,GAAAU,SAAA;UACAT,KAAA,GAAAF,GAAA;UACAG,CAAA;QAAA;UAAA,MACAA,CAAA,GAAAH,GAAA,CAAAY,MAAA;YAAAJ,QAAA,CAAAE,IAAA;YAAA;UAAA;UACAN,EAAA,GAAAJ,GAAA,CAAAG,CAAA;UACAE,EAAA,GAAAL,GAAA,CAAAG,CAAA;UACAA,CAAA;UACA;UAAA,MACA,CAAAC,EAAA,yBAAAA,EAAA,wBAAAF,KAAA;YAAAM,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,OAAAF,QAAA,CAAAK,MAAA;QAAA;UAAA,MAIAT,EAAA,iBAAAA,EAAA;YAAAI,QAAA,CAAAE,IAAA;YAAA;UAAA;UACAT,aAAA,GAAAC,KAAA;UAAAM,QAAA,CAAAE,IAAA;UAAA,OACAL,EAAA,CAAAH,KAAA;QAAA;UAAAA,KAAA,GAAAM,QAAA,CAAAM,IAAA;UAAAN,QAAA,CAAAE,IAAA;UAAA;QAAA;UAAA,MACAN,EAAA,eAAAA,EAAA;YAAAI,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAAF,QAAA,CAAAE,IAAA;UAAA,OACAL,EAAA;YAAA,IAAAU,MAAA;YAAA,SAAAC,IAAA,GAAArB,SAAA,CAAAiB,MAAA,EAAAK,IAAA,OAAAC,KAAA,CAAAF,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;cAAAF,IAAA,CAAAE,IAAA,IAAAxB,SAAA,CAAAwB,IAAA;YAAA;YAAA,QAAAJ,MAAA,GAAAb,KAAA,EAAAkB,IAAA,CAAA1B,KAAA,CAAAqB,MAAA,GAAAd,aAAA,EAAAoB,MAAA,CAAAJ,IAAA;UAAA;QAAA;UAAAf,KAAA,GAAAM,QAAA,CAAAM,IAAA;UACAb,aAAA,GAAAU,SAAA;QAAA;UAAAH,QAAA,CAAAE,IAAA;UAAA;QAAA;UAAA,OAAAF,QAAA,CAAAK,MAAA,WAGAX,KAAA;QAAA;QAAA;UAAA,OAAAM,QAAA,CAAAc,IAAA;MAAA;IAAA,GAAAvB,OAAA;EAAA,CACA;EAAA,OAAAN,oBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}