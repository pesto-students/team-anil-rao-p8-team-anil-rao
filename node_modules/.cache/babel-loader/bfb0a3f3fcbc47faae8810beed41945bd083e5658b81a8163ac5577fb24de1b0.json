{"ast":null,"code":"import _slicedToArray from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { arrayify, logger } from '@sentry/utils';\nimport { getCurrentHub } from './hub.js';\nimport { addGlobalEventProcessor } from './scope.js';\nvar installedIntegrations = [];\n\n/** Map of integrations assigned to a client */\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preseve the order of integrations in the array.\n *\n * @private\n */\nfunction filterDuplicates(integrations) {\n  var integrationsByName = {};\n  integrations.forEach(function (currentInstance) {\n    var name = currentInstance.name;\n    var existingInstance = integrationsByName[name];\n\n    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n    integrationsByName[name] = currentInstance;\n  });\n  return Object.keys(integrationsByName).map(function (k) {\n    return integrationsByName[k];\n  });\n}\n\n/** Gets integrations to install */\nfunction getIntegrationsToSetup(options) {\n  var defaultIntegrations = options.defaultIntegrations || [];\n  var userIntegrations = options.integrations;\n\n  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n  defaultIntegrations.forEach(function (integration) {\n    integration.isDefaultInstance = true;\n  });\n  var integrations;\n  if (Array.isArray(userIntegrations)) {\n    integrations = [].concat(_toConsumableArray(defaultIntegrations), _toConsumableArray(userIntegrations));\n  } else if (typeof userIntegrations === 'function') {\n    integrations = arrayify(userIntegrations(defaultIntegrations));\n  } else {\n    integrations = defaultIntegrations;\n  }\n  var finalIntegrations = filterDuplicates(integrations);\n\n  // The `Debug` integration prints copies of the `event` and `hint` which will be passed to `beforeSend` or\n  // `beforeSendTransaction`. It therefore has to run after all other integrations, so that the changes of all event\n  // processors will be reflected in the printed values. For lack of a more elegant way to guarantee that, we therefore\n  // locate it and, assuming it exists, pop it out of its current spot and shove it onto the end of the array.\n  var debugIndex = findIndex(finalIntegrations, function (integration) {\n    return integration.name === 'Debug';\n  });\n  if (debugIndex !== -1) {\n    var _finalIntegrations$sp = finalIntegrations.splice(debugIndex, 1),\n      _finalIntegrations$sp2 = _slicedToArray(_finalIntegrations$sp, 1),\n      debugInstance = _finalIntegrations$sp2[0];\n    finalIntegrations.push(debugInstance);\n  }\n  return finalIntegrations;\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nfunction setupIntegrations(integrations) {\n  var integrationIndex = {};\n  integrations.forEach(function (integration) {\n    // guard against empty provided integrations\n    if (integration) {\n      setupIntegration(integration, integrationIndex);\n    }\n  });\n  return integrationIndex;\n}\n\n/** Setup a single integration.  */\nfunction setupIntegration(integration, integrationIndex) {\n  integrationIndex[integration.name] = integration;\n  if (installedIntegrations.indexOf(integration.name) === -1) {\n    integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n    installedIntegrations.push(integration.name);\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(\"Integration installed: \".concat(integration.name));\n  }\n}\n\n// Polyfill for Array.findIndex(), which is not supported in ES5\nfunction findIndex(arr, callback) {\n  for (var i = 0; i < arr.length; i++) {\n    if (callback(arr[i]) === true) {\n      return i;\n    }\n  }\n  return -1;\n}\nexport { getIntegrationsToSetup, installedIntegrations, setupIntegration, setupIntegrations };","map":{"version":3,"names":["installedIntegrations","filterDuplicates","integrations","integrationsByName","forEach","currentInstance","name","existingInstance","isDefaultInstance","Object","keys","map","k","getIntegrationsToSetup","options","defaultIntegrations","userIntegrations","integration","Array","isArray","concat","_toConsumableArray","arrayify","finalIntegrations","debugIndex","findIndex","_finalIntegrations$sp","splice","_finalIntegrations$sp2","_slicedToArray","debugInstance","push","setupIntegrations","integrationIndex","setupIntegration","indexOf","setupOnce","addGlobalEventProcessor","getCurrentHub","__SENTRY_DEBUG__","logger","log","arr","callback","i","length"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/integration.ts"],"sourcesContent":["import type { Integration, Options } from '@sentry/types';\nimport { arrayify, logger } from '@sentry/utils';\n\nimport { getCurrentHub } from './hub';\nimport { addGlobalEventProcessor } from './scope';\n\ndeclare module '@sentry/types' {\n  interface Integration {\n    isDefaultInstance?: boolean;\n  }\n}\n\nexport const installedIntegrations: string[] = [];\n\n/** Map of integrations assigned to a client */\nexport type IntegrationIndex = {\n  [key: string]: Integration;\n};\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preseve the order of integrations in the array.\n *\n * @private\n */\nfunction filterDuplicates(integrations: Integration[]): Integration[] {\n  const integrationsByName: { [key: string]: Integration } = {};\n\n  integrations.forEach(currentInstance => {\n    const { name } = currentInstance;\n\n    const existingInstance = integrationsByName[name];\n\n    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n\n    integrationsByName[name] = currentInstance;\n  });\n\n  return Object.keys(integrationsByName).map(k => integrationsByName[k]);\n}\n\n/** Gets integrations to install */\nexport function getIntegrationsToSetup(options: Options): Integration[] {\n  const defaultIntegrations = options.defaultIntegrations || [];\n  const userIntegrations = options.integrations;\n\n  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n  defaultIntegrations.forEach(integration => {\n    integration.isDefaultInstance = true;\n  });\n\n  let integrations: Integration[];\n\n  if (Array.isArray(userIntegrations)) {\n    integrations = [...defaultIntegrations, ...userIntegrations];\n  } else if (typeof userIntegrations === 'function') {\n    integrations = arrayify(userIntegrations(defaultIntegrations));\n  } else {\n    integrations = defaultIntegrations;\n  }\n\n  const finalIntegrations = filterDuplicates(integrations);\n\n  // The `Debug` integration prints copies of the `event` and `hint` which will be passed to `beforeSend` or\n  // `beforeSendTransaction`. It therefore has to run after all other integrations, so that the changes of all event\n  // processors will be reflected in the printed values. For lack of a more elegant way to guarantee that, we therefore\n  // locate it and, assuming it exists, pop it out of its current spot and shove it onto the end of the array.\n  const debugIndex = findIndex(finalIntegrations, integration => integration.name === 'Debug');\n  if (debugIndex !== -1) {\n    const [debugInstance] = finalIntegrations.splice(debugIndex, 1);\n    finalIntegrations.push(debugInstance);\n  }\n\n  return finalIntegrations;\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nexport function setupIntegrations(integrations: Integration[]): IntegrationIndex {\n  const integrationIndex: IntegrationIndex = {};\n\n  integrations.forEach(integration => {\n    // guard against empty provided integrations\n    if (integration) {\n      setupIntegration(integration, integrationIndex);\n    }\n  });\n\n  return integrationIndex;\n}\n\n/** Setup a single integration.  */\nexport function setupIntegration(integration: Integration, integrationIndex: IntegrationIndex): void {\n  integrationIndex[integration.name] = integration;\n\n  if (installedIntegrations.indexOf(integration.name) === -1) {\n    integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n    installedIntegrations.push(integration.name);\n    __DEBUG_BUILD__ && logger.log(`Integration installed: ${integration.name}`);\n  }\n}\n\n// Polyfill for Array.findIndex(), which is not supported in ES5\nfunction findIndex<T>(arr: T[], callback: (item: T) => boolean): number {\n  for (let i = 0; i < arr.length; i++) {\n    if (callback(arr[i]) === true) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n"],"mappings":";;;;;AAYA,IAAAA,qBAAA;;AAEA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA,SAAAC,iBAAAC,YAAA;EACA,IAAAC,kBAAA;EAEAD,YAAA,CAAAE,OAAA,WAAAC,eAAA;IACA,IAAAC,IAAA,GAAAD,eAAA,CAAAC,IAAA;IAEA,IAAAC,gBAAA,GAAAJ,kBAAA,CAAAG,IAAA;;IAEA;IACA;IACA,IAAAC,gBAAA,KAAAA,gBAAA,CAAAC,iBAAA,IAAAH,eAAA,CAAAG,iBAAA;MACA;IACA;IAEAL,kBAAA,CAAAG,IAAA,IAAAD,eAAA;EACA;EAEA,OAAAI,MAAA,CAAAC,IAAA,CAAAP,kBAAA,EAAAQ,GAAA,WAAAC,CAAA;IAAA,OAAAT,kBAAA,CAAAS,CAAA;EAAA;AACA;;AAEA;AACA,SAAAC,uBAAAC,OAAA;EACA,IAAAC,mBAAA,GAAAD,OAAA,CAAAC,mBAAA;EACA,IAAAC,gBAAA,GAAAF,OAAA,CAAAZ,YAAA;;EAEA;EACAa,mBAAA,CAAAX,OAAA,WAAAa,WAAA;IACAA,WAAA,CAAAT,iBAAA;EACA;EAEA,IAAAN,YAAA;EAEA,IAAAgB,KAAA,CAAAC,OAAA,CAAAH,gBAAA;IACAd,YAAA,MAAAkB,MAAA,CAAAC,kBAAA,CAAAN,mBAAA,GAAAM,kBAAA,CAAAL,gBAAA;EACA,kBAAAA,gBAAA;IACAd,YAAA,GAAAoB,QAAA,CAAAN,gBAAA,CAAAD,mBAAA;EACA;IACAb,YAAA,GAAAa,mBAAA;EACA;EAEA,IAAAQ,iBAAA,GAAAtB,gBAAA,CAAAC,YAAA;;EAEA;EACA;EACA;EACA;EACA,IAAAsB,UAAA,GAAAC,SAAA,CAAAF,iBAAA,YAAAN,WAAA;IAAA,OAAAA,WAAA,CAAAX,IAAA;EAAA;EACA,IAAAkB,UAAA;IACA,IAAAE,qBAAA,GAAAH,iBAAA,CAAAI,MAAA,CAAAH,UAAA;MAAAI,sBAAA,GAAAC,cAAA,CAAAH,qBAAA;MAAAI,aAAA,GAAAF,sBAAA;IACAL,iBAAA,CAAAQ,IAAA,CAAAD,aAAA;EACA;EAEA,OAAAP,iBAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAAS,kBAAA9B,YAAA;EACA,IAAA+B,gBAAA;EAEA/B,YAAA,CAAAE,OAAA,WAAAa,WAAA;IACA;IACA,IAAAA,WAAA;MACAiB,gBAAA,CAAAjB,WAAA,EAAAgB,gBAAA;IACA;EACA;EAEA,OAAAA,gBAAA;AACA;;AAEA;AACA,SAAAC,iBAAAjB,WAAA,EAAAgB,gBAAA;EACAA,gBAAA,CAAAhB,WAAA,CAAAX,IAAA,IAAAW,WAAA;EAEA,IAAAjB,qBAAA,CAAAmC,OAAA,CAAAlB,WAAA,CAAAX,IAAA;IACAW,WAAA,CAAAmB,SAAA,CAAAC,uBAAA,EAAAC,aAAA;IACAtC,qBAAA,CAAA+B,IAAA,CAAAd,WAAA,CAAAX,IAAA;IACA,QAAAiC,gBAAA,oBAAAA,gBAAA,KAAAC,MAAA,CAAAC,GAAA,2BAAArB,MAAA,CAAAH,WAAA,CAAAX,IAAA;EACA;AACA;;AAEA;AACA,SAAAmB,UAAAiB,GAAA,EAAAC,QAAA;EACA,SAAAC,CAAA,MAAAA,CAAA,GAAAF,GAAA,CAAAG,MAAA,EAAAD,CAAA;IACA,IAAAD,QAAA,CAAAD,GAAA,CAAAE,CAAA;MACA,OAAAA,CAAA;IACA;EACA;EAEA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}