{"ast":null,"code":"import _slicedToArray from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { createStackParser } from '@sentry/utils';\n\n// global reference to slice\nvar UNKNOWN_FUNCTION = '?';\nvar OPERA10_PRIORITY = 10;\nvar OPERA11_PRIORITY = 20;\nvar CHROME_PRIORITY = 30;\nvar WINJS_PRIORITY = 40;\nvar GECKO_PRIORITY = 50;\nfunction createFrame(filename, func, lineno, colno) {\n  var frame = {\n    filename: filename,\n    function: func,\n    in_app: true // All browser frames are considered in_app\n  };\n\n  if (lineno !== undefined) {\n    frame.lineno = lineno;\n  }\n  if (colno !== undefined) {\n    frame.colno = colno;\n  }\n  return frame;\n}\n\n// Chromium based browsers: Chrome, Brave, new Opera, new Edge\nvar chromeRegex = /^\\s*at (?:(.+?\\)(?: \\[.+\\])?|.*?) ?\\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\\/)?.*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\nvar chromeEvalRegex = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\nvar chrome = function chrome(line) {\n  var parts = chromeRegex.exec(line);\n  if (parts) {\n    var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n\n    if (isEval) {\n      var subMatch = chromeEvalRegex.exec(parts[2]);\n      if (subMatch) {\n        // throw out eval line/column and use top-most line/column number\n        parts[2] = subMatch[1]; // url\n        parts[3] = subMatch[2]; // line\n        parts[4] = subMatch[3]; // column\n      }\n    }\n\n    // Kamil: One more hack won't hurt us right? Understanding and adding more rules on top of these regexps right now\n    // would be way too time consuming. (TODO: Rewrite whole RegExp to be more readable)\n    var _extractSafariExtensi = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]),\n      _extractSafariExtensi2 = _slicedToArray(_extractSafariExtensi, 2),\n      func = _extractSafariExtensi2[0],\n      filename = _extractSafariExtensi2[1];\n    return createFrame(filename, func, parts[3] ? +parts[3] : undefined, parts[4] ? +parts[4] : undefined);\n  }\n  return;\n};\nvar chromeStackLineParser = [CHROME_PRIORITY, chrome];\n\n// gecko regex: `(?:bundle|\\d+\\.js)`: `bundle` is for react native, `\\d+\\.js` also but specifically for ram bundles because it\n// generates filenames without a prefix like `file://` the filenames in the stacktrace are just 42.js\n// We need this specific case for now because we want no other regex to match.\nvar geckoREgex = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)?((?:[-a-z]+)?:\\/.*?|\\[native code\\]|[^@]*(?:bundle|\\d+\\.js)|\\/[\\w\\-. /=]+)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nvar geckoEvalRegex = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\nvar gecko = function gecko(line) {\n  var parts = geckoREgex.exec(line);\n  if (parts) {\n    var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n    if (isEval) {\n      var subMatch = geckoEvalRegex.exec(parts[3]);\n      if (subMatch) {\n        // throw out eval line/column and use top-most line number\n        parts[1] = parts[1] || 'eval';\n        parts[3] = subMatch[1];\n        parts[4] = subMatch[2];\n        parts[5] = ''; // no column when eval\n      }\n    }\n\n    var filename = parts[3];\n    var func = parts[1] || UNKNOWN_FUNCTION;\n    var _extractSafariExtensi3 = extractSafariExtensionDetails(func, filename);\n    var _extractSafariExtensi4 = _slicedToArray(_extractSafariExtensi3, 2);\n    func = _extractSafariExtensi4[0];\n    filename = _extractSafariExtensi4[1];\n    return createFrame(filename, func, parts[4] ? +parts[4] : undefined, parts[5] ? +parts[5] : undefined);\n  }\n  return;\n};\nvar geckoStackLineParser = [GECKO_PRIORITY, gecko];\nvar winjsRegex = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:[-a-z]+):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\nvar winjs = function winjs(line) {\n  var parts = winjsRegex.exec(line);\n  return parts ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : undefined) : undefined;\n};\nvar winjsStackLineParser = [WINJS_PRIORITY, winjs];\nvar opera10Regex = / line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$/i;\nvar opera10 = function opera10(line) {\n  var parts = opera10Regex.exec(line);\n  return parts ? createFrame(parts[2], parts[3] || UNKNOWN_FUNCTION, +parts[1]) : undefined;\n};\nvar opera10StackLineParser = [OPERA10_PRIORITY, opera10];\nvar opera11Regex = / line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\\(.*\\))? in (.*):\\s*$/i;\nvar opera11 = function opera11(line) {\n  var parts = opera11Regex.exec(line);\n  return parts ? createFrame(parts[5], parts[3] || parts[4] || UNKNOWN_FUNCTION, +parts[1], +parts[2]) : undefined;\n};\nvar opera11StackLineParser = [OPERA11_PRIORITY, opera11];\nvar defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser, winjsStackLineParser];\nvar defaultStackParser = createStackParser.apply(void 0, defaultStackLineParsers);\n\n/**\n * Safari web extensions, starting version unknown, can produce \"frames-only\" stacktraces.\n * What it means, is that instead of format like:\n *\n * Error: wat\n *   at function@url:row:col\n *   at function@url:row:col\n *   at function@url:row:col\n *\n * it produces something like:\n *\n *   function@url:row:col\n *   function@url:row:col\n *   function@url:row:col\n *\n * Because of that, it won't be captured by `chrome` RegExp and will fall into `Gecko` branch.\n * This function is extracted so that we can use it in both places without duplicating the logic.\n * Unfortunately \"just\" changing RegExp is too complicated now and making it pass all tests\n * and fix this case seems like an impossible, or at least way too time-consuming task.\n */\nvar extractSafariExtensionDetails = function extractSafariExtensionDetails(func, filename) {\n  var isSafariExtension = func.indexOf('safari-extension') !== -1;\n  var isSafariWebExtension = func.indexOf('safari-web-extension') !== -1;\n  return isSafariExtension || isSafariWebExtension ? [func.indexOf('@') !== -1 ? func.split('@')[0] : UNKNOWN_FUNCTION, isSafariExtension ? \"safari-extension:\".concat(filename) : \"safari-web-extension:\".concat(filename)] : [func, filename];\n};\nexport { chromeStackLineParser, defaultStackLineParsers, defaultStackParser, geckoStackLineParser, opera10StackLineParser, opera11StackLineParser, winjsStackLineParser };","map":{"version":3,"names":["UNKNOWN_FUNCTION","OPERA10_PRIORITY","OPERA11_PRIORITY","CHROME_PRIORITY","WINJS_PRIORITY","GECKO_PRIORITY","createFrame","filename","func","lineno","colno","frame","function","in_app","undefined","chromeRegex","chromeEvalRegex","chrome","line","parts","exec","isEval","indexOf","subMatch","_extractSafariExtensi","extractSafariExtensionDetails","_extractSafariExtensi2","_slicedToArray","chromeStackLineParser","geckoREgex","geckoEvalRegex","gecko","_extractSafariExtensi3","_extractSafariExtensi4","geckoStackLineParser","winjsRegex","winjs","winjsStackLineParser","opera10Regex","opera10","opera10StackLineParser","opera11Regex","opera11","opera11StackLineParser","defaultStackLineParsers","defaultStackParser","createStackParser","apply","isSafariExtension","isSafariWebExtension","split","concat"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/src/stack-parsers.ts"],"sourcesContent":["// This was originally forked from https://github.com/csnover/TraceKit, and was largely\n// re - written as part of raven - js.\n//\n// This code was later copied to the JavaScript mono - repo and further modified and\n// refactored over the years.\n\n// Copyright (c) 2013 Onur Can Cakmak onur.cakmak@gmail.com and all TraceKit contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files(the 'Software'), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n// merge, publish, distribute, sublicense, and / or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n// The above copyright notice and this permission notice shall be included in all copies\n// or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nimport type { StackFrame, StackLineParser, StackLineParserFn } from '@sentry/types';\nimport { createStackParser } from '@sentry/utils';\n\n// global reference to slice\nconst UNKNOWN_FUNCTION = '?';\n\nconst OPERA10_PRIORITY = 10;\nconst OPERA11_PRIORITY = 20;\nconst CHROME_PRIORITY = 30;\nconst WINJS_PRIORITY = 40;\nconst GECKO_PRIORITY = 50;\n\nfunction createFrame(filename: string, func: string, lineno?: number, colno?: number): StackFrame {\n  const frame: StackFrame = {\n    filename,\n    function: func,\n    in_app: true, // All browser frames are considered in_app\n  };\n\n  if (lineno !== undefined) {\n    frame.lineno = lineno;\n  }\n\n  if (colno !== undefined) {\n    frame.colno = colno;\n  }\n\n  return frame;\n}\n\n// Chromium based browsers: Chrome, Brave, new Opera, new Edge\nconst chromeRegex =\n  /^\\s*at (?:(.+?\\)(?: \\[.+\\])?|.*?) ?\\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\\/)?.*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\nconst chromeEvalRegex = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n\nconst chrome: StackLineParserFn = line => {\n  const parts = chromeRegex.exec(line);\n\n  if (parts) {\n    const isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n\n    if (isEval) {\n      const subMatch = chromeEvalRegex.exec(parts[2]);\n\n      if (subMatch) {\n        // throw out eval line/column and use top-most line/column number\n        parts[2] = subMatch[1]; // url\n        parts[3] = subMatch[2]; // line\n        parts[4] = subMatch[3]; // column\n      }\n    }\n\n    // Kamil: One more hack won't hurt us right? Understanding and adding more rules on top of these regexps right now\n    // would be way too time consuming. (TODO: Rewrite whole RegExp to be more readable)\n    const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);\n\n    return createFrame(filename, func, parts[3] ? +parts[3] : undefined, parts[4] ? +parts[4] : undefined);\n  }\n\n  return;\n};\n\nexport const chromeStackLineParser: StackLineParser = [CHROME_PRIORITY, chrome];\n\n// gecko regex: `(?:bundle|\\d+\\.js)`: `bundle` is for react native, `\\d+\\.js` also but specifically for ram bundles because it\n// generates filenames without a prefix like `file://` the filenames in the stacktrace are just 42.js\n// We need this specific case for now because we want no other regex to match.\nconst geckoREgex =\n  /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)?((?:[-a-z]+)?:\\/.*?|\\[native code\\]|[^@]*(?:bundle|\\d+\\.js)|\\/[\\w\\-. /=]+)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nconst geckoEvalRegex = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n\nconst gecko: StackLineParserFn = line => {\n  const parts = geckoREgex.exec(line);\n\n  if (parts) {\n    const isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n    if (isEval) {\n      const subMatch = geckoEvalRegex.exec(parts[3]);\n\n      if (subMatch) {\n        // throw out eval line/column and use top-most line number\n        parts[1] = parts[1] || 'eval';\n        parts[3] = subMatch[1];\n        parts[4] = subMatch[2];\n        parts[5] = ''; // no column when eval\n      }\n    }\n\n    let filename = parts[3];\n    let func = parts[1] || UNKNOWN_FUNCTION;\n    [func, filename] = extractSafariExtensionDetails(func, filename);\n\n    return createFrame(filename, func, parts[4] ? +parts[4] : undefined, parts[5] ? +parts[5] : undefined);\n  }\n\n  return;\n};\n\nexport const geckoStackLineParser: StackLineParser = [GECKO_PRIORITY, gecko];\n\nconst winjsRegex = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:[-a-z]+):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n\nconst winjs: StackLineParserFn = line => {\n  const parts = winjsRegex.exec(line);\n\n  return parts\n    ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : undefined)\n    : undefined;\n};\n\nexport const winjsStackLineParser: StackLineParser = [WINJS_PRIORITY, winjs];\n\nconst opera10Regex = / line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$/i;\n\nconst opera10: StackLineParserFn = line => {\n  const parts = opera10Regex.exec(line);\n  return parts ? createFrame(parts[2], parts[3] || UNKNOWN_FUNCTION, +parts[1]) : undefined;\n};\n\nexport const opera10StackLineParser: StackLineParser = [OPERA10_PRIORITY, opera10];\n\nconst opera11Regex =\n  / line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\\(.*\\))? in (.*):\\s*$/i;\n\nconst opera11: StackLineParserFn = line => {\n  const parts = opera11Regex.exec(line);\n  return parts ? createFrame(parts[5], parts[3] || parts[4] || UNKNOWN_FUNCTION, +parts[1], +parts[2]) : undefined;\n};\n\nexport const opera11StackLineParser: StackLineParser = [OPERA11_PRIORITY, opera11];\n\nexport const defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser, winjsStackLineParser];\n\nexport const defaultStackParser = createStackParser(...defaultStackLineParsers);\n\n/**\n * Safari web extensions, starting version unknown, can produce \"frames-only\" stacktraces.\n * What it means, is that instead of format like:\n *\n * Error: wat\n *   at function@url:row:col\n *   at function@url:row:col\n *   at function@url:row:col\n *\n * it produces something like:\n *\n *   function@url:row:col\n *   function@url:row:col\n *   function@url:row:col\n *\n * Because of that, it won't be captured by `chrome` RegExp and will fall into `Gecko` branch.\n * This function is extracted so that we can use it in both places without duplicating the logic.\n * Unfortunately \"just\" changing RegExp is too complicated now and making it pass all tests\n * and fix this case seems like an impossible, or at least way too time-consuming task.\n */\nconst extractSafariExtensionDetails = (func: string, filename: string): [string, string] => {\n  const isSafariExtension = func.indexOf('safari-extension') !== -1;\n  const isSafariWebExtension = func.indexOf('safari-web-extension') !== -1;\n\n  return isSafariExtension || isSafariWebExtension\n    ? [\n        func.indexOf('@') !== -1 ? func.split('@')[0] : UNKNOWN_FUNCTION,\n        isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`,\n      ]\n    : [func, filename];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}