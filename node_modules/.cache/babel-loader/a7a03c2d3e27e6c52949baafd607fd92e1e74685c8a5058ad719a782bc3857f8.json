{"ast":null,"code":"import _toConsumableArray from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { uuid4, dateTimestampInSeconds, resolvedSyncPromise, truncate, GLOBAL_OBJ, normalize } from '@sentry/utils';\nimport { DEFAULT_ENVIRONMENT } from '../constants.js';\nimport { Scope } from '../scope.js';\n\n/**\n * Adds common information to events.\n *\n * The information includes release and environment from `options`,\n * breadcrumbs and context (extra, tags and user) from the scope.\n *\n * Information that is already present in the event is never overwritten. For\n * nested objects, such as the context, keys are merged.\n *\n * Note: This also triggers callbacks for `addGlobalEventProcessor`, but not `beforeSend`.\n *\n * @param event The original event.\n * @param hint May contain additional information about the original exception.\n * @param scope A scope containing event metadata.\n * @returns A new event with more information.\n * @hidden\n */\nfunction prepareEvent(options, event, hint, scope) {\n  var _options$normalizeDep = options.normalizeDepth,\n    normalizeDepth = _options$normalizeDep === void 0 ? 3 : _options$normalizeDep,\n    _options$normalizeMax = options.normalizeMaxBreadth,\n    normalizeMaxBreadth = _options$normalizeMax === void 0 ? 1000 : _options$normalizeMax;\n  var prepared = _objectSpread(_objectSpread({}, event), {}, {\n    event_id: event.event_id || hint.event_id || uuid4(),\n    timestamp: event.timestamp || dateTimestampInSeconds()\n  });\n  var integrations = hint.integrations || options.integrations.map(function (i) {\n    return i.name;\n  });\n  applyClientOptions(prepared, options);\n  applyIntegrationsMetadata(prepared, integrations);\n\n  // Only put debug IDs onto frames for error events.\n  if (event.type === undefined) {\n    applyDebugIds(prepared, options.stackParser);\n  }\n\n  // If we have scope given to us, use it as the base for further modifications.\n  // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n  var finalScope = scope;\n  if (hint.captureContext) {\n    finalScope = Scope.clone(finalScope).update(hint.captureContext);\n  }\n\n  // We prepare the result here with a resolved Event.\n  var result = resolvedSyncPromise(prepared);\n\n  // This should be the last thing called, since we want that\n  // {@link Hub.addEventProcessor} gets the finished prepared event.\n  //\n  // We need to check for the existence of `finalScope.getAttachments`\n  // because `getAttachments` can be undefined if users are using an older version\n  // of `@sentry/core` that does not have the `getAttachments` method.\n  // See: https://github.com/getsentry/sentry-javascript/issues/5229\n  if (finalScope) {\n    // Collect attachments from the hint and scope\n    if (finalScope.getAttachments) {\n      var attachments = [].concat(_toConsumableArray(hint.attachments || []), _toConsumableArray(finalScope.getAttachments()));\n      if (attachments.length) {\n        hint.attachments = attachments;\n      }\n    }\n\n    // In case we have a hub we reassign it.\n    result = finalScope.applyToEvent(prepared, hint);\n  }\n  return result.then(function (evt) {\n    if (evt) {\n      // We apply the debug_meta field only after all event processors have ran, so that if any event processors modified\n      // file names (e.g.the RewriteFrames integration) the filename -> debug ID relationship isn't destroyed.\n      // This should not cause any PII issues, since we're only moving data that is already on the event and not adding\n      // any new data\n      applyDebugMeta(evt);\n    }\n    if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n    }\n    return evt;\n  });\n}\n\n/**\n *  Enhances event using the client configuration.\n *  It takes care of all \"static\" values like environment, release and `dist`,\n *  as well as truncating overly long values.\n * @param event event instance to be enhanced\n */\nfunction applyClientOptions(event, options) {\n  var environment = options.environment,\n    release = options.release,\n    dist = options.dist,\n    _options$maxValueLeng = options.maxValueLength,\n    maxValueLength = _options$maxValueLeng === void 0 ? 250 : _options$maxValueLeng;\n  if (!('environment' in event)) {\n    event.environment = 'environment' in options ? environment : DEFAULT_ENVIRONMENT;\n  }\n  if (event.release === undefined && release !== undefined) {\n    event.release = release;\n  }\n  if (event.dist === undefined && dist !== undefined) {\n    event.dist = dist;\n  }\n  if (event.message) {\n    event.message = truncate(event.message, maxValueLength);\n  }\n  var exception = event.exception && event.exception.values && event.exception.values[0];\n  if (exception && exception.value) {\n    exception.value = truncate(exception.value, maxValueLength);\n  }\n  var request = event.request;\n  if (request && request.url) {\n    request.url = truncate(request.url, maxValueLength);\n  }\n}\nvar debugIdStackParserCache = new WeakMap();\n\n/**\n * Puts debug IDs into the stack frames of an error event.\n */\nfunction applyDebugIds(event, stackParser) {\n  var debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n  if (!debugIdMap) {\n    return;\n  }\n  var debugIdStackFramesCache;\n  var cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);\n  if (cachedDebugIdStackFrameCache) {\n    debugIdStackFramesCache = cachedDebugIdStackFrameCache;\n  } else {\n    debugIdStackFramesCache = new Map();\n    debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);\n  }\n\n  // Build a map of filename -> debug_id\n  var filenameDebugIdMap = Object.keys(debugIdMap).reduce(function (acc, debugIdStackTrace) {\n    var parsedStack;\n    var cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);\n    if (cachedParsedStack) {\n      parsedStack = cachedParsedStack;\n    } else {\n      parsedStack = stackParser(debugIdStackTrace);\n      debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);\n    }\n    for (var i = parsedStack.length - 1; i >= 0; i--) {\n      var stackFrame = parsedStack[i];\n      if (stackFrame.filename) {\n        acc[stackFrame.filename] = debugIdMap[debugIdStackTrace];\n        break;\n      }\n    }\n    return acc;\n  }, {});\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception.values.forEach(function (exception) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace.frames.forEach(function (frame) {\n        if (frame.filename) {\n          frame.debug_id = filenameDebugIdMap[frame.filename];\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n}\n\n/**\n * Moves debug IDs from the stack frames of an error event into the debug_meta field.\n */\nfunction applyDebugMeta(event) {\n  // Extract debug IDs and filenames from the stack frames on the event.\n  var filenameDebugIdMap = {};\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception.values.forEach(function (exception) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace.frames.forEach(function (frame) {\n        if (frame.debug_id) {\n          if (frame.abs_path) {\n            filenameDebugIdMap[frame.abs_path] = frame.debug_id;\n          } else if (frame.filename) {\n            filenameDebugIdMap[frame.filename] = frame.debug_id;\n          }\n          delete frame.debug_id;\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n  if (Object.keys(filenameDebugIdMap).length === 0) {\n    return;\n  }\n\n  // Fill debug_meta information\n  event.debug_meta = event.debug_meta || {};\n  event.debug_meta.images = event.debug_meta.images || [];\n  var images = event.debug_meta.images;\n  Object.keys(filenameDebugIdMap).forEach(function (filename) {\n    images.push({\n      type: 'sourcemap',\n      code_file: filename,\n      debug_id: filenameDebugIdMap[filename]\n    });\n  });\n}\n\n/**\n * This function adds all used integrations to the SDK info in the event.\n * @param event The event that will be filled with all integrations.\n */\nfunction applyIntegrationsMetadata(event, integrationNames) {\n  if (integrationNames.length > 0) {\n    event.sdk = event.sdk || {};\n    event.sdk.integrations = [].concat(_toConsumableArray(event.sdk.integrations || []), _toConsumableArray(integrationNames));\n  }\n}\n\n/**\n * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n * Normalized keys:\n * - `breadcrumbs.data`\n * - `user`\n * - `contexts`\n * - `extra`\n * @param event Event\n * @returns Normalized event\n */\nfunction normalizeEvent(event, depth, maxBreadth) {\n  if (!event) {\n    return null;\n  }\n  var normalized = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, event), event.breadcrumbs && {\n    breadcrumbs: event.breadcrumbs.map(function (b) {\n      return _objectSpread(_objectSpread({}, b), b.data && {\n        data: normalize(b.data, depth, maxBreadth)\n      });\n    })\n  }), event.user && {\n    user: normalize(event.user, depth, maxBreadth)\n  }), event.contexts && {\n    contexts: normalize(event.contexts, depth, maxBreadth)\n  }), event.extra && {\n    extra: normalize(event.extra, depth, maxBreadth)\n  });\n\n  // event.contexts.trace stores information about a Transaction. Similarly,\n  // event.spans[] stores information about child Spans. Given that a\n  // Transaction is conceptually a Span, normalization should apply to both\n  // Transactions and Spans consistently.\n  // For now the decision is to skip normalization of Transactions and Spans,\n  // so this block overwrites the normalized event to add back the original\n  // Transaction information prior to normalization.\n  if (event.contexts && event.contexts.trace && normalized.contexts) {\n    normalized.contexts.trace = event.contexts.trace;\n\n    // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n    if (event.contexts.trace.data) {\n      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n    }\n  }\n\n  // event.spans[].data may contain circular/dangerous data so we need to normalize it\n  if (event.spans) {\n    normalized.spans = event.spans.map(function (span) {\n      // We cannot use the spread operator here because `toJSON` on `span` is non-enumerable\n      if (span.data) {\n        span.data = normalize(span.data, depth, maxBreadth);\n      }\n      return span;\n    });\n  }\n  return normalized;\n}\nexport { applyDebugIds, applyDebugMeta, prepareEvent };","map":{"version":3,"names":["prepareEvent","options","event","hint","scope","_options$normalizeDep","normalizeDepth","_options$normalizeMax","normalizeMaxBreadth","prepared","_objectSpread","event_id","uuid4","timestamp","dateTimestampInSeconds","integrations","map","i","name","applyClientOptions","applyIntegrationsMetadata","type","undefined","applyDebugIds","stackParser","finalScope","captureContext","Scope","clone","update","result","resolvedSyncPromise","getAttachments","attachments","concat","_toConsumableArray","length","applyToEvent","then","evt","applyDebugMeta","normalizeEvent","environment","release","dist","_options$maxValueLeng","maxValueLength","DEFAULT_ENVIRONMENT","message","truncate","exception","values","value","request","url","debugIdStackParserCache","WeakMap","debugIdMap","GLOBAL_OBJ","_sentryDebugIds","debugIdStackFramesCache","cachedDebugIdStackFrameCache","get","Map","set","filenameDebugIdMap","Object","keys","reduce","acc","debugIdStackTrace","parsedStack","cachedParsedStack","stackFrame","filename","forEach","stacktrace","frames","frame","debug_id","e","abs_path","debug_meta","images","push","code_file","integrationNames","sdk","depth","maxBreadth","normalized","breadcrumbs","b","data","normalize","user","contexts","extra","trace","spans","span"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/utils/prepareEvent.ts"],"sourcesContent":["import type { ClientOptions, Event, EventHint, StackFrame, StackParser } from '@sentry/types';\nimport { dateTimestampInSeconds, GLOBAL_OBJ, normalize, resolvedSyncPromise, truncate, uuid4 } from '@sentry/utils';\n\nimport { DEFAULT_ENVIRONMENT } from '../constants';\nimport { Scope } from '../scope';\n\n/**\n * Adds common information to events.\n *\n * The information includes release and environment from `options`,\n * breadcrumbs and context (extra, tags and user) from the scope.\n *\n * Information that is already present in the event is never overwritten. For\n * nested objects, such as the context, keys are merged.\n *\n * Note: This also triggers callbacks for `addGlobalEventProcessor`, but not `beforeSend`.\n *\n * @param event The original event.\n * @param hint May contain additional information about the original exception.\n * @param scope A scope containing event metadata.\n * @returns A new event with more information.\n * @hidden\n */\nexport function prepareEvent(\n  options: ClientOptions,\n  event: Event,\n  hint: EventHint,\n  scope?: Scope,\n): PromiseLike<Event | null> {\n  const { normalizeDepth = 3, normalizeMaxBreadth = 1_000 } = options;\n  const prepared: Event = {\n    ...event,\n    event_id: event.event_id || hint.event_id || uuid4(),\n    timestamp: event.timestamp || dateTimestampInSeconds(),\n  };\n  const integrations = hint.integrations || options.integrations.map(i => i.name);\n\n  applyClientOptions(prepared, options);\n  applyIntegrationsMetadata(prepared, integrations);\n\n  // Only put debug IDs onto frames for error events.\n  if (event.type === undefined) {\n    applyDebugIds(prepared, options.stackParser);\n  }\n\n  // If we have scope given to us, use it as the base for further modifications.\n  // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n  let finalScope = scope;\n  if (hint.captureContext) {\n    finalScope = Scope.clone(finalScope).update(hint.captureContext);\n  }\n\n  // We prepare the result here with a resolved Event.\n  let result = resolvedSyncPromise<Event | null>(prepared);\n\n  // This should be the last thing called, since we want that\n  // {@link Hub.addEventProcessor} gets the finished prepared event.\n  //\n  // We need to check for the existence of `finalScope.getAttachments`\n  // because `getAttachments` can be undefined if users are using an older version\n  // of `@sentry/core` that does not have the `getAttachments` method.\n  // See: https://github.com/getsentry/sentry-javascript/issues/5229\n  if (finalScope) {\n    // Collect attachments from the hint and scope\n    if (finalScope.getAttachments) {\n      const attachments = [...(hint.attachments || []), ...finalScope.getAttachments()];\n\n      if (attachments.length) {\n        hint.attachments = attachments;\n      }\n    }\n\n    // In case we have a hub we reassign it.\n    result = finalScope.applyToEvent(prepared, hint);\n  }\n\n  return result.then(evt => {\n    if (evt) {\n      // We apply the debug_meta field only after all event processors have ran, so that if any event processors modified\n      // file names (e.g.the RewriteFrames integration) the filename -> debug ID relationship isn't destroyed.\n      // This should not cause any PII issues, since we're only moving data that is already on the event and not adding\n      // any new data\n      applyDebugMeta(evt);\n    }\n\n    if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n    }\n    return evt;\n  });\n}\n\n/**\n *  Enhances event using the client configuration.\n *  It takes care of all \"static\" values like environment, release and `dist`,\n *  as well as truncating overly long values.\n * @param event event instance to be enhanced\n */\nfunction applyClientOptions(event: Event, options: ClientOptions): void {\n  const { environment, release, dist, maxValueLength = 250 } = options;\n\n  if (!('environment' in event)) {\n    event.environment = 'environment' in options ? environment : DEFAULT_ENVIRONMENT;\n  }\n\n  if (event.release === undefined && release !== undefined) {\n    event.release = release;\n  }\n\n  if (event.dist === undefined && dist !== undefined) {\n    event.dist = dist;\n  }\n\n  if (event.message) {\n    event.message = truncate(event.message, maxValueLength);\n  }\n\n  const exception = event.exception && event.exception.values && event.exception.values[0];\n  if (exception && exception.value) {\n    exception.value = truncate(exception.value, maxValueLength);\n  }\n\n  const request = event.request;\n  if (request && request.url) {\n    request.url = truncate(request.url, maxValueLength);\n  }\n}\n\nconst debugIdStackParserCache = new WeakMap<StackParser, Map<string, StackFrame[]>>();\n\n/**\n * Puts debug IDs into the stack frames of an error event.\n */\nexport function applyDebugIds(event: Event, stackParser: StackParser): void {\n  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n\n  if (!debugIdMap) {\n    return;\n  }\n\n  let debugIdStackFramesCache: Map<string, StackFrame[]>;\n  const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);\n  if (cachedDebugIdStackFrameCache) {\n    debugIdStackFramesCache = cachedDebugIdStackFrameCache;\n  } else {\n    debugIdStackFramesCache = new Map<string, StackFrame[]>();\n    debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);\n  }\n\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = Object.keys(debugIdMap).reduce<Record<string, string>>((acc, debugIdStackTrace) => {\n    let parsedStack: StackFrame[];\n    const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);\n    if (cachedParsedStack) {\n      parsedStack = cachedParsedStack;\n    } else {\n      parsedStack = stackParser(debugIdStackTrace);\n      debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);\n    }\n\n    for (let i = parsedStack.length - 1; i >= 0; i--) {\n      const stackFrame = parsedStack[i];\n      if (stackFrame.filename) {\n        acc[stackFrame.filename] = debugIdMap[debugIdStackTrace];\n        break;\n      }\n    }\n    return acc;\n  }, {});\n\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event!.exception!.values!.forEach(exception => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace!.frames!.forEach(frame => {\n        if (frame.filename) {\n          frame.debug_id = filenameDebugIdMap[frame.filename];\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n}\n\n/**\n * Moves debug IDs from the stack frames of an error event into the debug_meta field.\n */\nexport function applyDebugMeta(event: Event): void {\n  // Extract debug IDs and filenames from the stack frames on the event.\n  const filenameDebugIdMap: Record<string, string> = {};\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception!.values!.forEach(exception => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace!.frames!.forEach(frame => {\n        if (frame.debug_id) {\n          if (frame.abs_path) {\n            filenameDebugIdMap[frame.abs_path] = frame.debug_id;\n          } else if (frame.filename) {\n            filenameDebugIdMap[frame.filename] = frame.debug_id;\n          }\n          delete frame.debug_id;\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n\n  if (Object.keys(filenameDebugIdMap).length === 0) {\n    return;\n  }\n\n  // Fill debug_meta information\n  event.debug_meta = event.debug_meta || {};\n  event.debug_meta.images = event.debug_meta.images || [];\n  const images = event.debug_meta.images;\n  Object.keys(filenameDebugIdMap).forEach(filename => {\n    images.push({\n      type: 'sourcemap',\n      code_file: filename,\n      debug_id: filenameDebugIdMap[filename],\n    });\n  });\n}\n\n/**\n * This function adds all used integrations to the SDK info in the event.\n * @param event The event that will be filled with all integrations.\n */\nfunction applyIntegrationsMetadata(event: Event, integrationNames: string[]): void {\n  if (integrationNames.length > 0) {\n    event.sdk = event.sdk || {};\n    event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationNames];\n  }\n}\n\n/**\n * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n * Normalized keys:\n * - `breadcrumbs.data`\n * - `user`\n * - `contexts`\n * - `extra`\n * @param event Event\n * @returns Normalized event\n */\nfunction normalizeEvent(event: Event | null, depth: number, maxBreadth: number): Event | null {\n  if (!event) {\n    return null;\n  }\n\n  const normalized: Event = {\n    ...event,\n    ...(event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(b => ({\n        ...b,\n        ...(b.data && {\n          data: normalize(b.data, depth, maxBreadth),\n        }),\n      })),\n    }),\n    ...(event.user && {\n      user: normalize(event.user, depth, maxBreadth),\n    }),\n    ...(event.contexts && {\n      contexts: normalize(event.contexts, depth, maxBreadth),\n    }),\n    ...(event.extra && {\n      extra: normalize(event.extra, depth, maxBreadth),\n    }),\n  };\n\n  // event.contexts.trace stores information about a Transaction. Similarly,\n  // event.spans[] stores information about child Spans. Given that a\n  // Transaction is conceptually a Span, normalization should apply to both\n  // Transactions and Spans consistently.\n  // For now the decision is to skip normalization of Transactions and Spans,\n  // so this block overwrites the normalized event to add back the original\n  // Transaction information prior to normalization.\n  if (event.contexts && event.contexts.trace && normalized.contexts) {\n    normalized.contexts.trace = event.contexts.trace;\n\n    // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n    if (event.contexts.trace.data) {\n      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n    }\n  }\n\n  // event.spans[].data may contain circular/dangerous data so we need to normalize it\n  if (event.spans) {\n    normalized.spans = event.spans.map(span => {\n      // We cannot use the spread operator here because `toJSON` on `span` is non-enumerable\n      if (span.data) {\n        span.data = normalize(span.data, depth, maxBreadth);\n      }\n      return span;\n    });\n  }\n\n  return normalized;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}