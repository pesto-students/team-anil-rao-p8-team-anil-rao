{"ast":null,"code":"import _regeneratorRuntime from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { parseRetryAfterHeader, logger, envelopeContainsItemType } from '@sentry/utils';\nvar MIN_DELAY = 100; // 100 ms\nvar START_DELAY = 5000; // 5 seconds\nvar MAX_DELAY = 3.6e6; // 1 hour\n\nfunction log(msg, error) {\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.info(\"[Offline]: \".concat(msg), error);\n}\n\n/**\n * Wraps a transport and stores and retries events when they fail to send.\n *\n * @param createTransport The transport to wrap.\n */\nfunction makeOfflineTransport(createTransport) {\n  return function (options) {\n    var transport = createTransport(options);\n    var store = options.createStore ? options.createStore(options) : undefined;\n    var retryDelay = START_DELAY;\n    var flushTimer;\n    function shouldQueue(env, error, retryDelay) {\n      // We don't queue Session Replay envelopes because they are:\n      // - Ordered and Replay relies on the response status to know when they're successfully sent.\n      // - Likely to fill the queue quickly and block other events from being sent.\n      // We also want to drop client reports because they can be generated when we retry sending events while offline.\n      if (envelopeContainsItemType(env, ['replay_event', 'replay_recording', 'client_report'])) {\n        return false;\n      }\n      if (options.shouldStore) {\n        return options.shouldStore(env, error, retryDelay);\n      }\n      return true;\n    }\n    function flushIn(delay) {\n      if (!store) {\n        return;\n      }\n      if (flushTimer) {\n        clearTimeout(flushTimer);\n      }\n      flushTimer = setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var found;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              flushTimer = undefined;\n              _context.next = 3;\n              return store.pop();\n            case 3:\n              found = _context.sent;\n              if (found) {\n                log('Attempting to send previously queued event');\n                void send(found).catch(function (e) {\n                  log('Failed to retry sending', e);\n                });\n              }\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      })), delay);\n\n      // We need to unref the timer in node.js, otherwise the node process never exit.\n      if (typeof flushTimer !== 'number' && flushTimer.unref) {\n        flushTimer.unref();\n      }\n    }\n    function flushWithBackOff() {\n      if (flushTimer) {\n        return;\n      }\n      flushIn(retryDelay);\n      retryDelay = Math.min(retryDelay * 2, MAX_DELAY);\n    }\n    function send(_x) {\n      return _send.apply(this, arguments);\n    }\n    function _send() {\n      _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(envelope) {\n        var result, delay;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              _context2.next = 3;\n              return transport.send(envelope);\n            case 3:\n              result = _context2.sent;\n              delay = MIN_DELAY;\n              if (!result) {\n                _context2.next = 12;\n                break;\n              }\n              if (!(result.headers && result.headers['retry-after'])) {\n                _context2.next = 10;\n                break;\n              }\n              delay = parseRetryAfterHeader(result.headers['retry-after']);\n              _context2.next = 12;\n              break;\n            case 10:\n              if (!((result.statusCode || 0) >= 400)) {\n                _context2.next = 12;\n                break;\n              }\n              return _context2.abrupt(\"return\", result);\n            case 12:\n              flushIn(delay);\n              retryDelay = START_DELAY;\n              return _context2.abrupt(\"return\", result);\n            case 17:\n              _context2.prev = 17;\n              _context2.t0 = _context2[\"catch\"](0);\n              _context2.t1 = store;\n              if (!_context2.t1) {\n                _context2.next = 24;\n                break;\n              }\n              _context2.next = 23;\n              return shouldQueue(envelope, _context2.t0, retryDelay);\n            case 23:\n              _context2.t1 = _context2.sent;\n            case 24:\n              if (!_context2.t1) {\n                _context2.next = 32;\n                break;\n              }\n              _context2.next = 27;\n              return store.insert(envelope);\n            case 27:\n              flushWithBackOff();\n              log('Error sending. Event queued', _context2.t0);\n              return _context2.abrupt(\"return\", {});\n            case 32:\n              throw _context2.t0;\n            case 33:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, null, [[0, 17]]);\n      }));\n      return _send.apply(this, arguments);\n    }\n    if (options.flushAtStartup) {\n      flushWithBackOff();\n    }\n    return {\n      send: send,\n      flush: function flush(t) {\n        return transport.flush(t);\n      }\n    };\n  };\n}\nexport { MIN_DELAY, START_DELAY, makeOfflineTransport };","map":{"version":3,"names":["MIN_DELAY","START_DELAY","MAX_DELAY","log","msg","error","__SENTRY_DEBUG__","logger","info","concat","makeOfflineTransport","createTransport","options","transport","store","createStore","undefined","retryDelay","flushTimer","shouldQueue","env","envelopeContainsItemType","shouldStore","flushIn","delay","clearTimeout","setTimeout","_asyncToGenerator","_regeneratorRuntime","mark","_callee","found","wrap","_callee$","_context","prev","next","pop","sent","send","catch","e","stop","unref","flushWithBackOff","Math","min","_x","_send","apply","arguments","_callee2","envelope","result","_callee2$","_context2","headers","parseRetryAfterHeader","statusCode","abrupt","t0","t1","insert","flushAtStartup","flush","t"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/transports/offline.ts"],"sourcesContent":["import type { Envelope, InternalBaseTransportOptions, Transport, TransportMakeRequestResponse } from '@sentry/types';\nimport { envelopeContainsItemType, logger, parseRetryAfterHeader } from '@sentry/utils';\n\nexport const MIN_DELAY = 100; // 100 ms\nexport const START_DELAY = 5_000; // 5 seconds\nconst MAX_DELAY = 3.6e6; // 1 hour\n\nfunction log(msg: string, error?: Error): void {\n  __DEBUG_BUILD__ && logger.info(`[Offline]: ${msg}`, error);\n}\n\nexport interface OfflineStore {\n  insert(env: Envelope): Promise<void>;\n  pop(): Promise<Envelope | undefined>;\n}\n\nexport type CreateOfflineStore = (options: OfflineTransportOptions) => OfflineStore;\n\nexport interface OfflineTransportOptions extends InternalBaseTransportOptions {\n  /**\n   * A function that creates the offline store instance.\n   */\n  createStore?: CreateOfflineStore;\n\n  /**\n   * Flush the offline store shortly after startup.\n   *\n   * Defaults: false\n   */\n  flushAtStartup?: boolean;\n\n  /**\n   * Called before an event is stored.\n   *\n   * Return false to drop the envelope rather than store it.\n   *\n   * @param envelope The envelope that failed to send.\n   * @param error The error that occurred.\n   * @param retryDelay The current retry delay in milliseconds.\n   */\n  shouldStore?: (envelope: Envelope, error: Error, retryDelay: number) => boolean | Promise<boolean>;\n}\n\ntype Timer = number | { unref?: () => void };\n\n/**\n * Wraps a transport and stores and retries events when they fail to send.\n *\n * @param createTransport The transport to wrap.\n */\nexport function makeOfflineTransport<TO>(\n  createTransport: (options: TO) => Transport,\n): (options: TO & OfflineTransportOptions) => Transport {\n  return options => {\n    const transport = createTransport(options);\n    const store = options.createStore ? options.createStore(options) : undefined;\n\n    let retryDelay = START_DELAY;\n    let flushTimer: Timer | undefined;\n\n    function shouldQueue(env: Envelope, error: Error, retryDelay: number): boolean | Promise<boolean> {\n      // We don't queue Session Replay envelopes because they are:\n      // - Ordered and Replay relies on the response status to know when they're successfully sent.\n      // - Likely to fill the queue quickly and block other events from being sent.\n      // We also want to drop client reports because they can be generated when we retry sending events while offline.\n      if (envelopeContainsItemType(env, ['replay_event', 'replay_recording', 'client_report'])) {\n        return false;\n      }\n\n      if (options.shouldStore) {\n        return options.shouldStore(env, error, retryDelay);\n      }\n\n      return true;\n    }\n\n    function flushIn(delay: number): void {\n      if (!store) {\n        return;\n      }\n\n      if (flushTimer) {\n        clearTimeout(flushTimer as ReturnType<typeof setTimeout>);\n      }\n\n      flushTimer = setTimeout(async () => {\n        flushTimer = undefined;\n\n        const found = await store.pop();\n        if (found) {\n          log('Attempting to send previously queued event');\n          void send(found).catch(e => {\n            log('Failed to retry sending', e);\n          });\n        }\n      }, delay) as Timer;\n\n      // We need to unref the timer in node.js, otherwise the node process never exit.\n      if (typeof flushTimer !== 'number' && flushTimer.unref) {\n        flushTimer.unref();\n      }\n    }\n\n    function flushWithBackOff(): void {\n      if (flushTimer) {\n        return;\n      }\n\n      flushIn(retryDelay);\n\n      retryDelay = Math.min(retryDelay * 2, MAX_DELAY);\n    }\n\n    async function send(envelope: Envelope): Promise<void | TransportMakeRequestResponse> {\n      try {\n        const result = await transport.send(envelope);\n\n        let delay = MIN_DELAY;\n\n        if (result) {\n          // If there's a retry-after header, use that as the next delay.\n          if (result.headers && result.headers['retry-after']) {\n            delay = parseRetryAfterHeader(result.headers['retry-after']);\n          } // If we have a server error, return now so we don't flush the queue.\n          else if ((result.statusCode || 0) >= 400) {\n            return result;\n          }\n        }\n\n        flushIn(delay);\n        retryDelay = START_DELAY;\n        return result;\n      } catch (e) {\n        if (store && (await shouldQueue(envelope, e as Error, retryDelay))) {\n          await store.insert(envelope);\n          flushWithBackOff();\n          log('Error sending. Event queued', e as Error);\n          return {};\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    if (options.flushAtStartup) {\n      flushWithBackOff();\n    }\n\n    return {\n      send,\n      flush: t => transport.flush(t),\n    };\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}