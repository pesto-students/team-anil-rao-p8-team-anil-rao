{"ast":null,"code":"import _toConsumableArray from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { dsnFromString, forEachEnvelopeItem } from '@sentry/utils';\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from '../api.js';\nfunction eventFromEnvelope(env, types) {\n  var event;\n  forEachEnvelopeItem(env, function (item, type) {\n    if (types.includes(type)) {\n      event = Array.isArray(item) ? item[1] : undefined;\n    }\n    // bail out if we found an event\n    return !!event;\n  });\n  return event;\n}\n\n/**\n * Creates a transport that can send events to different DSNs depending on the envelope contents.\n */\nfunction makeMultiplexedTransport(createTransport, matcher) {\n  return function (options) {\n    var fallbackTransport = createTransport(options);\n    var otherTransports = {};\n    function getTransport(dsn) {\n      if (!otherTransports[dsn]) {\n        var validatedDsn = dsnFromString(dsn);\n        if (!validatedDsn) {\n          return undefined;\n        }\n        var url = getEnvelopeEndpointWithUrlEncodedAuth(validatedDsn);\n        otherTransports[dsn] = createTransport(_objectSpread(_objectSpread({}, options), {}, {\n          url: url\n        }));\n      }\n      return otherTransports[dsn];\n    }\n    function send(_x) {\n      return _send.apply(this, arguments);\n    }\n    function _send() {\n      _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(envelope) {\n        var getEvent, transports, results;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              getEvent = function _getEvent(types) {\n                var eventTypes = types && types.length ? types : ['event'];\n                return eventFromEnvelope(envelope, eventTypes);\n              };\n              transports = matcher({\n                envelope: envelope,\n                getEvent: getEvent\n              }).map(function (dsn) {\n                return getTransport(dsn);\n              }).filter(function (t) {\n                return !!t;\n              }); // If we have no transports to send to, use the fallback transport\n              if (transports.length === 0) {\n                transports.push(fallbackTransport);\n              }\n              _context.next = 5;\n              return Promise.all(transports.map(function (transport) {\n                return transport.send(envelope);\n              }));\n            case 5:\n              results = _context.sent;\n              return _context.abrupt(\"return\", results[0]);\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return _send.apply(this, arguments);\n    }\n    function flush(_x2) {\n      return _flush.apply(this, arguments);\n    }\n    function _flush() {\n      _flush = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(timeout) {\n        var allTransports, results;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              allTransports = [].concat(_toConsumableArray(Object.keys(otherTransports).map(function (dsn) {\n                return otherTransports[dsn];\n              })), [fallbackTransport]);\n              _context2.next = 3;\n              return Promise.all(allTransports.map(function (transport) {\n                return transport.flush(timeout);\n              }));\n            case 3:\n              results = _context2.sent;\n              return _context2.abrupt(\"return\", results.every(function (r) {\n                return r;\n              }));\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      return _flush.apply(this, arguments);\n    }\n    return {\n      send: send,\n      flush: flush\n    };\n  };\n}\nexport { makeMultiplexedTransport };","map":{"version":3,"names":["eventFromEnvelope","env","types","event","forEachEnvelopeItem","item","type","includes","Array","isArray","undefined","makeMultiplexedTransport","createTransport","matcher","options","fallbackTransport","otherTransports","getTransport","dsn","validatedDsn","dsnFromString","url","getEnvelopeEndpointWithUrlEncodedAuth","_objectSpread","send","_x","_send","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","envelope","getEvent","transports","results","wrap","_callee$","_context","prev","next","_getEvent","eventTypes","length","map","filter","t","push","Promise","all","transport","sent","abrupt","stop","flush","_x2","_flush","_callee2","timeout","allTransports","_callee2$","_context2","concat","_toConsumableArray","Object","keys","every","r"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/transports/multiplexed.ts"],"sourcesContent":["import type {\n  BaseTransportOptions,\n  Envelope,\n  EnvelopeItemType,\n  Event,\n  EventItem,\n  Transport,\n  TransportMakeRequestResponse,\n} from '@sentry/types';\nimport { dsnFromString, forEachEnvelopeItem } from '@sentry/utils';\n\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from '../api';\n\ninterface MatchParam {\n  /** The envelope to be sent */\n  envelope: Envelope;\n  /**\n   * A function that returns an event from the envelope if one exists. You can optionally pass an array of envelope item\n   * types to filter by - only envelopes matching the given types will be multiplexed.\n   * Allowed values are: 'event', 'transaction', 'profile', 'replay_event'\n   *\n   * @param types Defaults to ['event']\n   */\n  getEvent(types?: EnvelopeItemType[]): Event | undefined;\n}\n\ntype Matcher = (param: MatchParam) => string[];\n\nfunction eventFromEnvelope(env: Envelope, types: EnvelopeItemType[]): Event | undefined {\n  let event: Event | undefined;\n\n  forEachEnvelopeItem(env, (item, type) => {\n    if (types.includes(type)) {\n      event = Array.isArray(item) ? (item as EventItem)[1] : undefined;\n    }\n    // bail out if we found an event\n    return !!event;\n  });\n\n  return event;\n}\n\n/**\n * Creates a transport that can send events to different DSNs depending on the envelope contents.\n */\nexport function makeMultiplexedTransport<TO extends BaseTransportOptions>(\n  createTransport: (options: TO) => Transport,\n  matcher: Matcher,\n): (options: TO) => Transport {\n  return options => {\n    const fallbackTransport = createTransport(options);\n    const otherTransports: Record<string, Transport> = {};\n\n    function getTransport(dsn: string): Transport | undefined {\n      if (!otherTransports[dsn]) {\n        const validatedDsn = dsnFromString(dsn);\n        if (!validatedDsn) {\n          return undefined;\n        }\n        const url = getEnvelopeEndpointWithUrlEncodedAuth(validatedDsn);\n        otherTransports[dsn] = createTransport({ ...options, url });\n      }\n\n      return otherTransports[dsn];\n    }\n\n    async function send(envelope: Envelope): Promise<void | TransportMakeRequestResponse> {\n      function getEvent(types?: EnvelopeItemType[]): Event | undefined {\n        const eventTypes: EnvelopeItemType[] = types && types.length ? types : ['event'];\n        return eventFromEnvelope(envelope, eventTypes);\n      }\n\n      const transports = matcher({ envelope, getEvent })\n        .map(dsn => getTransport(dsn))\n        .filter((t): t is Transport => !!t);\n\n      // If we have no transports to send to, use the fallback transport\n      if (transports.length === 0) {\n        transports.push(fallbackTransport);\n      }\n\n      const results = await Promise.all(transports.map(transport => transport.send(envelope)));\n\n      return results[0];\n    }\n\n    async function flush(timeout: number | undefined): Promise<boolean> {\n      const allTransports = [...Object.keys(otherTransports).map(dsn => otherTransports[dsn]), fallbackTransport];\n      const results = await Promise.all(allTransports.map(transport => transport.flush(timeout)));\n      return results.every(r => r);\n    }\n\n    return {\n      send,\n      flush,\n    };\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}