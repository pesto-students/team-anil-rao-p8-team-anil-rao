{"ast":null,"code":"import _regeneratorRuntime from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { getCurrentHub } from '@sentry/core';\nimport { logger, uuid4 } from '@sentry/utils';\nimport { WINDOW } from '../helpers.js';\nimport { isValidSampleRate, addProfileToMap } from './utils.js';\n\n/* eslint-disable complexity */\n\nvar MAX_PROFILE_DURATION_MS = 30000;\n// Keep a flag value to avoid re-initializing the profiler constructor. If it fails\n// once, it will always fail and this allows us to early return.\nvar PROFILING_CONSTRUCTOR_FAILED = false;\n\n/**\n * Check if profiler constructor is available.\n * @param maybeProfiler\n */\nfunction isJSProfilerSupported(maybeProfiler) {\n  return typeof maybeProfiler === 'function';\n}\n\n/**\n * Safety wrapper for startTransaction for the unlikely case that transaction starts before tracing is imported -\n * if that happens we want to avoid throwing an error from profiling code.\n * see https://github.com/getsentry/sentry-javascript/issues/4731.\n *\n * @experimental\n */\nfunction onProfilingStartRouteTransaction(transaction) {\n  if (!transaction) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log('[Profiling] Transaction is undefined, skipping profiling');\n    }\n    return transaction;\n  }\n  return wrapTransactionWithProfiling(transaction);\n}\n\n/**\n * Wraps startTransaction and stopTransaction with profiling related logic.\n * startProfiling is called after the call to startTransaction in order to avoid our own code from\n * being profiled. Because of that same reason, stopProfiling is called before the call to stopTransaction.\n */\nfunction wrapTransactionWithProfiling(transaction) {\n  // Feature support check first\n  var JSProfilerConstructor = WINDOW.Profiler;\n  if (!isJSProfilerSupported(JSProfilerConstructor)) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log('[Profiling] Profiling is not supported by this browser, Profiler interface missing on window object.');\n    }\n    return transaction;\n  }\n\n  // If constructor failed once, it will always fail, so we can early return.\n  if (PROFILING_CONSTRUCTOR_FAILED) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log('[Profiling] Profiling has been disabled for the duration of the current user session.');\n    }\n    return transaction;\n  }\n  var client = getCurrentHub().getClient();\n  var options = client && client.getOptions();\n  if (!options) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Profiling] Profiling disabled, no options found.');\n    return transaction;\n  }\n\n  // @ts-ignore profilesSampleRate is not part of the browser options yet\n  var profilesSampleRate = options.profilesSampleRate;\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The\n  // only valid values are booleans or numbers between 0 and 1.)\n  if (!isValidSampleRate(profilesSampleRate)) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('[Profiling] Discarding profile because of invalid sample rate.');\n    return transaction;\n  }\n\n  // if the function returned 0 (or false), or if `profileSampleRate` is 0, it's a sign the profile should be dropped\n  if (!profilesSampleRate) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Profiling] Discarding profile because a negative sampling decision was inherited or profileSampleRate is set to 0');\n    return transaction;\n  }\n\n  // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is\n  // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.\n  var sampled = profilesSampleRate === true ? true : Math.random() < profilesSampleRate;\n  // Check if we should sample this profile\n  if (!sampled) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(\"[Profiling] Discarding profile because it's not included in the random sample (sampling rate = \".concat(Number(profilesSampleRate), \")\"));\n    return transaction;\n  }\n\n  // From initial testing, it seems that the minimum value for sampleInterval is 10ms.\n  var samplingIntervalMS = 10;\n  // Start the profiler\n  var maxSamples = Math.floor(MAX_PROFILE_DURATION_MS / samplingIntervalMS);\n  var profiler;\n\n  // Attempt to initialize the profiler constructor, if it fails, we disable profiling for the current user session.\n  // This is likely due to a missing 'Document-Policy': 'js-profiling' header. We do not want to throw an error if this happens\n  // as we risk breaking the user's application, so just disable profiling and log an error.\n  try {\n    profiler = new JSProfilerConstructor({\n      sampleInterval: samplingIntervalMS,\n      maxBufferSize: maxSamples\n    });\n  } catch (e) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log(\"[Profiling] Failed to initialize the Profiling constructor, this is likely due to a missing 'Document-Policy': 'js-profiling' header.\");\n      logger.log('[Profiling] Disabling profiling for current user session.');\n    }\n    PROFILING_CONSTRUCTOR_FAILED = true;\n  }\n\n  // We failed to construct the profiler, fallback to original transaction - there is no need to log\n  // anything as we already did that in the try/catch block.\n  if (!profiler) {\n    return transaction;\n  }\n  if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n    logger.log(\"[Profiling] started profiling transaction: \".concat(transaction.name || transaction.description));\n  }\n\n  // We create \"unique\" transaction names to avoid concurrent transactions with same names\n  // from being ignored by the profiler. From here on, only this transaction name should be used when\n  // calling the profiler methods. Note: we log the original name to the user to avoid confusion.\n  var profileId = uuid4();\n\n  /**\n   * Idempotent handler for profile stop\n   */\n  function onProfileHandler() {\n    return _onProfileHandler.apply(this, arguments);\n  } // Enqueue a timeout to prevent profiles from running over max duration.\n  function _onProfileHandler() {\n    _onProfileHandler = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var stopProfilerSpan;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (transaction) {\n              _context.next = 2;\n              break;\n            }\n            return _context.abrupt(\"return\", null);\n          case 2:\n            if (profiler) {\n              _context.next = 4;\n              break;\n            }\n            return _context.abrupt(\"return\", null);\n          case 4:\n            // This is temporary - we will use the collected span data to evaluate\n            // if deferring txn.finish until profiler resolves is a viable approach.\n            stopProfilerSpan = transaction.startChild({\n              description: 'profiler.stop',\n              op: 'profiler'\n            });\n            return _context.abrupt(\"return\", profiler.stop().then(function (p) {\n              stopProfilerSpan.finish();\n              if (maxDurationTimeoutID) {\n                WINDOW.clearTimeout(maxDurationTimeoutID);\n                maxDurationTimeoutID = undefined;\n              }\n              if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n                logger.log(\"[Profiling] stopped profiling of transaction: \".concat(transaction.name || transaction.description));\n              }\n\n              // In case of an overlapping transaction, stopProfiling may return null and silently ignore the overlapping profile.\n              if (!p) {\n                if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n                  logger.log(\"[Profiling] profiler returned null profile for: \".concat(transaction.name || transaction.description), 'this may indicate an overlapping transaction or a call to stopProfiling with a profile title that was never started');\n                }\n                return null;\n              }\n              addProfileToMap(profileId, p);\n              return null;\n            }).catch(function (error) {\n              stopProfilerSpan.finish();\n              if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n                logger.log('[Profiling] error while stopping profiler:', error);\n              }\n              return null;\n            }));\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return _onProfileHandler.apply(this, arguments);\n  }\n  var maxDurationTimeoutID = WINDOW.setTimeout(function () {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log('[Profiling] max profile duration elapsed, stopping profiling for:', transaction.name || transaction.description);\n    }\n    // If the timeout exceeds, we want to stop profiling, but not finish the transaction\n    void onProfileHandler();\n  }, MAX_PROFILE_DURATION_MS);\n\n  // We need to reference the original finish call to avoid creating an infinite loop\n  var originalFinish = transaction.finish.bind(transaction);\n\n  /**\n   * Wraps startTransaction and stopTransaction with profiling related logic.\n   * startProfiling is called after the call to startTransaction in order to avoid our own code from\n   * being profiled. Because of that same reason, stopProfiling is called before the call to stopTransaction.\n   */\n  function profilingWrappedTransactionFinish() {\n    if (!transaction) {\n      return originalFinish();\n    }\n    // onProfileHandler should always return the same profile even if this is called multiple times.\n    // Always call onProfileHandler to ensure stopProfiling is called and the timeout is cleared.\n    void onProfileHandler().then(function () {\n      transaction.setContext('profile', {\n        profile_id: profileId\n      });\n      originalFinish();\n    }, function () {\n      // If onProfileHandler fails, we still want to call the original finish method.\n      originalFinish();\n    });\n    return transaction;\n  }\n  transaction.finish = profilingWrappedTransactionFinish;\n  return transaction;\n}\nexport { MAX_PROFILE_DURATION_MS, onProfilingStartRouteTransaction, wrapTransactionWithProfiling };","map":{"version":3,"names":["MAX_PROFILE_DURATION_MS","PROFILING_CONSTRUCTOR_FAILED","isJSProfilerSupported","maybeProfiler","onProfilingStartRouteTransaction","transaction","__SENTRY_DEBUG__","logger","log","wrapTransactionWithProfiling","JSProfilerConstructor","WINDOW","Profiler","client","getCurrentHub","getClient","options","getOptions","profilesSampleRate","isValidSampleRate","warn","sampled","Math","random","concat","Number","samplingIntervalMS","maxSamples","floor","profiler","sampleInterval","maxBufferSize","e","name","description","profileId","uuid4","onProfileHandler","_onProfileHandler","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","stopProfilerSpan","wrap","_callee$","_context","prev","next","abrupt","startChild","op","stop","then","p","finish","maxDurationTimeoutID","clearTimeout","undefined","addProfileToMap","catch","error","setTimeout","originalFinish","bind","profilingWrappedTransactionFinish","setContext","profile_id"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/src/profiling/hubextensions.ts"],"sourcesContent":["/* eslint-disable complexity */\nimport { getCurrentHub } from '@sentry/core';\nimport type { Transaction } from '@sentry/types';\nimport { logger, uuid4 } from '@sentry/utils';\n\nimport { WINDOW } from '../helpers';\nimport type { JSSelfProfile, JSSelfProfiler, JSSelfProfilerConstructor } from './jsSelfProfiling';\nimport { addProfileToMap, isValidSampleRate } from './utils';\n\nexport const MAX_PROFILE_DURATION_MS = 30_000;\n// Keep a flag value to avoid re-initializing the profiler constructor. If it fails\n// once, it will always fail and this allows us to early return.\nlet PROFILING_CONSTRUCTOR_FAILED = false;\n\n/**\n * Check if profiler constructor is available.\n * @param maybeProfiler\n */\nfunction isJSProfilerSupported(maybeProfiler: unknown): maybeProfiler is typeof JSSelfProfilerConstructor {\n  return typeof maybeProfiler === 'function';\n}\n\n/**\n * Safety wrapper for startTransaction for the unlikely case that transaction starts before tracing is imported -\n * if that happens we want to avoid throwing an error from profiling code.\n * see https://github.com/getsentry/sentry-javascript/issues/4731.\n *\n * @experimental\n */\nexport function onProfilingStartRouteTransaction(transaction: Transaction | undefined): Transaction | undefined {\n  if (!transaction) {\n    if (__DEBUG_BUILD__) {\n      logger.log('[Profiling] Transaction is undefined, skipping profiling');\n    }\n    return transaction;\n  }\n\n  return wrapTransactionWithProfiling(transaction);\n}\n\n/**\n * Wraps startTransaction and stopTransaction with profiling related logic.\n * startProfiling is called after the call to startTransaction in order to avoid our own code from\n * being profiled. Because of that same reason, stopProfiling is called before the call to stopTransaction.\n */\nexport function wrapTransactionWithProfiling(transaction: Transaction): Transaction {\n  // Feature support check first\n  const JSProfilerConstructor = WINDOW.Profiler;\n\n  if (!isJSProfilerSupported(JSProfilerConstructor)) {\n    if (__DEBUG_BUILD__) {\n      logger.log(\n        '[Profiling] Profiling is not supported by this browser, Profiler interface missing on window object.',\n      );\n    }\n    return transaction;\n  }\n\n  // If constructor failed once, it will always fail, so we can early return.\n  if (PROFILING_CONSTRUCTOR_FAILED) {\n    if (__DEBUG_BUILD__) {\n      logger.log('[Profiling] Profiling has been disabled for the duration of the current user session.');\n    }\n    return transaction;\n  }\n\n  const client = getCurrentHub().getClient();\n  const options = client && client.getOptions();\n  if (!options) {\n    __DEBUG_BUILD__ && logger.log('[Profiling] Profiling disabled, no options found.');\n    return transaction;\n  }\n\n  // @ts-ignore profilesSampleRate is not part of the browser options yet\n  const profilesSampleRate: number | boolean | undefined = options.profilesSampleRate;\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The\n  // only valid values are booleans or numbers between 0 and 1.)\n  if (!isValidSampleRate(profilesSampleRate)) {\n    __DEBUG_BUILD__ && logger.warn('[Profiling] Discarding profile because of invalid sample rate.');\n    return transaction;\n  }\n\n  // if the function returned 0 (or false), or if `profileSampleRate` is 0, it's a sign the profile should be dropped\n  if (!profilesSampleRate) {\n    __DEBUG_BUILD__ &&\n      logger.log(\n        '[Profiling] Discarding profile because a negative sampling decision was inherited or profileSampleRate is set to 0',\n      );\n    return transaction;\n  }\n\n  // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is\n  // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.\n  const sampled = profilesSampleRate === true ? true : Math.random() < profilesSampleRate;\n  // Check if we should sample this profile\n  if (!sampled) {\n    __DEBUG_BUILD__ &&\n      logger.log(\n        `[Profiling] Discarding profile because it's not included in the random sample (sampling rate = ${Number(\n          profilesSampleRate,\n        )})`,\n      );\n    return transaction;\n  }\n\n  // From initial testing, it seems that the minimum value for sampleInterval is 10ms.\n  const samplingIntervalMS = 10;\n  // Start the profiler\n  const maxSamples = Math.floor(MAX_PROFILE_DURATION_MS / samplingIntervalMS);\n  let profiler: JSSelfProfiler | undefined;\n\n  // Attempt to initialize the profiler constructor, if it fails, we disable profiling for the current user session.\n  // This is likely due to a missing 'Document-Policy': 'js-profiling' header. We do not want to throw an error if this happens\n  // as we risk breaking the user's application, so just disable profiling and log an error.\n  try {\n    profiler = new JSProfilerConstructor({ sampleInterval: samplingIntervalMS, maxBufferSize: maxSamples });\n  } catch (e) {\n    if (__DEBUG_BUILD__) {\n      logger.log(\n        \"[Profiling] Failed to initialize the Profiling constructor, this is likely due to a missing 'Document-Policy': 'js-profiling' header.\",\n      );\n      logger.log('[Profiling] Disabling profiling for current user session.');\n    }\n    PROFILING_CONSTRUCTOR_FAILED = true;\n  }\n\n  // We failed to construct the profiler, fallback to original transaction - there is no need to log\n  // anything as we already did that in the try/catch block.\n  if (!profiler) {\n    return transaction;\n  }\n\n  if (__DEBUG_BUILD__) {\n    logger.log(`[Profiling] started profiling transaction: ${transaction.name || transaction.description}`);\n  }\n\n  // We create \"unique\" transaction names to avoid concurrent transactions with same names\n  // from being ignored by the profiler. From here on, only this transaction name should be used when\n  // calling the profiler methods. Note: we log the original name to the user to avoid confusion.\n  const profileId = uuid4();\n\n  // A couple of important things to note here:\n  // `CpuProfilerBindings.stopProfiling` will be scheduled to run in 30seconds in order to exceed max profile duration.\n  // Whichever of the two (transaction.finish/timeout) is first to run, the profiling will be stopped and the gathered profile\n  // will be processed when the original transaction is finished. Since onProfileHandler can be invoked multiple times in the\n  // event of an error or user mistake (calling transaction.finish multiple times), it is important that the behavior of onProfileHandler\n  // is idempotent as we do not want any timings or profiles to be overriden by the last call to onProfileHandler.\n  // After the original finish method is called, the event will be reported through the integration and delegated to transport.\n  const processedProfile: JSSelfProfile | null = null;\n\n  /**\n   * Idempotent handler for profile stop\n   */\n  async function onProfileHandler(): Promise<null> {\n    // Check if the profile exists and return it the behavior has to be idempotent as users may call transaction.finish multiple times.\n    if (!transaction) {\n      return null;\n    }\n    // Satisfy the type checker, but profiler will always be defined here.\n    if (!profiler) {\n      return null;\n    }\n    if (processedProfile) {\n      if (__DEBUG_BUILD__) {\n        logger.log(\n          '[Profiling] profile for:',\n          transaction.name || transaction.description,\n          'already exists, returning early',\n        );\n      }\n      return null;\n    }\n\n    // This is temporary - we will use the collected span data to evaluate\n    // if deferring txn.finish until profiler resolves is a viable approach.\n    const stopProfilerSpan = transaction.startChild({ description: 'profiler.stop', op: 'profiler' });\n\n    return profiler\n      .stop()\n      .then((p: JSSelfProfile): null => {\n        stopProfilerSpan.finish();\n\n        if (maxDurationTimeoutID) {\n          WINDOW.clearTimeout(maxDurationTimeoutID);\n          maxDurationTimeoutID = undefined;\n        }\n\n        if (__DEBUG_BUILD__) {\n          logger.log(`[Profiling] stopped profiling of transaction: ${transaction.name || transaction.description}`);\n        }\n\n        // In case of an overlapping transaction, stopProfiling may return null and silently ignore the overlapping profile.\n        if (!p) {\n          if (__DEBUG_BUILD__) {\n            logger.log(\n              `[Profiling] profiler returned null profile for: ${transaction.name || transaction.description}`,\n              'this may indicate an overlapping transaction or a call to stopProfiling with a profile title that was never started',\n            );\n          }\n          return null;\n        }\n\n        addProfileToMap(profileId, p);\n        return null;\n      })\n      .catch(error => {\n        stopProfilerSpan.finish();\n        if (__DEBUG_BUILD__) {\n          logger.log('[Profiling] error while stopping profiler:', error);\n        }\n        return null;\n      });\n  }\n\n  // Enqueue a timeout to prevent profiles from running over max duration.\n  let maxDurationTimeoutID: number | undefined = WINDOW.setTimeout(() => {\n    if (__DEBUG_BUILD__) {\n      logger.log(\n        '[Profiling] max profile duration elapsed, stopping profiling for:',\n        transaction.name || transaction.description,\n      );\n    }\n    // If the timeout exceeds, we want to stop profiling, but not finish the transaction\n    void onProfileHandler();\n  }, MAX_PROFILE_DURATION_MS);\n\n  // We need to reference the original finish call to avoid creating an infinite loop\n  const originalFinish = transaction.finish.bind(transaction);\n\n  /**\n   * Wraps startTransaction and stopTransaction with profiling related logic.\n   * startProfiling is called after the call to startTransaction in order to avoid our own code from\n   * being profiled. Because of that same reason, stopProfiling is called before the call to stopTransaction.\n   */\n  function profilingWrappedTransactionFinish(): Transaction {\n    if (!transaction) {\n      return originalFinish();\n    }\n    // onProfileHandler should always return the same profile even if this is called multiple times.\n    // Always call onProfileHandler to ensure stopProfiling is called and the timeout is cleared.\n    void onProfileHandler().then(\n      () => {\n        transaction.setContext('profile', { profile_id: profileId });\n        originalFinish();\n      },\n      () => {\n        // If onProfileHandler fails, we still want to call the original finish method.\n        originalFinish();\n      },\n    );\n\n    return transaction;\n  }\n\n  transaction.finish = profilingWrappedTransactionFinish;\n  return transaction;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}