{"ast":null,"code":"/**\n * Parses string form of URL into an object\n * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B\n * // intentionally using regex and not <a/> href parsing trick because React Native and other\n * // environments where DOM might not be available\n * @returns parsed URL object\n */\nfunction parseUrl(url) {\n  if (!url) {\n    return {};\n  }\n  const match = url.match(/^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\n  if (!match) {\n    return {};\n  }\n\n  // coerce to undefined values to empty string so we don't get 'undefined'\n  const query = match[6] || '';\n  const fragment = match[8] || '';\n  return {\n    host: match[4],\n    path: match[5],\n    protocol: match[2],\n    search: query,\n    hash: fragment,\n    relative: match[5] + query + fragment // everything minus origin\n  };\n}\n\n/**\n * Strip the query string and fragment off of a given URL or path (if present)\n *\n * @param urlPath Full URL or path, including possible query string and/or fragment\n * @returns URL or path without query string or fragment\n */\nfunction stripUrlQueryAndFragment(urlPath) {\n  // eslint-disable-next-line no-useless-escape\n  return urlPath.split(/[\\?#]/, 1)[0];\n}\n\n/**\n * Returns number of URL segments of a passed string URL.\n */\nfunction getNumberOfUrlSegments(url) {\n  // split at '/' or at '\\/' to split regex urls correctly\n  return url.split(/\\\\?\\//).filter(s => s.length > 0 && s !== ',').length;\n}\n\n/**\n * Takes a URL object and returns a sanitized string which is safe to use as span description\n * see: https://develop.sentry.dev/sdk/data-handling/#structuring-data\n */\nfunction getSanitizedUrlString(url) {\n  const {\n    protocol,\n    host,\n    path\n  } = url;\n  const filteredHost = host && host\n  // Always filter out authority\n  .replace(/^.*@/, '[filtered]:[filtered]@')\n  // Don't show standard :80 (http) and :443 (https) ports to reduce the noise\n  .replace(':80', '').replace(':443', '') || '';\n  return `${protocol ? `${protocol}://` : ''}${filteredHost}${path}`;\n}\nexport { getNumberOfUrlSegments, getSanitizedUrlString, parseUrl, stripUrlQueryAndFragment };","map":{"version":3,"names":["parseUrl","url","match","query","fragment","host","path","protocol","search","hash","relative","stripUrlQueryAndFragment","urlPath","split","getNumberOfUrlSegments","filter","s","length","getSanitizedUrlString","filteredHost","replace"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/url.ts"],"sourcesContent":["type PartialURL = {\n  host?: string;\n  path?: string;\n  protocol?: string;\n  relative?: string;\n  search?: string;\n  hash?: string;\n};\n\n/**\n * Parses string form of URL into an object\n * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B\n * // intentionally using regex and not <a/> href parsing trick because React Native and other\n * // environments where DOM might not be available\n * @returns parsed URL object\n */\nexport function parseUrl(url: string): PartialURL {\n  if (!url) {\n    return {};\n  }\n\n  const match = url.match(/^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\n\n  if (!match) {\n    return {};\n  }\n\n  // coerce to undefined values to empty string so we don't get 'undefined'\n  const query = match[6] || '';\n  const fragment = match[8] || '';\n  return {\n    host: match[4],\n    path: match[5],\n    protocol: match[2],\n    search: query,\n    hash: fragment,\n    relative: match[5] + query + fragment, // everything minus origin\n  };\n}\n\n/**\n * Strip the query string and fragment off of a given URL or path (if present)\n *\n * @param urlPath Full URL or path, including possible query string and/or fragment\n * @returns URL or path without query string or fragment\n */\nexport function stripUrlQueryAndFragment(urlPath: string): string {\n  // eslint-disable-next-line no-useless-escape\n  return urlPath.split(/[\\?#]/, 1)[0];\n}\n\n/**\n * Returns number of URL segments of a passed string URL.\n */\nexport function getNumberOfUrlSegments(url: string): number {\n  // split at '/' or at '\\/' to split regex urls correctly\n  return url.split(/\\\\?\\//).filter(s => s.length > 0 && s !== ',').length;\n}\n\n/**\n * Takes a URL object and returns a sanitized string which is safe to use as span description\n * see: https://develop.sentry.dev/sdk/data-handling/#structuring-data\n */\nexport function getSanitizedUrlString(url: PartialURL): string {\n  const { protocol, host, path } = url;\n\n  const filteredHost =\n    (host &&\n      host\n        // Always filter out authority\n        .replace(/^.*@/, '[filtered]:[filtered]@')\n        // Don't show standard :80 (http) and :443 (https) ports to reduce the noise\n        .replace(':80', '')\n        .replace(':443', '')) ||\n    '';\n\n  return `${protocol ? `${protocol}://` : ''}${filteredHost}${path}`;\n}\n"],"mappings":"AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAAA,SAAAC,GAAA;EACA,KAAAA,GAAA;IACA;EACA;EAEA,MAAAC,KAAA,GAAAD,GAAA,CAAAC,KAAA;EAEA,KAAAA,KAAA;IACA;EACA;;EAEA;EACA,MAAAC,KAAA,GAAAD,KAAA;EACA,MAAAE,QAAA,GAAAF,KAAA;EACA;IACAG,IAAA,EAAAH,KAAA;IACAI,IAAA,EAAAJ,KAAA;IACAK,QAAA,EAAAL,KAAA;IACAM,MAAA,EAAAL,KAAA;IACAM,IAAA,EAAAL,QAAA;IACAM,QAAA,EAAAR,KAAA,MAAAC,KAAA,GAAAC,QAAA;EACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAAO,yBAAAC,OAAA;EACA;EACA,OAAAA,OAAA,CAAAC,KAAA;AACA;;AAEA;AACA;AACA;AACA,SAAAC,uBAAAb,GAAA;EACA;EACA,OAAAA,GAAA,CAAAY,KAAA,UAAAE,MAAA,CAAAC,CAAA,IAAAA,CAAA,CAAAC,MAAA,QAAAD,CAAA,UAAAC,MAAA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAAC,sBAAAjB,GAAA;EACA;IAAAM,QAAA;IAAAF,IAAA;IAAAC;EAAA,IAAAL,GAAA;EAEA,MAAAkB,YAAA,GACAd,IAAA,IACAA;EACA;EAAA,CACAe,OAAA;EACA;EAAA,CACAA,OAAA,YACAA,OAAA,gBACA;EAEA,UAAAb,QAAA,MAAAA,QAAA,aAAAY,YAAA,GAAAb,IAAA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}