{"ast":null,"code":"import _objectSpread from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { node } from './node-stack-trace.js';\nvar STACKTRACE_FRAME_LIMIT = 50;\n// Used to sanitize webpack (error: *) wrapped stack errors\nvar WEBPACK_ERROR_REGEXP = /\\(error: (.*)\\)/;\n\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nfunction createStackParser() {\n  for (var _len = arguments.length, parsers = new Array(_len), _key = 0; _key < _len; _key++) {\n    parsers[_key] = arguments[_key];\n  }\n  var sortedParsers = parsers.sort(function (a, b) {\n    return a[0] - b[0];\n  }).map(function (p) {\n    return p[1];\n  });\n  return function (stack) {\n    var skipFirst = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var frames = [];\n    var lines = stack.split('\\n');\n    for (var i = skipFirst; i < lines.length; i++) {\n      var line = lines[i];\n      // Ignore lines over 1kb as they are unlikely to be stack frames.\n      // Many of the regular expressions use backtracking which results in run time that increases exponentially with\n      // input size. Huge strings can result in hangs/Denial of Service:\n      // https://github.com/getsentry/sentry-javascript/issues/2286\n      if (line.length > 1024) {\n        continue;\n      }\n\n      // https://github.com/getsentry/sentry-javascript/issues/5459\n      // Remove webpack (error: *) wrappers\n      var cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, '$1') : line;\n\n      // https://github.com/getsentry/sentry-javascript/issues/7813\n      // Skip Error: lines\n      if (cleanedLine.match(/\\S*Error: /)) {\n        continue;\n      }\n      var _iterator = _createForOfIteratorHelper(sortedParsers),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var parser = _step.value;\n          var frame = parser(cleanedLine);\n          if (frame) {\n            frames.push(frame);\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (frames.length >= STACKTRACE_FRAME_LIMIT) {\n        break;\n      }\n    }\n    return stripSentryFramesAndReverse(frames);\n  };\n}\n\n/**\n * Gets a stack parser implementation from Options.stackParser\n * @see Options\n *\n * If options contains an array of line parsers, it is converted into a parser\n */\nfunction stackParserFromStackParserOptions(stackParser) {\n  if (Array.isArray(stackParser)) {\n    return createStackParser.apply(void 0, _toConsumableArray(stackParser));\n  }\n  return stackParser;\n}\n\n/**\n * Removes Sentry frames from the top and bottom of the stack if present and enforces a limit of max number of frames.\n * Assumes stack input is ordered from top to bottom and returns the reverse representation so call site of the\n * function that caused the crash is the last frame in the array.\n * @hidden\n */\nfunction stripSentryFramesAndReverse(stack) {\n  if (!stack.length) {\n    return [];\n  }\n  var localStack = stack.slice(0, STACKTRACE_FRAME_LIMIT);\n  var lastFrameFunction = localStack[localStack.length - 1].function;\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (lastFrameFunction && /sentryWrapped/.test(lastFrameFunction)) {\n    localStack.pop();\n  }\n\n  // Reversing in the middle of the procedure allows us to just pop the values off the stack\n  localStack.reverse();\n  var firstFrameFunction = localStack[localStack.length - 1].function;\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (firstFrameFunction && /captureMessage|captureException/.test(firstFrameFunction)) {\n    localStack.pop();\n  }\n  return localStack.map(function (frame) {\n    return _objectSpread(_objectSpread({}, frame), {}, {\n      filename: frame.filename || localStack[localStack.length - 1].filename,\n      function: frame.function || '?'\n    });\n  });\n}\nvar defaultFunctionName = '<anonymous>';\n\n/**\n * Safely extract function name from itself\n */\nfunction getFunctionName(fn) {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}\n\n/**\n * Node.js stack line parser\n *\n * This is in @sentry/utils so it can be used from the Electron SDK in the browser for when `nodeIntegration == true`.\n * This allows it to be used without referencing or importing any node specific code which causes bundlers to complain\n */\nfunction nodeStackLineParser(getModule) {\n  return [90, node(getModule)];\n}\nexport { createStackParser, getFunctionName, nodeStackLineParser, stackParserFromStackParserOptions, stripSentryFramesAndReverse };","map":{"version":3,"names":["STACKTRACE_FRAME_LIMIT","WEBPACK_ERROR_REGEXP","createStackParser","_len","arguments","length","parsers","Array","_key","sortedParsers","sort","a","b","map","p","stack","skipFirst","undefined","frames","lines","split","i","line","cleanedLine","test","replace","match","_iterator","_createForOfIteratorHelper","_step","s","n","done","parser","value","frame","push","err","e","f","stripSentryFramesAndReverse","stackParserFromStackParserOptions","stackParser","isArray","apply","_toConsumableArray","localStack","slice","lastFrameFunction","function","pop","reverse","firstFrameFunction","_objectSpread","filename","defaultFunctionName","getFunctionName","fn","name","nodeStackLineParser","getModule","node"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/stacktrace.ts"],"sourcesContent":["import type { StackFrame, StackLineParser, StackParser } from '@sentry/types';\n\nimport type { GetModuleFn } from './node-stack-trace';\nimport { node } from './node-stack-trace';\n\nconst STACKTRACE_FRAME_LIMIT = 50;\n// Used to sanitize webpack (error: *) wrapped stack errors\nconst WEBPACK_ERROR_REGEXP = /\\(error: (.*)\\)/;\n\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nexport function createStackParser(...parsers: StackLineParser[]): StackParser {\n  const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);\n\n  return (stack: string, skipFirst: number = 0): StackFrame[] => {\n    const frames: StackFrame[] = [];\n    const lines = stack.split('\\n');\n\n    for (let i = skipFirst; i < lines.length; i++) {\n      const line = lines[i];\n      // Ignore lines over 1kb as they are unlikely to be stack frames.\n      // Many of the regular expressions use backtracking which results in run time that increases exponentially with\n      // input size. Huge strings can result in hangs/Denial of Service:\n      // https://github.com/getsentry/sentry-javascript/issues/2286\n      if (line.length > 1024) {\n        continue;\n      }\n\n      // https://github.com/getsentry/sentry-javascript/issues/5459\n      // Remove webpack (error: *) wrappers\n      const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, '$1') : line;\n\n      // https://github.com/getsentry/sentry-javascript/issues/7813\n      // Skip Error: lines\n      if (cleanedLine.match(/\\S*Error: /)) {\n        continue;\n      }\n\n      for (const parser of sortedParsers) {\n        const frame = parser(cleanedLine);\n\n        if (frame) {\n          frames.push(frame);\n          break;\n        }\n      }\n\n      if (frames.length >= STACKTRACE_FRAME_LIMIT) {\n        break;\n      }\n    }\n\n    return stripSentryFramesAndReverse(frames);\n  };\n}\n\n/**\n * Gets a stack parser implementation from Options.stackParser\n * @see Options\n *\n * If options contains an array of line parsers, it is converted into a parser\n */\nexport function stackParserFromStackParserOptions(stackParser: StackParser | StackLineParser[]): StackParser {\n  if (Array.isArray(stackParser)) {\n    return createStackParser(...stackParser);\n  }\n  return stackParser;\n}\n\n/**\n * Removes Sentry frames from the top and bottom of the stack if present and enforces a limit of max number of frames.\n * Assumes stack input is ordered from top to bottom and returns the reverse representation so call site of the\n * function that caused the crash is the last frame in the array.\n * @hidden\n */\nexport function stripSentryFramesAndReverse(stack: ReadonlyArray<StackFrame>): StackFrame[] {\n  if (!stack.length) {\n    return [];\n  }\n\n  const localStack = stack.slice(0, STACKTRACE_FRAME_LIMIT);\n\n  const lastFrameFunction = localStack[localStack.length - 1].function;\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (lastFrameFunction && /sentryWrapped/.test(lastFrameFunction)) {\n    localStack.pop();\n  }\n\n  // Reversing in the middle of the procedure allows us to just pop the values off the stack\n  localStack.reverse();\n\n  const firstFrameFunction = localStack[localStack.length - 1].function;\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (firstFrameFunction && /captureMessage|captureException/.test(firstFrameFunction)) {\n    localStack.pop();\n  }\n\n  return localStack.map(frame => ({\n    ...frame,\n    filename: frame.filename || localStack[localStack.length - 1].filename,\n    function: frame.function || '?',\n  }));\n}\n\nconst defaultFunctionName = '<anonymous>';\n\n/**\n * Safely extract function name from itself\n */\nexport function getFunctionName(fn: unknown): string {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}\n\n/**\n * Node.js stack line parser\n *\n * This is in @sentry/utils so it can be used from the Electron SDK in the browser for when `nodeIntegration == true`.\n * This allows it to be used without referencing or importing any node specific code which causes bundlers to complain\n */\nexport function nodeStackLineParser(getModule?: GetModuleFn): StackLineParser {\n  return [90, node(getModule)];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}