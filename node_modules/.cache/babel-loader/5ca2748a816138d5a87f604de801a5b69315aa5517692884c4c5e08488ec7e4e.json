{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _defineProperty from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { DEFAULT_ENVIRONMENT, getCurrentHub } from '@sentry/core';\nimport { forEachEnvelopeItem, logger, uuid4, GLOBAL_OBJ } from '@sentry/utils';\nimport { WINDOW } from '../helpers.js';\n\n/* eslint-disable max-lines */\n\nvar MS_TO_NS = 1e6;\n// Use 0 as main thread id which is identical to threadId in node:worker_threads\n// where main logs 0 and workers seem to log in increments of 1\nvar THREAD_ID_STRING = String(0);\nvar THREAD_NAME = 'main';\n\n// Machine properties (eval only once)\nvar OS_PLATFORM = '';\nvar OS_PLATFORM_VERSION = '';\nvar OS_ARCH = '';\nvar OS_BROWSER = WINDOW.navigator && WINDOW.navigator.userAgent || '';\nvar OS_MODEL = '';\nvar OS_LOCALE = WINDOW.navigator && WINDOW.navigator.language || WINDOW.navigator && WINDOW.navigator.languages && WINDOW.navigator.languages[0] || '';\nfunction isUserAgentData(data) {\n  return typeof data === 'object' && data !== null && 'getHighEntropyValues' in data;\n}\n\n// @ts-ignore userAgentData is not part of the navigator interface yet\nvar userAgentData = WINDOW.navigator && WINDOW.navigator.userAgentData;\nif (isUserAgentData(userAgentData)) {\n  userAgentData.getHighEntropyValues(['architecture', 'model', 'platform', 'platformVersion', 'fullVersionList']).then(function (ua) {\n    OS_PLATFORM = ua.platform || '';\n    OS_ARCH = ua.architecture || '';\n    OS_MODEL = ua.model || '';\n    OS_PLATFORM_VERSION = ua.platformVersion || '';\n    if (ua.fullVersionList && ua.fullVersionList.length > 0) {\n      var firstUa = ua.fullVersionList[ua.fullVersionList.length - 1];\n      OS_BROWSER = \"\".concat(firstUa.brand, \" \").concat(firstUa.version);\n    }\n  }).catch(function (e) {\n    return void e;\n  });\n}\nfunction isProcessedJSSelfProfile(profile) {\n  return !('thread_metadata' in profile);\n}\n\n// Enriches the profile with threadId of the current thread.\n// This is done in node as we seem to not be able to get the info from C native code.\n/**\n *\n */\nfunction enrichWithThreadInformation(profile) {\n  if (!isProcessedJSSelfProfile(profile)) {\n    return profile;\n  }\n  return convertJSSelfProfileToSampledFormat(profile);\n}\n\n// Profile is marked as optional because it is deleted from the metadata\n// by the integration before the event is processed by other integrations.\n\nfunction getTraceId(event) {\n  var traceId = event && event.contexts && event.contexts['trace'] && event.contexts['trace']['trace_id'];\n  // Log a warning if the profile has an invalid traceId (should be uuidv4).\n  // All profiles and transactions are rejected if this is the case and we want to\n  // warn users that this is happening if they enable debug flag\n  if (typeof traceId === 'string' && traceId.length !== 32) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log(\"[Profiling] Invalid traceId: \".concat(traceId, \" on profiled event\"));\n    }\n  }\n  if (typeof traceId !== 'string') {\n    return '';\n  }\n  return traceId;\n}\n/**\n * Creates a profiling event envelope from a Sentry event. If profile does not pass\n * validation, returns null.\n * @param event\n * @param dsn\n * @param metadata\n * @param tunnel\n * @returns {EventEnvelope | null}\n */\n\n/**\n * Creates a profiling event envelope from a Sentry event.\n */\nfunction createProfilePayload(event, processedProfile, profile_id) {\n  if (event.type !== 'transaction') {\n    // createProfilingEventEnvelope should only be called for transactions,\n    // we type guard this behavior with isProfiledTransactionEvent.\n    throw new TypeError('Profiling events may only be attached to transactions, this should never occur.');\n  }\n  if (processedProfile === undefined || processedProfile === null) {\n    throw new TypeError(\"Cannot construct profiling event envelope without a valid profile. Got \".concat(processedProfile, \" instead.\"));\n  }\n  var traceId = getTraceId(event);\n  var enrichedThreadProfile = enrichWithThreadInformation(processedProfile);\n  var transactionStartMs = typeof event.start_timestamp === 'number' ? event.start_timestamp * 1000 : Date.now();\n  var transactionEndMs = typeof event.timestamp === 'number' ? event.timestamp * 1000 : Date.now();\n  var profile = {\n    event_id: profile_id,\n    timestamp: new Date(transactionStartMs).toISOString(),\n    platform: 'javascript',\n    version: '1',\n    release: event.release || '',\n    environment: event.environment || DEFAULT_ENVIRONMENT,\n    runtime: {\n      name: 'javascript',\n      version: WINDOW.navigator.userAgent\n    },\n    os: {\n      name: OS_PLATFORM,\n      version: OS_PLATFORM_VERSION,\n      build_number: OS_BROWSER\n    },\n    device: {\n      locale: OS_LOCALE,\n      model: OS_MODEL,\n      manufacturer: OS_BROWSER,\n      architecture: OS_ARCH,\n      is_emulator: false\n    },\n    debug_meta: {\n      images: applyDebugMetadata(processedProfile.resources)\n    },\n    profile: enrichedThreadProfile,\n    transactions: [{\n      name: event.transaction || '',\n      id: event.event_id || uuid4(),\n      trace_id: traceId,\n      active_thread_id: THREAD_ID_STRING,\n      relative_start_ns: '0',\n      relative_end_ns: ((transactionEndMs - transactionStartMs) * 1e6).toFixed(0)\n    }]\n  };\n  return profile;\n}\n\n/**\n * Converts a JSSelfProfile to a our sampled format.\n * Does not currently perform stack indexing.\n */\nfunction convertJSSelfProfileToSampledFormat(input) {\n  var EMPTY_STACK_ID = undefined;\n  var STACK_ID = 0;\n\n  // Initialize the profile that we will fill with data\n  var profile = {\n    samples: [],\n    stacks: [],\n    frames: [],\n    thread_metadata: _defineProperty({}, THREAD_ID_STRING, {\n      name: THREAD_NAME\n    })\n  };\n  if (!input.samples.length) {\n    return profile;\n  }\n\n  // We assert samples.length > 0 above and timestamp should always be present\n  var start = input.samples[0].timestamp;\n  for (var i = 0; i < input.samples.length; i++) {\n    var jsSample = input.samples[i];\n\n    // If sample has no stack, add an empty sample\n    if (jsSample.stackId === undefined) {\n      if (EMPTY_STACK_ID === undefined) {\n        EMPTY_STACK_ID = STACK_ID;\n        profile.stacks[EMPTY_STACK_ID] = [];\n        STACK_ID++;\n      }\n      profile['samples'][i] = {\n        // convert ms timestamp to ns\n        elapsed_since_start_ns: ((jsSample.timestamp - start) * MS_TO_NS).toFixed(0),\n        stack_id: EMPTY_STACK_ID,\n        thread_id: THREAD_ID_STRING\n      };\n      continue;\n    }\n    var stackTop = input.stacks[jsSample.stackId];\n\n    // Functions in top->down order (root is last)\n    // We follow the stackTop.parentId trail and collect each visited frameId\n    var stack = [];\n    while (stackTop) {\n      stack.push(stackTop.frameId);\n      var frame = input.frames[stackTop.frameId];\n\n      // If our frame has not been indexed yet, index it\n      if (profile.frames[stackTop.frameId] === undefined) {\n        profile.frames[stackTop.frameId] = {\n          function: frame.name,\n          file: frame.resourceId ? input.resources[frame.resourceId] : undefined,\n          line: frame.line,\n          column: frame.column\n        };\n      }\n      stackTop = stackTop.parentId === undefined ? undefined : input.stacks[stackTop.parentId];\n    }\n    var sample = {\n      // convert ms timestamp to ns\n      elapsed_since_start_ns: ((jsSample.timestamp - start) * MS_TO_NS).toFixed(0),\n      stack_id: STACK_ID,\n      thread_id: THREAD_ID_STRING\n    };\n    profile['stacks'][STACK_ID] = stack;\n    profile['samples'][i] = sample;\n    STACK_ID++;\n  }\n  return profile;\n}\n\n/**\n * Adds items to envelope if they are not already present - mutates the envelope.\n * @param envelope\n */\nfunction addProfilesToEnvelope(envelope, profiles) {\n  if (!profiles.length) {\n    return envelope;\n  }\n  var _iterator = _createForOfIteratorHelper(profiles),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var profile = _step.value;\n      // @ts-ignore untyped envelope\n      envelope[1].push([{\n        type: 'profile'\n      }, profile]);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return envelope;\n}\n\n/**\n * Finds transactions with profile_id context in the envelope\n * @param envelope\n * @returns\n */\nfunction findProfiledTransactionsFromEnvelope(envelope) {\n  var events = [];\n  forEachEnvelopeItem(envelope, function (item, type) {\n    if (type !== 'transaction') {\n      return;\n    }\n    for (var j = 1; j < item.length; j++) {\n      var event = item[j];\n      if (event && event.contexts && event.contexts['profile'] && event.contexts['profile']['profile_id']) {\n        events.push(item[j]);\n      }\n    }\n  });\n  return events;\n}\nvar debugIdStackParserCache = new WeakMap();\n/**\n * Applies debug meta data to an event from a list of paths to resources (sourcemaps)\n */\nfunction applyDebugMetadata(resource_paths) {\n  var debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n  if (!debugIdMap) {\n    return [];\n  }\n  var hub = getCurrentHub();\n  if (!hub) {\n    return [];\n  }\n  var client = hub.getClient();\n  if (!client) {\n    return [];\n  }\n  var options = client.getOptions();\n  if (!options) {\n    return [];\n  }\n  var stackParser = options.stackParser;\n  if (!stackParser) {\n    return [];\n  }\n  var debugIdStackFramesCache;\n  var cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);\n  if (cachedDebugIdStackFrameCache) {\n    debugIdStackFramesCache = cachedDebugIdStackFrameCache;\n  } else {\n    debugIdStackFramesCache = new Map();\n    debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);\n  }\n\n  // Build a map of filename -> debug_id\n  var filenameDebugIdMap = Object.keys(debugIdMap).reduce(function (acc, debugIdStackTrace) {\n    var parsedStack;\n    var cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);\n    if (cachedParsedStack) {\n      parsedStack = cachedParsedStack;\n    } else {\n      parsedStack = stackParser(debugIdStackTrace);\n      debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);\n    }\n    for (var i = parsedStack.length - 1; i >= 0; i--) {\n      var stackFrame = parsedStack[i];\n      var file = stackFrame && stackFrame.filename;\n      if (stackFrame && file) {\n        acc[file] = debugIdMap[debugIdStackTrace];\n        break;\n      }\n    }\n    return acc;\n  }, {});\n  var images = [];\n  var _iterator2 = _createForOfIteratorHelper(resource_paths),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var path = _step2.value;\n      if (path && filenameDebugIdMap[path]) {\n        images.push({\n          type: 'sourcemap',\n          code_file: path,\n          debug_id: filenameDebugIdMap[path]\n        });\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return images;\n}\n\n/**\n * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).\n */\nfunction isValidSampleRate(rate) {\n  // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck\n  if (typeof rate !== 'number' && typeof rate !== 'boolean' || typeof rate === 'number' && isNaN(rate)) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(\"[Profiling] Invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got \".concat(JSON.stringify(rate), \" of type \").concat(JSON.stringify(typeof rate), \".\"));\n    return false;\n  }\n\n  // Boolean sample rates are always valid\n  if (rate === true || rate === false) {\n    return true;\n  }\n\n  // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false\n  if (rate < 0 || rate > 1) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(\"[Profiling] Invalid sample rate. Sample rate must be between 0 and 1. Got \".concat(rate, \".\"));\n    return false;\n  }\n  return true;\n}\nfunction isValidProfile(profile) {\n  if (profile.samples.length < 2) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      // Log a warning if the profile has less than 2 samples so users can know why\n      // they are not seeing any profiling data and we cant avoid the back and forth\n      // of asking them to provide us with a dump of the profile data.\n      logger.log('[Profiling] Discarding profile because it contains less than 2 samples');\n    }\n    return false;\n  }\n  if (!profile.frames.length) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log('[Profiling] Discarding profile because it contains no frames');\n    }\n    return false;\n  }\n  return true;\n}\n\n/**\n * Creates a profiling envelope item, if the profile does not pass validation, returns null.\n * @param event\n * @returns {Profile | null}\n */\nfunction createProfilingEvent(profile_id, profile, event) {\n  if (!isValidProfile(profile)) {\n    return null;\n  }\n  return createProfilePayload(event, profile, profile_id);\n}\nvar PROFILE_MAP = new Map();\n/**\n *\n */\nfunction addProfileToMap(profile_id, profile) {\n  PROFILE_MAP.set(profile_id, profile);\n  if (PROFILE_MAP.size > 30) {\n    var last = PROFILE_MAP.keys().next().value;\n    PROFILE_MAP.delete(last);\n  }\n}\nexport { PROFILE_MAP, addProfileToMap, addProfilesToEnvelope, applyDebugMetadata, convertJSSelfProfileToSampledFormat, createProfilePayload, createProfilingEvent, enrichWithThreadInformation, findProfiledTransactionsFromEnvelope, isValidSampleRate };","map":{"version":3,"names":["MS_TO_NS","THREAD_ID_STRING","String","THREAD_NAME","OS_PLATFORM","OS_PLATFORM_VERSION","OS_ARCH","OS_BROWSER","WINDOW","navigator","userAgent","OS_MODEL","OS_LOCALE","language","languages","isUserAgentData","data","userAgentData","getHighEntropyValues","then","ua","platform","architecture","model","platformVersion","fullVersionList","length","firstUa","concat","brand","version","catch","e","isProcessedJSSelfProfile","profile","enrichWithThreadInformation","convertJSSelfProfileToSampledFormat","getTraceId","event","traceId","contexts","__SENTRY_DEBUG__","logger","log","createProfilePayload","processedProfile","profile_id","type","TypeError","undefined","enrichedThreadProfile","transactionStartMs","start_timestamp","Date","now","transactionEndMs","timestamp","event_id","toISOString","release","environment","DEFAULT_ENVIRONMENT","runtime","name","os","build_number","device","locale","manufacturer","is_emulator","debug_meta","images","applyDebugMetadata","resources","transactions","transaction","id","uuid4","trace_id","active_thread_id","relative_start_ns","relative_end_ns","toFixed","input","EMPTY_STACK_ID","STACK_ID","samples","stacks","frames","thread_metadata","_defineProperty","start","i","jsSample","stackId","elapsed_since_start_ns","stack_id","thread_id","stackTop","stack","push","frameId","frame","function","file","resourceId","line","column","parentId","sample","addProfilesToEnvelope","envelope","profiles","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","err","f","findProfiledTransactionsFromEnvelope","events","forEachEnvelopeItem","item","j","debugIdStackParserCache","WeakMap","resource_paths","debugIdMap","GLOBAL_OBJ","_sentryDebugIds","hub","getCurrentHub","client","getClient","options","getOptions","stackParser","debugIdStackFramesCache","cachedDebugIdStackFrameCache","get","Map","set","filenameDebugIdMap","Object","keys","reduce","acc","debugIdStackTrace","parsedStack","cachedParsedStack","stackFrame","filename","_iterator2","_step2","path","code_file","debug_id","isValidSampleRate","rate","isNaN","warn","JSON","stringify","isValidProfile","createProfilingEvent","PROFILE_MAP","addProfileToMap","size","last","next","delete"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/src/profiling/utils.ts"],"sourcesContent":["/* eslint-disable max-lines */\n\nimport { DEFAULT_ENVIRONMENT, getCurrentHub } from '@sentry/core';\nimport type { DebugImage, Envelope, Event, StackFrame, StackParser } from '@sentry/types';\nimport type { Profile, ThreadCpuProfile } from '@sentry/types/src/profiling';\nimport { forEachEnvelopeItem, GLOBAL_OBJ, logger, uuid4 } from '@sentry/utils';\n\nimport { WINDOW } from '../helpers';\nimport type { JSSelfProfile, JSSelfProfileStack } from './jsSelfProfiling';\n\nconst MS_TO_NS = 1e6;\n// Use 0 as main thread id which is identical to threadId in node:worker_threads\n// where main logs 0 and workers seem to log in increments of 1\nconst THREAD_ID_STRING = String(0);\nconst THREAD_NAME = 'main';\n\n// Machine properties (eval only once)\nlet OS_PLATFORM = '';\nlet OS_PLATFORM_VERSION = '';\nlet OS_ARCH = '';\nlet OS_BROWSER = (WINDOW.navigator && WINDOW.navigator.userAgent) || '';\nlet OS_MODEL = '';\nconst OS_LOCALE =\n  (WINDOW.navigator && WINDOW.navigator.language) ||\n  (WINDOW.navigator && WINDOW.navigator.languages && WINDOW.navigator.languages[0]) ||\n  '';\n\ntype UAData = {\n  platform?: string;\n  architecture?: string;\n  model?: string;\n  platformVersion?: string;\n  fullVersionList?: {\n    brand: string;\n    version: string;\n  }[];\n};\n\ninterface UserAgentData {\n  getHighEntropyValues: (keys: string[]) => Promise<UAData>;\n}\n\nfunction isUserAgentData(data: unknown): data is UserAgentData {\n  return typeof data === 'object' && data !== null && 'getHighEntropyValues' in data;\n}\n\n// @ts-ignore userAgentData is not part of the navigator interface yet\nconst userAgentData = WINDOW.navigator && WINDOW.navigator.userAgentData;\n\nif (isUserAgentData(userAgentData)) {\n  userAgentData\n    .getHighEntropyValues(['architecture', 'model', 'platform', 'platformVersion', 'fullVersionList'])\n    .then((ua: UAData) => {\n      OS_PLATFORM = ua.platform || '';\n      OS_ARCH = ua.architecture || '';\n      OS_MODEL = ua.model || '';\n      OS_PLATFORM_VERSION = ua.platformVersion || '';\n\n      if (ua.fullVersionList && ua.fullVersionList.length > 0) {\n        const firstUa = ua.fullVersionList[ua.fullVersionList.length - 1];\n        OS_BROWSER = `${firstUa.brand} ${firstUa.version}`;\n      }\n    })\n    .catch(e => void e);\n}\n\nfunction isProcessedJSSelfProfile(profile: ThreadCpuProfile | JSSelfProfile): profile is JSSelfProfile {\n  return !('thread_metadata' in profile);\n}\n\n// Enriches the profile with threadId of the current thread.\n// This is done in node as we seem to not be able to get the info from C native code.\n/**\n *\n */\nexport function enrichWithThreadInformation(profile: ThreadCpuProfile | JSSelfProfile): ThreadCpuProfile {\n  if (!isProcessedJSSelfProfile(profile)) {\n    return profile;\n  }\n\n  return convertJSSelfProfileToSampledFormat(profile);\n}\n\n// Profile is marked as optional because it is deleted from the metadata\n// by the integration before the event is processed by other integrations.\nexport interface ProfiledEvent extends Event {\n  sdkProcessingMetadata: {\n    profile?: JSSelfProfile;\n  };\n}\n\nfunction getTraceId(event: Event): string {\n  const traceId: unknown = event && event.contexts && event.contexts['trace'] && event.contexts['trace']['trace_id'];\n  // Log a warning if the profile has an invalid traceId (should be uuidv4).\n  // All profiles and transactions are rejected if this is the case and we want to\n  // warn users that this is happening if they enable debug flag\n  if (typeof traceId === 'string' && traceId.length !== 32) {\n    if (__DEBUG_BUILD__) {\n      logger.log(`[Profiling] Invalid traceId: ${traceId} on profiled event`);\n    }\n  }\n  if (typeof traceId !== 'string') {\n    return '';\n  }\n\n  return traceId;\n}\n/**\n * Creates a profiling event envelope from a Sentry event. If profile does not pass\n * validation, returns null.\n * @param event\n * @param dsn\n * @param metadata\n * @param tunnel\n * @returns {EventEnvelope | null}\n */\n\n/**\n * Creates a profiling event envelope from a Sentry event.\n */\nexport function createProfilePayload(\n  event: ProfiledEvent,\n  processedProfile: JSSelfProfile,\n  profile_id: string,\n): Profile {\n  if (event.type !== 'transaction') {\n    // createProfilingEventEnvelope should only be called for transactions,\n    // we type guard this behavior with isProfiledTransactionEvent.\n    throw new TypeError('Profiling events may only be attached to transactions, this should never occur.');\n  }\n\n  if (processedProfile === undefined || processedProfile === null) {\n    throw new TypeError(\n      `Cannot construct profiling event envelope without a valid profile. Got ${processedProfile} instead.`,\n    );\n  }\n\n  const traceId = getTraceId(event);\n  const enrichedThreadProfile = enrichWithThreadInformation(processedProfile);\n  const transactionStartMs = typeof event.start_timestamp === 'number' ? event.start_timestamp * 1000 : Date.now();\n  const transactionEndMs = typeof event.timestamp === 'number' ? event.timestamp * 1000 : Date.now();\n\n  const profile: Profile = {\n    event_id: profile_id,\n    timestamp: new Date(transactionStartMs).toISOString(),\n    platform: 'javascript',\n    version: '1',\n    release: event.release || '',\n    environment: event.environment || DEFAULT_ENVIRONMENT,\n    runtime: {\n      name: 'javascript',\n      version: WINDOW.navigator.userAgent,\n    },\n    os: {\n      name: OS_PLATFORM,\n      version: OS_PLATFORM_VERSION,\n      build_number: OS_BROWSER,\n    },\n    device: {\n      locale: OS_LOCALE,\n      model: OS_MODEL,\n      manufacturer: OS_BROWSER,\n      architecture: OS_ARCH,\n      is_emulator: false,\n    },\n    debug_meta: {\n      images: applyDebugMetadata(processedProfile.resources),\n    },\n    profile: enrichedThreadProfile,\n    transactions: [\n      {\n        name: event.transaction || '',\n        id: event.event_id || uuid4(),\n        trace_id: traceId,\n        active_thread_id: THREAD_ID_STRING,\n        relative_start_ns: '0',\n        relative_end_ns: ((transactionEndMs - transactionStartMs) * 1e6).toFixed(0),\n      },\n    ],\n  };\n\n  return profile;\n}\n\n/**\n *\n */\nexport function isProfiledTransactionEvent(event: Event): event is ProfiledEvent {\n  return !!(event.sdkProcessingMetadata && event.sdkProcessingMetadata['profile']);\n}\n\n/**\n * Converts a JSSelfProfile to a our sampled format.\n * Does not currently perform stack indexing.\n */\nexport function convertJSSelfProfileToSampledFormat(input: JSSelfProfile): Profile['profile'] {\n  let EMPTY_STACK_ID: undefined | number = undefined;\n  let STACK_ID = 0;\n\n  // Initialize the profile that we will fill with data\n  const profile: Profile['profile'] = {\n    samples: [],\n    stacks: [],\n    frames: [],\n    thread_metadata: {\n      [THREAD_ID_STRING]: { name: THREAD_NAME },\n    },\n  };\n\n  if (!input.samples.length) {\n    return profile;\n  }\n\n  // We assert samples.length > 0 above and timestamp should always be present\n  const start = input.samples[0].timestamp;\n\n  for (let i = 0; i < input.samples.length; i++) {\n    const jsSample = input.samples[i];\n\n    // If sample has no stack, add an empty sample\n    if (jsSample.stackId === undefined) {\n      if (EMPTY_STACK_ID === undefined) {\n        EMPTY_STACK_ID = STACK_ID;\n        profile.stacks[EMPTY_STACK_ID] = [];\n        STACK_ID++;\n      }\n\n      profile['samples'][i] = {\n        // convert ms timestamp to ns\n        elapsed_since_start_ns: ((jsSample.timestamp - start) * MS_TO_NS).toFixed(0),\n        stack_id: EMPTY_STACK_ID,\n        thread_id: THREAD_ID_STRING,\n      };\n      continue;\n    }\n\n    let stackTop: JSSelfProfileStack | undefined = input.stacks[jsSample.stackId];\n\n    // Functions in top->down order (root is last)\n    // We follow the stackTop.parentId trail and collect each visited frameId\n    const stack: number[] = [];\n\n    while (stackTop) {\n      stack.push(stackTop.frameId);\n\n      const frame = input.frames[stackTop.frameId];\n\n      // If our frame has not been indexed yet, index it\n      if (profile.frames[stackTop.frameId] === undefined) {\n        profile.frames[stackTop.frameId] = {\n          function: frame.name,\n          file: frame.resourceId ? input.resources[frame.resourceId] : undefined,\n          line: frame.line,\n          column: frame.column,\n        };\n      }\n\n      stackTop = stackTop.parentId === undefined ? undefined : input.stacks[stackTop.parentId];\n    }\n\n    const sample: Profile['profile']['samples'][0] = {\n      // convert ms timestamp to ns\n      elapsed_since_start_ns: ((jsSample.timestamp - start) * MS_TO_NS).toFixed(0),\n      stack_id: STACK_ID,\n      thread_id: THREAD_ID_STRING,\n    };\n\n    profile['stacks'][STACK_ID] = stack;\n    profile['samples'][i] = sample;\n    STACK_ID++;\n  }\n\n  return profile;\n}\n\n/**\n * Adds items to envelope if they are not already present - mutates the envelope.\n * @param envelope\n */\nexport function addProfilesToEnvelope(envelope: Envelope, profiles: Profile[]): Envelope {\n  if (!profiles.length) {\n    return envelope;\n  }\n\n  for (const profile of profiles) {\n    // @ts-ignore untyped envelope\n    envelope[1].push([{ type: 'profile' }, profile]);\n  }\n  return envelope;\n}\n\n/**\n * Finds transactions with profile_id context in the envelope\n * @param envelope\n * @returns\n */\nexport function findProfiledTransactionsFromEnvelope(envelope: Envelope): Event[] {\n  const events: Event[] = [];\n\n  forEachEnvelopeItem(envelope, (item, type) => {\n    if (type !== 'transaction') {\n      return;\n    }\n\n    for (let j = 1; j < item.length; j++) {\n      const event = item[j] as Event;\n\n      if (event && event.contexts && event.contexts['profile'] && event.contexts['profile']['profile_id']) {\n        events.push(item[j] as Event);\n      }\n    }\n  });\n\n  return events;\n}\n\nconst debugIdStackParserCache = new WeakMap<StackParser, Map<string, StackFrame[]>>();\n/**\n * Applies debug meta data to an event from a list of paths to resources (sourcemaps)\n */\nexport function applyDebugMetadata(resource_paths: ReadonlyArray<string>): DebugImage[] {\n  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n\n  if (!debugIdMap) {\n    return [];\n  }\n\n  const hub = getCurrentHub();\n  if (!hub) {\n    return [];\n  }\n  const client = hub.getClient();\n  if (!client) {\n    return [];\n  }\n  const options = client.getOptions();\n  if (!options) {\n    return [];\n  }\n  const stackParser = options.stackParser;\n  if (!stackParser) {\n    return [];\n  }\n\n  let debugIdStackFramesCache: Map<string, StackFrame[]>;\n  const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);\n  if (cachedDebugIdStackFrameCache) {\n    debugIdStackFramesCache = cachedDebugIdStackFrameCache;\n  } else {\n    debugIdStackFramesCache = new Map<string, StackFrame[]>();\n    debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);\n  }\n\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = Object.keys(debugIdMap).reduce<Record<string, string>>((acc, debugIdStackTrace) => {\n    let parsedStack: StackFrame[];\n\n    const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);\n    if (cachedParsedStack) {\n      parsedStack = cachedParsedStack;\n    } else {\n      parsedStack = stackParser(debugIdStackTrace);\n      debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);\n    }\n\n    for (let i = parsedStack.length - 1; i >= 0; i--) {\n      const stackFrame = parsedStack[i];\n      const file = stackFrame && stackFrame.filename;\n\n      if (stackFrame && file) {\n        acc[file] = debugIdMap[debugIdStackTrace] as string;\n        break;\n      }\n    }\n    return acc;\n  }, {});\n\n  const images: DebugImage[] = [];\n  for (const path of resource_paths) {\n    if (path && filenameDebugIdMap[path]) {\n      images.push({\n        type: 'sourcemap',\n        code_file: path,\n        debug_id: filenameDebugIdMap[path] as string,\n      });\n    }\n  }\n\n  return images;\n}\n\n/**\n * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).\n */\nexport function isValidSampleRate(rate: unknown): boolean {\n  // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck\n  if ((typeof rate !== 'number' && typeof rate !== 'boolean') || (typeof rate === 'number' && isNaN(rate))) {\n    __DEBUG_BUILD__ &&\n      logger.warn(\n        `[Profiling] Invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(\n          rate,\n        )} of type ${JSON.stringify(typeof rate)}.`,\n      );\n    return false;\n  }\n\n  // Boolean sample rates are always valid\n  if (rate === true || rate === false) {\n    return true;\n  }\n\n  // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false\n  if (rate < 0 || rate > 1) {\n    __DEBUG_BUILD__ &&\n      logger.warn(`[Profiling] Invalid sample rate. Sample rate must be between 0 and 1. Got ${rate}.`);\n    return false;\n  }\n  return true;\n}\n\nfunction isValidProfile(profile: JSSelfProfile): profile is JSSelfProfile & { profile_id: string } {\n  if (profile.samples.length < 2) {\n    if (__DEBUG_BUILD__) {\n      // Log a warning if the profile has less than 2 samples so users can know why\n      // they are not seeing any profiling data and we cant avoid the back and forth\n      // of asking them to provide us with a dump of the profile data.\n      logger.log('[Profiling] Discarding profile because it contains less than 2 samples');\n    }\n    return false;\n  }\n\n  if (!profile.frames.length) {\n    if (__DEBUG_BUILD__) {\n      logger.log('[Profiling] Discarding profile because it contains no frames');\n    }\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Creates a profiling envelope item, if the profile does not pass validation, returns null.\n * @param event\n * @returns {Profile | null}\n */\nexport function createProfilingEvent(profile_id: string, profile: JSSelfProfile, event: ProfiledEvent): Profile | null {\n  if (!isValidProfile(profile)) {\n    return null;\n  }\n\n  return createProfilePayload(event, profile, profile_id);\n}\n\nexport const PROFILE_MAP: Map<string, JSSelfProfile> = new Map();\n/**\n *\n */\nexport function addProfileToMap(profile_id: string, profile: JSSelfProfile): void {\n  PROFILE_MAP.set(profile_id, profile);\n\n  if (PROFILE_MAP.size > 30) {\n    const last: string = PROFILE_MAP.keys().next().value;\n    PROFILE_MAP.delete(last);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}