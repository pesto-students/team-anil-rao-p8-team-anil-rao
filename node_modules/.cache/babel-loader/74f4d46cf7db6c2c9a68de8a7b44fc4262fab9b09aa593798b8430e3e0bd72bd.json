{"ast":null,"code":"import { makePromiseBuffer, forEachEnvelopeItem, envelopeItemTypeToDataCategory, isRateLimited, resolvedSyncPromise, createEnvelope, SentryError, logger, serializeEnvelope, updateRateLimits } from '@sentry/utils';\nvar DEFAULT_TRANSPORT_BUFFER_SIZE = 30;\n\n/**\n * Creates an instance of a Sentry `Transport`\n *\n * @param options\n * @param makeRequest\n */\nfunction createTransport(options, makeRequest) {\n  var buffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE);\n  var rateLimits = {};\n  var flush = function flush(timeout) {\n    return buffer.drain(timeout);\n  };\n  function send(envelope) {\n    var filteredEnvelopeItems = [];\n\n    // Drop rate limited items from envelope\n    forEachEnvelopeItem(envelope, function (item, type) {\n      var envelopeItemDataCategory = envelopeItemTypeToDataCategory(type);\n      if (isRateLimited(rateLimits, envelopeItemDataCategory)) {\n        var event = getEventForEnvelopeItem(item, type);\n        options.recordDroppedEvent('ratelimit_backoff', envelopeItemDataCategory, event);\n      } else {\n        filteredEnvelopeItems.push(item);\n      }\n    });\n\n    // Skip sending if envelope is empty after filtering out rate limited events\n    if (filteredEnvelopeItems.length === 0) {\n      return resolvedSyncPromise();\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems);\n\n    // Creates client report for each item in an envelope\n    var recordEnvelopeLoss = function recordEnvelopeLoss(reason) {\n      forEachEnvelopeItem(filteredEnvelope, function (item, type) {\n        var event = getEventForEnvelopeItem(item, type);\n        options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type), event);\n      });\n    };\n    var requestTask = function requestTask() {\n      return makeRequest({\n        body: serializeEnvelope(filteredEnvelope, options.textEncoder)\n      }).then(function (response) {\n        // We don't want to throw on NOK responses, but we want to at least log them\n        if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(\"Sentry responded with status code \".concat(response.statusCode, \" to sent event.\"));\n        }\n        rateLimits = updateRateLimits(rateLimits, response);\n        return response;\n      }, function (error) {\n        recordEnvelopeLoss('network_error');\n        throw error;\n      });\n    };\n    return buffer.add(requestTask).then(function (result) {\n      return result;\n    }, function (error) {\n      if (error instanceof SentryError) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Skipped sending event because buffer is full.');\n        recordEnvelopeLoss('queue_overflow');\n        return resolvedSyncPromise();\n      } else {\n        throw error;\n      }\n    });\n  }\n\n  // We use this to identifify if the transport is the base transport\n  // TODO (v8): Remove this again as we'll no longer need it\n  send.__sentry__baseTransport__ = true;\n  return {\n    send: send,\n    flush: flush\n  };\n}\nfunction getEventForEnvelopeItem(item, type) {\n  if (type !== 'event' && type !== 'transaction') {\n    return undefined;\n  }\n  return Array.isArray(item) ? item[1] : undefined;\n}\nexport { DEFAULT_TRANSPORT_BUFFER_SIZE, createTransport };","map":{"version":3,"names":["DEFAULT_TRANSPORT_BUFFER_SIZE","createTransport","options","makeRequest","buffer","arguments","length","undefined","makePromiseBuffer","bufferSize","rateLimits","flush","timeout","drain","send","envelope","filteredEnvelopeItems","forEachEnvelopeItem","item","type","envelopeItemDataCategory","envelopeItemTypeToDataCategory","isRateLimited","event","getEventForEnvelopeItem","recordDroppedEvent","push","resolvedSyncPromise","filteredEnvelope","createEnvelope","recordEnvelopeLoss","reason","requestTask","body","serializeEnvelope","textEncoder","then","response","statusCode","__SENTRY_DEBUG__","logger","warn","concat","updateRateLimits","error","add","result","SentryError","__sentry__baseTransport__","Array","isArray"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/transports/base.ts"],"sourcesContent":["import type {\n  Envelope,\n  EnvelopeItem,\n  EnvelopeItemType,\n  Event,\n  EventDropReason,\n  EventItem,\n  InternalBaseTransportOptions,\n  Transport,\n  TransportMakeRequestResponse,\n  TransportRequestExecutor,\n} from '@sentry/types';\nimport type { PromiseBuffer, RateLimits } from '@sentry/utils';\nimport {\n  createEnvelope,\n  envelopeItemTypeToDataCategory,\n  forEachEnvelopeItem,\n  isRateLimited,\n  logger,\n  makePromiseBuffer,\n  resolvedSyncPromise,\n  SentryError,\n  serializeEnvelope,\n  updateRateLimits,\n} from '@sentry/utils';\n\nexport const DEFAULT_TRANSPORT_BUFFER_SIZE = 30;\n\n/**\n * Creates an instance of a Sentry `Transport`\n *\n * @param options\n * @param makeRequest\n */\nexport function createTransport(\n  options: InternalBaseTransportOptions,\n  makeRequest: TransportRequestExecutor,\n  buffer: PromiseBuffer<void | TransportMakeRequestResponse> = makePromiseBuffer(\n    options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE,\n  ),\n): Transport {\n  let rateLimits: RateLimits = {};\n  const flush = (timeout?: number): PromiseLike<boolean> => buffer.drain(timeout);\n\n  function send(envelope: Envelope): PromiseLike<void | TransportMakeRequestResponse> {\n    const filteredEnvelopeItems: EnvelopeItem[] = [];\n\n    // Drop rate limited items from envelope\n    forEachEnvelopeItem(envelope, (item, type) => {\n      const envelopeItemDataCategory = envelopeItemTypeToDataCategory(type);\n      if (isRateLimited(rateLimits, envelopeItemDataCategory)) {\n        const event: Event | undefined = getEventForEnvelopeItem(item, type);\n        options.recordDroppedEvent('ratelimit_backoff', envelopeItemDataCategory, event);\n      } else {\n        filteredEnvelopeItems.push(item);\n      }\n    });\n\n    // Skip sending if envelope is empty after filtering out rate limited events\n    if (filteredEnvelopeItems.length === 0) {\n      return resolvedSyncPromise();\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const filteredEnvelope: Envelope = createEnvelope(envelope[0], filteredEnvelopeItems as any);\n\n    // Creates client report for each item in an envelope\n    const recordEnvelopeLoss = (reason: EventDropReason): void => {\n      forEachEnvelopeItem(filteredEnvelope, (item, type) => {\n        const event: Event | undefined = getEventForEnvelopeItem(item, type);\n        options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type), event);\n      });\n    };\n\n    const requestTask = (): PromiseLike<void | TransportMakeRequestResponse> =>\n      makeRequest({ body: serializeEnvelope(filteredEnvelope, options.textEncoder) }).then(\n        response => {\n          // We don't want to throw on NOK responses, but we want to at least log them\n          if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {\n            __DEBUG_BUILD__ && logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);\n          }\n\n          rateLimits = updateRateLimits(rateLimits, response);\n          return response;\n        },\n        error => {\n          recordEnvelopeLoss('network_error');\n          throw error;\n        },\n      );\n\n    return buffer.add(requestTask).then(\n      result => result,\n      error => {\n        if (error instanceof SentryError) {\n          __DEBUG_BUILD__ && logger.error('Skipped sending event because buffer is full.');\n          recordEnvelopeLoss('queue_overflow');\n          return resolvedSyncPromise();\n        } else {\n          throw error;\n        }\n      },\n    );\n  }\n\n  // We use this to identifify if the transport is the base transport\n  // TODO (v8): Remove this again as we'll no longer need it\n  send.__sentry__baseTransport__ = true;\n\n  return {\n    send,\n    flush,\n  };\n}\n\nfunction getEventForEnvelopeItem(item: Envelope[1][number], type: EnvelopeItemType): Event | undefined {\n  if (type !== 'event' && type !== 'transaction') {\n    return undefined;\n  }\n\n  return Array.isArray(item) ? (item as EventItem)[1] : undefined;\n}\n"],"mappings":";AA0BA,IAAAA,6BAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAAC,gBACAC,OAAA,EACAC,WAAA,EAIA;EAAA,IAHAC,MAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAAG,iBAAA,CACAN,OAAA,CAAAO,UAAA,IAAAT,6BACA;EAEA,IAAAU,UAAA;EACA,IAAAC,KAAA,YAAAA,MAAAC,OAAA;IAAA,OAAAR,MAAA,CAAAS,KAAA,CAAAD,OAAA;EAAA;EAEA,SAAAE,KAAAC,QAAA;IACA,IAAAC,qBAAA;;IAEA;IACAC,mBAAA,CAAAF,QAAA,YAAAG,IAAA,EAAAC,IAAA;MACA,IAAAC,wBAAA,GAAAC,8BAAA,CAAAF,IAAA;MACA,IAAAG,aAAA,CAAAZ,UAAA,EAAAU,wBAAA;QACA,IAAAG,KAAA,GAAAC,uBAAA,CAAAN,IAAA,EAAAC,IAAA;QACAjB,OAAA,CAAAuB,kBAAA,sBAAAL,wBAAA,EAAAG,KAAA;MACA;QACAP,qBAAA,CAAAU,IAAA,CAAAR,IAAA;MACA;IACA;;IAEA;IACA,IAAAF,qBAAA,CAAAV,MAAA;MACA,OAAAqB,mBAAA;IACA;;IAEA;IACA,IAAAC,gBAAA,GAAAC,cAAA,CAAAd,QAAA,KAAAC,qBAAA;;IAEA;IACA,IAAAc,kBAAA,YAAAA,mBAAAC,MAAA;MACAd,mBAAA,CAAAW,gBAAA,YAAAV,IAAA,EAAAC,IAAA;QACA,IAAAI,KAAA,GAAAC,uBAAA,CAAAN,IAAA,EAAAC,IAAA;QACAjB,OAAA,CAAAuB,kBAAA,CAAAM,MAAA,EAAAV,8BAAA,CAAAF,IAAA,GAAAI,KAAA;MACA;IACA;IAEA,IAAAS,WAAA,YAAAA,YAAA;MAAA,OACA7B,WAAA;QAAA8B,IAAA,EAAAC,iBAAA,CAAAN,gBAAA,EAAA1B,OAAA,CAAAiC,WAAA;MAAA,GAAAC,IAAA,CACA,UAAAC,QAAA;QACA;QACA,IAAAA,QAAA,CAAAC,UAAA,KAAA/B,SAAA,KAAA8B,QAAA,CAAAC,UAAA,UAAAD,QAAA,CAAAC,UAAA;UACA,QAAAC,gBAAA,oBAAAA,gBAAA,KAAAC,MAAA,CAAAC,IAAA,sCAAAC,MAAA,CAAAL,QAAA,CAAAC,UAAA;QACA;QAEA5B,UAAA,GAAAiC,gBAAA,CAAAjC,UAAA,EAAA2B,QAAA;QACA,OAAAA,QAAA;MACA,GACA,UAAAO,KAAA;QACAd,kBAAA;QACA,MAAAc,KAAA;MACA,CACA;IAAA;IAEA,OAAAxC,MAAA,CAAAyC,GAAA,CAAAb,WAAA,EAAAI,IAAA,CACA,UAAAU,MAAA;MAAA,OAAAA,MAAA;IAAA,GACA,UAAAF,KAAA;MACA,IAAAA,KAAA,YAAAG,WAAA;QACA,QAAAR,gBAAA,oBAAAA,gBAAA,KAAAC,MAAA,CAAAI,KAAA;QACAd,kBAAA;QACA,OAAAH,mBAAA;MACA;QACA,MAAAiB,KAAA;MACA;IACA,CACA;EACA;;EAEA;EACA;EACA9B,IAAA,CAAAkC,yBAAA;EAEA;IACAlC,IAAA,EAAAA,IAAA;IACAH,KAAA,EAAAA;EACA;AACA;AAEA,SAAAa,wBAAAN,IAAA,EAAAC,IAAA;EACA,IAAAA,IAAA,gBAAAA,IAAA;IACA,OAAAZ,SAAA;EACA;EAEA,OAAA0C,KAAA,CAAAC,OAAA,CAAAhC,IAAA,IAAAA,IAAA,MAAAX,SAAA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}