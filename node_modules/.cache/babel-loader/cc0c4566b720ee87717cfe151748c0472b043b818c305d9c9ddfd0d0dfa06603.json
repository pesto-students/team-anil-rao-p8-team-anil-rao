{"ast":null,"code":"import { isThenable } from '@sentry/utils';\nimport { getCurrentHub } from '../hub.js';\nimport { hasTracingEnabled } from '../utils/hasTracingEnabled.js';\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n *\n * Note that if you have not enabled tracing extensions via `addTracingExtensions`\n * or you didn't set `tracesSampleRate`, this function will not generate spans\n * and the `span` returned from the callback will be undefined.\n *\n * This function is meant to be used internally and may break at any time. Use at your own risk.\n *\n * @internal\n * @private\n */\nfunction trace(context, callback) {\n  let onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};\n  const ctx = {\n    ...context\n  };\n  // If a name is set and a description is not, set the description to the name.\n  if (ctx.name !== undefined && ctx.description === undefined) {\n    ctx.description = ctx.name;\n  }\n  const hub = getCurrentHub();\n  const scope = hub.getScope();\n  const parentSpan = scope.getSpan();\n  function getActiveSpan() {\n    if (!hasTracingEnabled()) {\n      return undefined;\n    }\n    return parentSpan ? parentSpan.startChild(ctx) : hub.startTransaction(ctx);\n  }\n  const activeSpan = getActiveSpan();\n  scope.setSpan(activeSpan);\n  function finishAndSetSpan() {\n    activeSpan && activeSpan.finish();\n    hub.getScope().setSpan(parentSpan);\n  }\n  let maybePromiseResult;\n  try {\n    maybePromiseResult = callback(activeSpan);\n  } catch (e) {\n    activeSpan && activeSpan.setStatus('internal_error');\n    onError(e);\n    finishAndSetSpan();\n    throw e;\n  }\n  if (isThenable(maybePromiseResult)) {\n    Promise.resolve(maybePromiseResult).then(() => {\n      finishAndSetSpan();\n    }, e => {\n      activeSpan && activeSpan.setStatus('internal_error');\n      onError(e);\n      finishAndSetSpan();\n    });\n  } else {\n    finishAndSetSpan();\n  }\n  return maybePromiseResult;\n}\nexport { trace };","map":{"version":3,"names":["trace","context","callback","onError","arguments","length","undefined","ctx","name","description","hub","getCurrentHub","scope","getScope","parentSpan","getSpan","getActiveSpan","hasTracingEnabled","startChild","startTransaction","activeSpan","setSpan","finishAndSetSpan","finish","maybePromiseResult","e","setStatus","isThenable","Promise","resolve","then"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/tracing/trace.ts"],"sourcesContent":["import type { TransactionContext } from '@sentry/types';\nimport { isThenable } from '@sentry/utils';\n\nimport { getCurrentHub } from '../hub';\nimport { hasTracingEnabled } from '../utils/hasTracingEnabled';\nimport type { Span } from './span';\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n *\n * Note that if you have not enabled tracing extensions via `addTracingExtensions`\n * or you didn't set `tracesSampleRate`, this function will not generate spans\n * and the `span` returned from the callback will be undefined.\n *\n * This function is meant to be used internally and may break at any time. Use at your own risk.\n *\n * @internal\n * @private\n */\nexport function trace<T>(\n  context: TransactionContext,\n  callback: (span?: Span) => T,\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  onError: (error: unknown) => void = () => {},\n): T {\n  const ctx = { ...context };\n  // If a name is set and a description is not, set the description to the name.\n  if (ctx.name !== undefined && ctx.description === undefined) {\n    ctx.description = ctx.name;\n  }\n\n  const hub = getCurrentHub();\n  const scope = hub.getScope();\n\n  const parentSpan = scope.getSpan();\n\n  function getActiveSpan(): Span | undefined {\n    if (!hasTracingEnabled()) {\n      return undefined;\n    }\n    return parentSpan ? parentSpan.startChild(ctx) : hub.startTransaction(ctx);\n  }\n\n  const activeSpan = getActiveSpan();\n  scope.setSpan(activeSpan);\n\n  function finishAndSetSpan(): void {\n    activeSpan && activeSpan.finish();\n    hub.getScope().setSpan(parentSpan);\n  }\n\n  let maybePromiseResult: T;\n  try {\n    maybePromiseResult = callback(activeSpan);\n  } catch (e) {\n    activeSpan && activeSpan.setStatus('internal_error');\n    onError(e);\n    finishAndSetSpan();\n    throw e;\n  }\n\n  if (isThenable(maybePromiseResult)) {\n    Promise.resolve(maybePromiseResult).then(\n      () => {\n        finishAndSetSpan();\n      },\n      e => {\n        activeSpan && activeSpan.setStatus('internal_error');\n        onError(e);\n        finishAndSetSpan();\n      },\n    );\n  } else {\n    finishAndSetSpan();\n  }\n\n  return maybePromiseResult;\n}\n"],"mappings":";;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAAA,MACAC,OAAA,EACAC,QAAA,EAGA;EAAA,IADAC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA;EAEA,MAAAG,GAAA;IAAA,GAAAN;EAAA;EACA;EACA,IAAAM,GAAA,CAAAC,IAAA,KAAAF,SAAA,IAAAC,GAAA,CAAAE,WAAA,KAAAH,SAAA;IACAC,GAAA,CAAAE,WAAA,GAAAF,GAAA,CAAAC,IAAA;EACA;EAEA,MAAAE,GAAA,GAAAC,aAAA;EACA,MAAAC,KAAA,GAAAF,GAAA,CAAAG,QAAA;EAEA,MAAAC,UAAA,GAAAF,KAAA,CAAAG,OAAA;EAEA,SAAAC,cAAA;IACA,KAAAC,iBAAA;MACA,OAAAX,SAAA;IACA;IACA,OAAAQ,UAAA,GAAAA,UAAA,CAAAI,UAAA,CAAAX,GAAA,IAAAG,GAAA,CAAAS,gBAAA,CAAAZ,GAAA;EACA;EAEA,MAAAa,UAAA,GAAAJ,aAAA;EACAJ,KAAA,CAAAS,OAAA,CAAAD,UAAA;EAEA,SAAAE,iBAAA;IACAF,UAAA,IAAAA,UAAA,CAAAG,MAAA;IACAb,GAAA,CAAAG,QAAA,GAAAQ,OAAA,CAAAP,UAAA;EACA;EAEA,IAAAU,kBAAA;EACA;IACAA,kBAAA,GAAAtB,QAAA,CAAAkB,UAAA;EACA,SAAAK,CAAA;IACAL,UAAA,IAAAA,UAAA,CAAAM,SAAA;IACAvB,OAAA,CAAAsB,CAAA;IACAH,gBAAA;IACA,MAAAG,CAAA;EACA;EAEA,IAAAE,UAAA,CAAAH,kBAAA;IACAI,OAAA,CAAAC,OAAA,CAAAL,kBAAA,EAAAM,IAAA,CACA;MACAR,gBAAA;IACA,GACAG,CAAA;MACAL,UAAA,IAAAA,UAAA,CAAAM,SAAA;MACAvB,OAAA,CAAAsB,CAAA;MACAH,gBAAA;IACA,CACA;EACA;IACAA,gBAAA;EACA;EAEA,OAAAE,kBAAA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}