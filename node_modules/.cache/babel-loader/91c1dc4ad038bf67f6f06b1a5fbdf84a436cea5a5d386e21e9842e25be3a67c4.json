{"ast":null,"code":"import { isString, isRegExp } from './is.js';\n\n/**\n * Truncates given string to the maximum characters count\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string (0 = unlimited)\n * @returns string Encoded\n */\nfunction truncate(str) {\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  if (typeof str !== 'string' || max === 0) {\n    return str;\n  }\n  return str.length <= max ? str : \"\".concat(str.slice(0, max), \"...\");\n}\n\n/**\n * This is basically just `trim_line` from\n * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string\n * @returns string Encoded\n */\nfunction snipLine(line, colno) {\n  var newLine = line;\n  var lineLength = newLine.length;\n  if (lineLength <= 150) {\n    return newLine;\n  }\n  if (colno > lineLength) {\n    // eslint-disable-next-line no-param-reassign\n    colno = lineLength;\n  }\n  var start = Math.max(colno - 60, 0);\n  if (start < 5) {\n    start = 0;\n  }\n  var end = Math.min(start + 140, lineLength);\n  if (end > lineLength - 5) {\n    end = lineLength;\n  }\n  if (end === lineLength) {\n    start = Math.max(end - 140, 0);\n  }\n  newLine = newLine.slice(start, end);\n  if (start > 0) {\n    newLine = \"'{snip} \".concat(newLine);\n  }\n  if (end < lineLength) {\n    newLine += ' {snip}';\n  }\n  return newLine;\n}\n\n/**\n * Join values in array\n * @param input array of values to be joined together\n * @param delimiter string to be placed in-between values\n * @returns Joined values\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction safeJoin(input, delimiter) {\n  if (!Array.isArray(input)) {\n    return '';\n  }\n  var output = [];\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of\n  for (var i = 0; i < input.length; i++) {\n    var value = input[i];\n    try {\n      output.push(String(value));\n    } catch (e) {\n      output.push('[value cannot be serialized]');\n    }\n  }\n  return output.join(delimiter);\n}\n\n/**\n * Checks if the given value matches a regex or string\n *\n * @param value The string to test\n * @param pattern Either a regex or a string against which `value` will be matched\n * @param requireExactStringMatch If true, `value` must match `pattern` exactly. If false, `value` will match\n * `pattern` if it contains `pattern`. Only applies to string-type patterns.\n */\nfunction isMatchingPattern(value, pattern) {\n  var requireExactStringMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!isString(value)) {\n    return false;\n  }\n  if (isRegExp(pattern)) {\n    return pattern.test(value);\n  }\n  if (isString(pattern)) {\n    return requireExactStringMatch ? value === pattern : value.includes(pattern);\n  }\n  return false;\n}\n\n/**\n * Test the given string against an array of strings and regexes. By default, string matching is done on a\n * substring-inclusion basis rather than a strict equality basis\n *\n * @param testString The string to test\n * @param patterns The patterns against which to test the string\n * @param requireExactStringMatch If true, `testString` must match one of the given string patterns exactly in order to\n * count. If false, `testString` will match a string pattern if it contains that pattern.\n * @returns\n */\nfunction stringMatchesSomePattern(testString) {\n  var patterns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var requireExactStringMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return patterns.some(function (pattern) {\n    return isMatchingPattern(testString, pattern, requireExactStringMatch);\n  });\n}\nexport { isMatchingPattern, safeJoin, snipLine, stringMatchesSomePattern, truncate };","map":{"version":3,"names":["truncate","str","max","arguments","length","undefined","concat","slice","snipLine","line","colno","newLine","lineLength","start","Math","end","min","safeJoin","input","delimiter","Array","isArray","output","i","value","push","String","e","join","isMatchingPattern","pattern","requireExactStringMatch","isString","isRegExp","test","includes","stringMatchesSomePattern","testString","patterns","some"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/string.ts"],"sourcesContent":["import { isRegExp, isString } from './is';\n\nexport { escapeStringForRegex } from './vendor/escapeStringForRegex';\n\n/**\n * Truncates given string to the maximum characters count\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string (0 = unlimited)\n * @returns string Encoded\n */\nexport function truncate(str: string, max: number = 0): string {\n  if (typeof str !== 'string' || max === 0) {\n    return str;\n  }\n  return str.length <= max ? str : `${str.slice(0, max)}...`;\n}\n\n/**\n * This is basically just `trim_line` from\n * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string\n * @returns string Encoded\n */\nexport function snipLine(line: string, colno: number): string {\n  let newLine = line;\n  const lineLength = newLine.length;\n  if (lineLength <= 150) {\n    return newLine;\n  }\n  if (colno > lineLength) {\n    // eslint-disable-next-line no-param-reassign\n    colno = lineLength;\n  }\n\n  let start = Math.max(colno - 60, 0);\n  if (start < 5) {\n    start = 0;\n  }\n\n  let end = Math.min(start + 140, lineLength);\n  if (end > lineLength - 5) {\n    end = lineLength;\n  }\n  if (end === lineLength) {\n    start = Math.max(end - 140, 0);\n  }\n\n  newLine = newLine.slice(start, end);\n  if (start > 0) {\n    newLine = `'{snip} ${newLine}`;\n  }\n  if (end < lineLength) {\n    newLine += ' {snip}';\n  }\n\n  return newLine;\n}\n\n/**\n * Join values in array\n * @param input array of values to be joined together\n * @param delimiter string to be placed in-between values\n * @returns Joined values\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function safeJoin(input: any[], delimiter?: string): string {\n  if (!Array.isArray(input)) {\n    return '';\n  }\n\n  const output = [];\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of\n  for (let i = 0; i < input.length; i++) {\n    const value = input[i];\n    try {\n      output.push(String(value));\n    } catch (e) {\n      output.push('[value cannot be serialized]');\n    }\n  }\n\n  return output.join(delimiter);\n}\n\n/**\n * Checks if the given value matches a regex or string\n *\n * @param value The string to test\n * @param pattern Either a regex or a string against which `value` will be matched\n * @param requireExactStringMatch If true, `value` must match `pattern` exactly. If false, `value` will match\n * `pattern` if it contains `pattern`. Only applies to string-type patterns.\n */\nexport function isMatchingPattern(\n  value: string,\n  pattern: RegExp | string,\n  requireExactStringMatch: boolean = false,\n): boolean {\n  if (!isString(value)) {\n    return false;\n  }\n\n  if (isRegExp(pattern)) {\n    return pattern.test(value);\n  }\n  if (isString(pattern)) {\n    return requireExactStringMatch ? value === pattern : value.includes(pattern);\n  }\n\n  return false;\n}\n\n/**\n * Test the given string against an array of strings and regexes. By default, string matching is done on a\n * substring-inclusion basis rather than a strict equality basis\n *\n * @param testString The string to test\n * @param patterns The patterns against which to test the string\n * @param requireExactStringMatch If true, `testString` must match one of the given string patterns exactly in order to\n * count. If false, `testString` will match a string pattern if it contains that pattern.\n * @returns\n */\nexport function stringMatchesSomePattern(\n  testString: string,\n  patterns: Array<string | RegExp> = [],\n  requireExactStringMatch: boolean = false,\n): boolean {\n  return patterns.some(pattern => isMatchingPattern(testString, pattern, requireExactStringMatch));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}