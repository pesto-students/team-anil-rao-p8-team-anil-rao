{"ast":null,"code":"import _toConsumableArray from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { _optionalChain } from '@sentry/utils/esm/buildPolyfills';\nimport { hasTracingEnabled, getCurrentHub } from '@sentry/core';\nimport { addInstrumentationHandler, browserPerformanceTimeOrigin, dynamicSamplingContextToSentryBaggageHeader, isInstanceOf, BAGGAGE_HEADER_NAME, SENTRY_XHR_DATA_KEY, stringMatchesSomePattern } from '@sentry/utils';\n\n/* eslint-disable max-lines */\n\nvar DEFAULT_TRACE_PROPAGATION_TARGETS = ['localhost', /^\\/(?!\\/)/];\n\n/** Options for Request Instrumentation */\n\nvar defaultRequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  // TODO (v8): Remove this property\n  tracingOrigins: DEFAULT_TRACE_PROPAGATION_TARGETS,\n  tracePropagationTargets: DEFAULT_TRACE_PROPAGATION_TARGETS,\n  _experiments: {}\n};\n\n/** Registers span creators for xhr and fetch requests  */\nfunction instrumentOutgoingRequests(_options) {\n  // eslint-disable-next-line deprecation/deprecation\n  var _traceFetch$traceXHR$ = _objectSpread({\n      traceFetch: defaultRequestInstrumentationOptions.traceFetch,\n      traceXHR: defaultRequestInstrumentationOptions.traceXHR\n    }, _options),\n    traceFetch = _traceFetch$traceXHR$.traceFetch,\n    traceXHR = _traceFetch$traceXHR$.traceXHR,\n    tracePropagationTargets = _traceFetch$traceXHR$.tracePropagationTargets,\n    tracingOrigins = _traceFetch$traceXHR$.tracingOrigins,\n    shouldCreateSpanForRequest = _traceFetch$traceXHR$.shouldCreateSpanForRequest,\n    _experiments = _traceFetch$traceXHR$._experiments;\n  var shouldCreateSpan = typeof shouldCreateSpanForRequest === 'function' ? shouldCreateSpanForRequest : function (_) {\n    return true;\n  };\n\n  // TODO(v8) Remove tracingOrigins here\n  // The only reason we're passing it in here is because this instrumentOutgoingRequests function is publicly exported\n  // and we don't want to break the API. We can remove it in v8.\n  var shouldAttachHeadersWithTargets = function shouldAttachHeadersWithTargets(url) {\n    return shouldAttachHeaders(url, tracePropagationTargets || tracingOrigins);\n  };\n  var spans = {};\n  if (traceFetch) {\n    addInstrumentationHandler('fetch', function (handlerData) {\n      var createdSpan = fetchCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (_optionalChain([_experiments, 'optionalAccess', function (_2) {\n        return _2.enableHTTPTimings;\n      }]) && createdSpan) {\n        addHTTPTimings(createdSpan);\n      }\n    });\n  }\n  if (traceXHR) {\n    addInstrumentationHandler('xhr', function (handlerData) {\n      var createdSpan = xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (_optionalChain([_experiments, 'optionalAccess', function (_3) {\n        return _3.enableHTTPTimings;\n      }]) && createdSpan) {\n        addHTTPTimings(createdSpan);\n      }\n    });\n  }\n}\n\n/**\n * Creates a temporary observer to listen to the next fetch/xhr resourcing timings,\n * so that when timings hit their per-browser limit they don't need to be removed.\n *\n * @param span A span that has yet to be finished, must contain `url` on data.\n */\nfunction addHTTPTimings(span) {\n  var url = span.data.url;\n  var observer = new PerformanceObserver(function (list) {\n    var entries = list.getEntries();\n    entries.forEach(function (entry) {\n      if ((entry.initiatorType === 'fetch' || entry.initiatorType === 'xmlhttprequest') && entry.name.endsWith(url)) {\n        var spanData = resourceTimingEntryToSpanData(entry);\n        spanData.forEach(function (data) {\n          return span.setData.apply(span, _toConsumableArray(data));\n        });\n        observer.disconnect();\n      }\n    });\n  });\n  observer.observe({\n    entryTypes: ['resource']\n  });\n}\nfunction resourceTimingEntryToSpanData(resourceTiming) {\n  var version = resourceTiming.nextHopProtocol.split('/')[1] || 'none';\n  var timingSpanData = [];\n  if (version) {\n    timingSpanData.push(['network.protocol.version', version]);\n  }\n  if (!browserPerformanceTimeOrigin) {\n    return timingSpanData;\n  }\n  return [].concat(timingSpanData, [['http.request.connect_start', (browserPerformanceTimeOrigin + resourceTiming.connectStart) / 1000], ['http.request.request_start', (browserPerformanceTimeOrigin + resourceTiming.requestStart) / 1000], ['http.request.response_start', (browserPerformanceTimeOrigin + resourceTiming.responseStart) / 1000]]);\n}\n\n/**\n * A function that determines whether to attach tracing headers to a request.\n * This was extracted from `instrumentOutgoingRequests` to make it easier to test shouldAttachHeaders.\n * We only export this fuction for testing purposes.\n */\nfunction shouldAttachHeaders(url, tracePropagationTargets) {\n  return stringMatchesSomePattern(url, tracePropagationTargets || DEFAULT_TRACE_PROPAGATION_TARGETS);\n}\n\n/**\n * Create and track fetch request spans\n *\n * @returns Span if a span was created, otherwise void.\n */\nfunction fetchCallback(handlerData, shouldCreateSpan, shouldAttachHeaders, spans) {\n  if (!hasTracingEnabled() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {\n    return;\n  }\n  if (handlerData.endTimestamp) {\n    var spanId = handlerData.fetchData.__span;\n    if (!spanId) return;\n    var span = spans[spanId];\n    if (span) {\n      if (handlerData.response) {\n        // TODO (kmclb) remove this once types PR goes through\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        span.setHttpStatus(handlerData.response.status);\n        var contentLength =\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        handlerData.response && handlerData.response.headers && handlerData.response.headers.get('content-length');\n        var contentLengthNum = parseInt(contentLength);\n        if (contentLengthNum > 0) {\n          span.setData('http.response_content_length', contentLengthNum);\n        }\n      } else if (handlerData.error) {\n        span.setStatus('internal_error');\n      }\n      span.finish();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return;\n  }\n  var currentSpan = getCurrentHub().getScope().getSpan();\n  var activeTransaction = currentSpan && currentSpan.transaction;\n  if (currentSpan && activeTransaction) {\n    var _handlerData$fetchDat = handlerData.fetchData,\n      method = _handlerData$fetchDat.method,\n      url = _handlerData$fetchDat.url;\n    var _span = currentSpan.startChild({\n      data: {\n        url: url,\n        type: 'fetch',\n        'http.method': method\n      },\n      description: \"\".concat(method, \" \").concat(url),\n      op: 'http.client'\n    });\n    handlerData.fetchData.__span = _span.spanId;\n    spans[_span.spanId] = _span;\n    var request = handlerData.args[0];\n\n    // In case the user hasn't set the second argument of a fetch call we default it to `{}`.\n    handlerData.args[1] = handlerData.args[1] || {};\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var options = handlerData.args[1];\n    if (shouldAttachHeaders(handlerData.fetchData.url)) {\n      options.headers = addTracingHeadersToFetchRequest(request, activeTransaction.getDynamicSamplingContext(), _span, options);\n    }\n    return _span;\n  }\n}\n\n/**\n * Adds sentry-trace and baggage headers to the various forms of fetch headers\n */\nfunction addTracingHeadersToFetchRequest(request,\n// unknown is actually type Request but we can't export DOM types from this package,\ndynamicSamplingContext, span, options) {\n  var sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);\n  var sentryTraceHeader = span.toTraceparent();\n  var headers = typeof Request !== 'undefined' && isInstanceOf(request, Request) ? request.headers : options.headers;\n  if (!headers) {\n    return {\n      'sentry-trace': sentryTraceHeader,\n      baggage: sentryBaggageHeader\n    };\n  } else if (typeof Headers !== 'undefined' && isInstanceOf(headers, Headers)) {\n    var newHeaders = new Headers(headers);\n    newHeaders.append('sentry-trace', sentryTraceHeader);\n    if (sentryBaggageHeader) {\n      // If the same header is appended multiple times the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.append(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n    }\n    return newHeaders;\n  } else if (Array.isArray(headers)) {\n    var _newHeaders = [].concat(_toConsumableArray(headers), [['sentry-trace', sentryTraceHeader]]);\n    if (sentryBaggageHeader) {\n      // If there are multiple entries with the same key, the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      _newHeaders.push([BAGGAGE_HEADER_NAME, sentryBaggageHeader]);\n    }\n    return _newHeaders;\n  } else {\n    var existingBaggageHeader = 'baggage' in headers ? headers.baggage : undefined;\n    var newBaggageHeaders = [];\n    if (Array.isArray(existingBaggageHeader)) {\n      newBaggageHeaders.push.apply(newBaggageHeaders, _toConsumableArray(existingBaggageHeader));\n    } else if (existingBaggageHeader) {\n      newBaggageHeaders.push(existingBaggageHeader);\n    }\n    if (sentryBaggageHeader) {\n      newBaggageHeaders.push(sentryBaggageHeader);\n    }\n    return _objectSpread(_objectSpread({}, headers), {}, {\n      'sentry-trace': sentryTraceHeader,\n      baggage: newBaggageHeaders.length > 0 ? newBaggageHeaders.join(',') : undefined\n    });\n  }\n}\n\n/**\n * Create and track xhr request spans\n *\n * @returns Span if a span was created, otherwise void.\n */\nfunction xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeaders, spans) {\n  var xhr = handlerData.xhr;\n  var sentryXhrData = xhr && xhr[SENTRY_XHR_DATA_KEY];\n  if (!hasTracingEnabled() || xhr && xhr.__sentry_own_request__ || !(xhr && sentryXhrData && shouldCreateSpan(sentryXhrData.url))) {\n    return;\n  }\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp) {\n    var spanId = xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n    var span = spans[spanId];\n    if (span) {\n      span.setHttpStatus(sentryXhrData.status_code);\n      span.finish();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return;\n  }\n  var currentSpan = getCurrentHub().getScope().getSpan();\n  var activeTransaction = currentSpan && currentSpan.transaction;\n  if (currentSpan && activeTransaction) {\n    var _span2 = currentSpan.startChild({\n      data: _objectSpread(_objectSpread({}, sentryXhrData.data), {}, {\n        type: 'xhr',\n        'http.method': sentryXhrData.method,\n        url: sentryXhrData.url\n      }),\n      description: \"\".concat(sentryXhrData.method, \" \").concat(sentryXhrData.url),\n      op: 'http.client'\n    });\n    xhr.__sentry_xhr_span_id__ = _span2.spanId;\n    spans[xhr.__sentry_xhr_span_id__] = _span2;\n    if (xhr.setRequestHeader && shouldAttachHeaders(sentryXhrData.url)) {\n      try {\n        xhr.setRequestHeader('sentry-trace', _span2.toTraceparent());\n        var dynamicSamplingContext = activeTransaction.getDynamicSamplingContext();\n        var sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);\n        if (sentryBaggageHeader) {\n          // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n          // We can therefore simply set a baggage header without checking what was there before\n          // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n          xhr.setRequestHeader(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n        }\n      } catch (_) {\n        // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n      }\n    }\n    return _span2;\n  }\n}\nexport { DEFAULT_TRACE_PROPAGATION_TARGETS, addTracingHeadersToFetchRequest, defaultRequestInstrumentationOptions, instrumentOutgoingRequests, shouldAttachHeaders };","map":{"version":3,"names":["DEFAULT_TRACE_PROPAGATION_TARGETS","defaultRequestInstrumentationOptions","traceFetch","traceXHR","tracingOrigins","tracePropagationTargets","_experiments","instrumentOutgoingRequests","_options","_traceFetch$traceXHR$","_objectSpread","shouldCreateSpanForRequest","shouldCreateSpan","_","shouldAttachHeadersWithTargets","url","shouldAttachHeaders","spans","addInstrumentationHandler","handlerData","createdSpan","fetchCallback","_optionalChain","_2","enableHTTPTimings","addHTTPTimings","xhrCallback","_3","span","data","observer","PerformanceObserver","list","entries","getEntries","forEach","entry","initiatorType","name","endsWith","spanData","resourceTimingEntryToSpanData","setData","apply","_toConsumableArray","disconnect","observe","entryTypes","resourceTiming","version","nextHopProtocol","split","timingSpanData","push","browserPerformanceTimeOrigin","concat","connectStart","requestStart","responseStart","stringMatchesSomePattern","hasTracingEnabled","fetchData","endTimestamp","spanId","__span","response","setHttpStatus","status","contentLength","headers","get","contentLengthNum","parseInt","error","setStatus","finish","currentSpan","getCurrentHub","getScope","getSpan","activeTransaction","transaction","_handlerData$fetchDat","method","startChild","type","description","op","request","args","options","addTracingHeadersToFetchRequest","getDynamicSamplingContext","dynamicSamplingContext","sentryBaggageHeader","dynamicSamplingContextToSentryBaggageHeader","sentryTraceHeader","toTraceparent","Request","isInstanceOf","baggage","Headers","newHeaders","append","BAGGAGE_HEADER_NAME","Array","isArray","existingBaggageHeader","undefined","newBaggageHeaders","length","join","xhr","sentryXhrData","SENTRY_XHR_DATA_KEY","__sentry_own_request__","__sentry_xhr_span_id__","status_code","setRequestHeader"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry-internal/src/browser/request.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport { getCurrentHub, hasTracingEnabled } from '@sentry/core';\nimport type { DynamicSamplingContext, Span } from '@sentry/types';\nimport {\n  addInstrumentationHandler,\n  BAGGAGE_HEADER_NAME,\n  browserPerformanceTimeOrigin,\n  dynamicSamplingContextToSentryBaggageHeader,\n  isInstanceOf,\n  SENTRY_XHR_DATA_KEY,\n  stringMatchesSomePattern,\n} from '@sentry/utils';\n\nexport const DEFAULT_TRACE_PROPAGATION_TARGETS = ['localhost', /^\\/(?!\\/)/];\n\n/** Options for Request Instrumentation */\nexport interface RequestInstrumentationOptions {\n  /**\n   * Allow experiments for the request instrumentation.\n   */\n  _experiments: Partial<{\n    enableHTTPTimings: boolean;\n  }>;\n\n  /**\n   * @deprecated Will be removed in v8.\n   * Use `shouldCreateSpanForRequest` to control span creation and `tracePropagationTargets` to control\n   * trace header attachment.\n   */\n  tracingOrigins: Array<string | RegExp>;\n\n  /**\n   * List of strings and/or regexes used to determine which outgoing requests will have `sentry-trace` and `baggage`\n   * headers attached.\n   *\n   * Default: ['localhost', /^\\//] {@see DEFAULT_TRACE_PROPAGATION_TARGETS}\n   */\n  tracePropagationTargets: Array<string | RegExp>;\n\n  /**\n   * Flag to disable patching all together for fetch requests.\n   *\n   * Default: true\n   */\n  traceFetch: boolean;\n\n  /**\n   * Flag to disable patching all together for xhr requests.\n   *\n   * Default: true\n   */\n  traceXHR: boolean;\n\n  /**\n   * This function will be called before creating a span for a request with the given url.\n   * Return false if you don't want a span for the given url.\n   *\n   * Default: (url: string) => true\n   */\n  shouldCreateSpanForRequest?(this: void, url: string): boolean;\n}\n\n/** Data returned from fetch callback */\nexport interface FetchData {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  args: any[]; // the arguments passed to the fetch call itself\n  fetchData?: {\n    method: string;\n    url: string;\n    // span_id\n    __span?: string;\n  };\n\n  // TODO Should this be unknown instead? If we vendor types, make it a Response\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  response?: any;\n  error?: unknown;\n\n  startTimestamp: number;\n  endTimestamp?: number;\n}\n\n/** Data returned from XHR request */\nexport interface XHRData {\n  xhr?: {\n    [SENTRY_XHR_DATA_KEY]?: {\n      method: string;\n      url: string;\n      status_code: number;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      data: Record<string, any>;\n    };\n    __sentry_xhr_span_id__?: string;\n    setRequestHeader?: (key: string, val: string) => void;\n    getRequestHeader?: (key: string) => string;\n    __sentry_own_request__?: boolean;\n  };\n  startTimestamp: number;\n  endTimestamp?: number;\n}\n\ntype PolymorphicRequestHeaders =\n  | Record<string, string | undefined>\n  | Array<[string, string]>\n  // the below is not preicsely the Header type used in Request, but it'll pass duck-typing\n  | {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      [key: string]: any;\n      append: (key: string, value: string) => void;\n      get: (key: string) => string | null | undefined;\n    };\n\nexport const defaultRequestInstrumentationOptions: RequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  // TODO (v8): Remove this property\n  tracingOrigins: DEFAULT_TRACE_PROPAGATION_TARGETS,\n  tracePropagationTargets: DEFAULT_TRACE_PROPAGATION_TARGETS,\n  _experiments: {},\n};\n\n/** Registers span creators for xhr and fetch requests  */\nexport function instrumentOutgoingRequests(_options?: Partial<RequestInstrumentationOptions>): void {\n  // eslint-disable-next-line deprecation/deprecation\n  const { traceFetch, traceXHR, tracePropagationTargets, tracingOrigins, shouldCreateSpanForRequest, _experiments } = {\n    traceFetch: defaultRequestInstrumentationOptions.traceFetch,\n    traceXHR: defaultRequestInstrumentationOptions.traceXHR,\n    ..._options,\n  };\n\n  const shouldCreateSpan =\n    typeof shouldCreateSpanForRequest === 'function' ? shouldCreateSpanForRequest : (_: string) => true;\n\n  // TODO(v8) Remove tracingOrigins here\n  // The only reason we're passing it in here is because this instrumentOutgoingRequests function is publicly exported\n  // and we don't want to break the API. We can remove it in v8.\n  const shouldAttachHeadersWithTargets = (url: string): boolean =>\n    shouldAttachHeaders(url, tracePropagationTargets || tracingOrigins);\n\n  const spans: Record<string, Span> = {};\n\n  if (traceFetch) {\n    addInstrumentationHandler('fetch', (handlerData: FetchData) => {\n      const createdSpan = fetchCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (_experiments?.enableHTTPTimings && createdSpan) {\n        addHTTPTimings(createdSpan);\n      }\n    });\n  }\n\n  if (traceXHR) {\n    addInstrumentationHandler('xhr', (handlerData: XHRData) => {\n      const createdSpan = xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (_experiments?.enableHTTPTimings && createdSpan) {\n        addHTTPTimings(createdSpan);\n      }\n    });\n  }\n}\n\n/**\n * Creates a temporary observer to listen to the next fetch/xhr resourcing timings,\n * so that when timings hit their per-browser limit they don't need to be removed.\n *\n * @param span A span that has yet to be finished, must contain `url` on data.\n */\nfunction addHTTPTimings(span: Span): void {\n  const url = span.data.url;\n  const observer = new PerformanceObserver(list => {\n    const entries = list.getEntries() as PerformanceResourceTiming[];\n    entries.forEach(entry => {\n      if ((entry.initiatorType === 'fetch' || entry.initiatorType === 'xmlhttprequest') && entry.name.endsWith(url)) {\n        const spanData = resourceTimingEntryToSpanData(entry);\n        spanData.forEach(data => span.setData(...data));\n        observer.disconnect();\n      }\n    });\n  });\n  observer.observe({\n    entryTypes: ['resource'],\n  });\n}\n\nfunction resourceTimingEntryToSpanData(resourceTiming: PerformanceResourceTiming): [string, string | number][] {\n  const version = resourceTiming.nextHopProtocol.split('/')[1] || 'none';\n\n  const timingSpanData: [string, string | number][] = [];\n  if (version) {\n    timingSpanData.push(['network.protocol.version', version]);\n  }\n\n  if (!browserPerformanceTimeOrigin) {\n    return timingSpanData;\n  }\n  return [\n    ...timingSpanData,\n    ['http.request.connect_start', (browserPerformanceTimeOrigin + resourceTiming.connectStart) / 1000],\n    ['http.request.request_start', (browserPerformanceTimeOrigin + resourceTiming.requestStart) / 1000],\n    ['http.request.response_start', (browserPerformanceTimeOrigin + resourceTiming.responseStart) / 1000],\n  ];\n}\n\n/**\n * A function that determines whether to attach tracing headers to a request.\n * This was extracted from `instrumentOutgoingRequests` to make it easier to test shouldAttachHeaders.\n * We only export this fuction for testing purposes.\n */\nexport function shouldAttachHeaders(url: string, tracePropagationTargets: (string | RegExp)[] | undefined): boolean {\n  return stringMatchesSomePattern(url, tracePropagationTargets || DEFAULT_TRACE_PROPAGATION_TARGETS);\n}\n\n/**\n * Create and track fetch request spans\n *\n * @returns Span if a span was created, otherwise void.\n */\nfunction fetchCallback(\n  handlerData: FetchData,\n  shouldCreateSpan: (url: string) => boolean,\n  shouldAttachHeaders: (url: string) => boolean,\n  spans: Record<string, Span>,\n): Span | void {\n  if (!hasTracingEnabled() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {\n    return;\n  }\n\n  if (handlerData.endTimestamp) {\n    const spanId = handlerData.fetchData.__span;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span) {\n      if (handlerData.response) {\n        // TODO (kmclb) remove this once types PR goes through\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        span.setHttpStatus(handlerData.response.status);\n\n        const contentLength: string =\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          handlerData.response && handlerData.response.headers && handlerData.response.headers.get('content-length');\n\n        const contentLengthNum = parseInt(contentLength);\n        if (contentLengthNum > 0) {\n          span.setData('http.response_content_length', contentLengthNum);\n        }\n      } else if (handlerData.error) {\n        span.setStatus('internal_error');\n      }\n      span.finish();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return;\n  }\n\n  const currentSpan = getCurrentHub().getScope().getSpan();\n  const activeTransaction = currentSpan && currentSpan.transaction;\n\n  if (currentSpan && activeTransaction) {\n    const { method, url } = handlerData.fetchData;\n    const span = currentSpan.startChild({\n      data: {\n        url,\n        type: 'fetch',\n        'http.method': method,\n      },\n      description: `${method} ${url}`,\n      op: 'http.client',\n    });\n\n    handlerData.fetchData.__span = span.spanId;\n    spans[span.spanId] = span;\n\n    const request: string | Request = handlerData.args[0];\n\n    // In case the user hasn't set the second argument of a fetch call we default it to `{}`.\n    handlerData.args[1] = handlerData.args[1] || {};\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const options: { [key: string]: any } = handlerData.args[1];\n\n    if (shouldAttachHeaders(handlerData.fetchData.url)) {\n      options.headers = addTracingHeadersToFetchRequest(\n        request,\n        activeTransaction.getDynamicSamplingContext(),\n        span,\n        options,\n      );\n    }\n    return span;\n  }\n}\n\n/**\n * Adds sentry-trace and baggage headers to the various forms of fetch headers\n */\nexport function addTracingHeadersToFetchRequest(\n  request: string | unknown, // unknown is actually type Request but we can't export DOM types from this package,\n  dynamicSamplingContext: Partial<DynamicSamplingContext>,\n  span: Span,\n  options: {\n    headers?:\n      | {\n          [key: string]: string[] | string | undefined;\n        }\n      | PolymorphicRequestHeaders;\n  },\n): PolymorphicRequestHeaders {\n  const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);\n  const sentryTraceHeader = span.toTraceparent();\n\n  const headers =\n    typeof Request !== 'undefined' && isInstanceOf(request, Request) ? (request as Request).headers : options.headers;\n\n  if (!headers) {\n    return { 'sentry-trace': sentryTraceHeader, baggage: sentryBaggageHeader };\n  } else if (typeof Headers !== 'undefined' && isInstanceOf(headers, Headers)) {\n    const newHeaders = new Headers(headers as Headers);\n\n    newHeaders.append('sentry-trace', sentryTraceHeader);\n\n    if (sentryBaggageHeader) {\n      // If the same header is appended multiple times the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.append(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n    }\n\n    return newHeaders as PolymorphicRequestHeaders;\n  } else if (Array.isArray(headers)) {\n    const newHeaders = [...headers, ['sentry-trace', sentryTraceHeader]];\n\n    if (sentryBaggageHeader) {\n      // If there are multiple entries with the same key, the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.push([BAGGAGE_HEADER_NAME, sentryBaggageHeader]);\n    }\n\n    return newHeaders as PolymorphicRequestHeaders;\n  } else {\n    const existingBaggageHeader = 'baggage' in headers ? headers.baggage : undefined;\n    const newBaggageHeaders: string[] = [];\n\n    if (Array.isArray(existingBaggageHeader)) {\n      newBaggageHeaders.push(...existingBaggageHeader);\n    } else if (existingBaggageHeader) {\n      newBaggageHeaders.push(existingBaggageHeader);\n    }\n\n    if (sentryBaggageHeader) {\n      newBaggageHeaders.push(sentryBaggageHeader);\n    }\n\n    return {\n      ...(headers as Exclude<typeof headers, Headers>),\n      'sentry-trace': sentryTraceHeader,\n      baggage: newBaggageHeaders.length > 0 ? newBaggageHeaders.join(',') : undefined,\n    };\n  }\n}\n\n/**\n * Create and track xhr request spans\n *\n * @returns Span if a span was created, otherwise void.\n */\nfunction xhrCallback(\n  handlerData: XHRData,\n  shouldCreateSpan: (url: string) => boolean,\n  shouldAttachHeaders: (url: string) => boolean,\n  spans: Record<string, Span>,\n): Span | void {\n  const xhr = handlerData.xhr;\n  const sentryXhrData = xhr && xhr[SENTRY_XHR_DATA_KEY];\n\n  if (\n    !hasTracingEnabled() ||\n    (xhr && xhr.__sentry_own_request__) ||\n    !(xhr && sentryXhrData && shouldCreateSpan(sentryXhrData.url))\n  ) {\n    return;\n  }\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp) {\n    const spanId = xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span) {\n      span.setHttpStatus(sentryXhrData.status_code);\n      span.finish();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return;\n  }\n\n  const currentSpan = getCurrentHub().getScope().getSpan();\n  const activeTransaction = currentSpan && currentSpan.transaction;\n\n  if (currentSpan && activeTransaction) {\n    const span = currentSpan.startChild({\n      data: {\n        ...sentryXhrData.data,\n        type: 'xhr',\n        'http.method': sentryXhrData.method,\n        url: sentryXhrData.url,\n      },\n      description: `${sentryXhrData.method} ${sentryXhrData.url}`,\n      op: 'http.client',\n    });\n\n    xhr.__sentry_xhr_span_id__ = span.spanId;\n    spans[xhr.__sentry_xhr_span_id__] = span;\n\n    if (xhr.setRequestHeader && shouldAttachHeaders(sentryXhrData.url)) {\n      try {\n        xhr.setRequestHeader('sentry-trace', span.toTraceparent());\n\n        const dynamicSamplingContext = activeTransaction.getDynamicSamplingContext();\n        const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);\n\n        if (sentryBaggageHeader) {\n          // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n          // We can therefore simply set a baggage header without checking what was there before\n          // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n          xhr.setRequestHeader(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n        }\n      } catch (_) {\n        // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n      }\n    }\n\n    return span;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}