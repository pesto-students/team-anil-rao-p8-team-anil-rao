{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { logger } from '@sentry/utils';\nimport { wrapTransactionWithProfiling } from './hubextensions.js';\nimport { PROFILE_MAP, findProfiledTransactionsFromEnvelope, createProfilingEvent, addProfilesToEnvelope } from './utils.js';\n\n/**\n * Browser profiling integration. Stores any event that has contexts[\"profile\"][\"profile_id\"]\n * This exists because we do not want to await async profiler.stop calls as transaction.finish is called\n * in a synchronous context. Instead, we handle sending the profile async from the promise callback and\n * rely on being able to pull the event from the cache when we need to construct the envelope. This makes the\n * integration less reliable as we might be dropping profiles when the cache is full.\n *\n * @experimental\n */\nvar BrowserProfilingIntegration = /*#__PURE__*/function () {\n  function BrowserProfilingIntegration() {\n    _classCallCheck(this, BrowserProfilingIntegration);\n    BrowserProfilingIntegration.prototype.__init.call(this);\n    BrowserProfilingIntegration.prototype.__init2.call(this);\n  }\n  _createClass(BrowserProfilingIntegration, [{\n    key: \"__init\",\n    value: function __init() {\n      this.name = 'BrowserProfilingIntegration';\n    }\n  }, {\n    key: \"__init2\",\n    value: function __init2() {\n      this.getCurrentHub = undefined;\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"setupOnce\",\n    value: function setupOnce(addGlobalEventProcessor, getCurrentHub) {\n      this.getCurrentHub = getCurrentHub;\n      var client = this.getCurrentHub().getClient();\n      if (client && typeof client.on === 'function') {\n        client.on('startTransaction', function (transaction) {\n          wrapTransactionWithProfiling(transaction);\n        });\n        client.on('beforeEnvelope', function (envelope) {\n          // if not profiles are in queue, there is nothing to add to the envelope.\n          if (!PROFILE_MAP['size']) {\n            return;\n          }\n          var profiledTransactionEvents = findProfiledTransactionsFromEnvelope(envelope);\n          if (!profiledTransactionEvents.length) {\n            return;\n          }\n          var profilesToAddToEnvelope = [];\n          var _iterator = _createForOfIteratorHelper(profiledTransactionEvents),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var profiledTransaction = _step.value;\n              var context = profiledTransaction && profiledTransaction.contexts;\n              var profile_id = context && context['profile'] && context['profile']['profile_id'];\n              if (!profile_id) {\n                (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Profiling] cannot find profile for a transaction without a profile context');\n                continue;\n              }\n\n              // Remove the profile from the transaction context before sending, relay will take care of the rest.\n              if (context && context['profile']) {\n                delete context.profile;\n              }\n              var profile = PROFILE_MAP.get(profile_id);\n              if (!profile) {\n                (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(\"[Profiling] Could not retrieve profile for transaction: \".concat(profile_id));\n                continue;\n              }\n              PROFILE_MAP.delete(profile_id);\n              var profileEvent = createProfilingEvent(profile_id, profile, profiledTransaction);\n              if (profileEvent) {\n                profilesToAddToEnvelope.push(profileEvent);\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          addProfilesToEnvelope(envelope, profilesToAddToEnvelope);\n        });\n      } else {\n        logger.warn('[Profiling] Client does not support hooks, profiling will be disabled');\n      }\n    }\n  }]);\n  return BrowserProfilingIntegration;\n}();\nexport { BrowserProfilingIntegration };","map":{"version":3,"names":["BrowserProfilingIntegration","_classCallCheck","prototype","__init","call","__init2","_createClass","key","value","name","getCurrentHub","undefined","setupOnce","addGlobalEventProcessor","client","getClient","on","transaction","wrapTransactionWithProfiling","envelope","PROFILE_MAP","profiledTransactionEvents","findProfiledTransactionsFromEnvelope","length","profilesToAddToEnvelope","_iterator","_createForOfIteratorHelper","_step","s","n","done","profiledTransaction","context","contexts","profile_id","__SENTRY_DEBUG__","logger","log","profile","get","concat","delete","profileEvent","createProfilingEvent","push","err","e","f","addProfilesToEnvelope","warn"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/src/profiling/integration.ts"],"sourcesContent":["import type { EventProcessor, Hub, Integration, Transaction } from '@sentry/types';\nimport type { Profile } from '@sentry/types/src/profiling';\nimport { logger } from '@sentry/utils';\n\nimport type { BrowserClient } from './../client';\nimport { wrapTransactionWithProfiling } from './hubextensions';\nimport type { ProfiledEvent } from './utils';\nimport {\n  addProfilesToEnvelope,\n  createProfilingEvent,\n  findProfiledTransactionsFromEnvelope,\n  PROFILE_MAP,\n} from './utils';\n\n/**\n * Browser profiling integration. Stores any event that has contexts[\"profile\"][\"profile_id\"]\n * This exists because we do not want to await async profiler.stop calls as transaction.finish is called\n * in a synchronous context. Instead, we handle sending the profile async from the promise callback and\n * rely on being able to pull the event from the cache when we need to construct the envelope. This makes the\n * integration less reliable as we might be dropping profiles when the cache is full.\n *\n * @experimental\n */\nexport class BrowserProfilingIntegration implements Integration {\n  public readonly name: string = 'BrowserProfilingIntegration';\n  public getCurrentHub?: () => Hub = undefined;\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    this.getCurrentHub = getCurrentHub;\n    const client = this.getCurrentHub().getClient() as BrowserClient;\n\n    if (client && typeof client.on === 'function') {\n      client.on('startTransaction', (transaction: Transaction) => {\n        wrapTransactionWithProfiling(transaction);\n      });\n\n      client.on('beforeEnvelope', (envelope): void => {\n        // if not profiles are in queue, there is nothing to add to the envelope.\n        if (!PROFILE_MAP['size']) {\n          return;\n        }\n\n        const profiledTransactionEvents = findProfiledTransactionsFromEnvelope(envelope);\n        if (!profiledTransactionEvents.length) {\n          return;\n        }\n\n        const profilesToAddToEnvelope: Profile[] = [];\n\n        for (const profiledTransaction of profiledTransactionEvents) {\n          const context = profiledTransaction && profiledTransaction.contexts;\n          const profile_id = context && context['profile'] && (context['profile']['profile_id'] as string);\n\n          if (!profile_id) {\n            __DEBUG_BUILD__ &&\n              logger.log('[Profiling] cannot find profile for a transaction without a profile context');\n            continue;\n          }\n\n          // Remove the profile from the transaction context before sending, relay will take care of the rest.\n          if (context && context['profile']) {\n            delete context.profile;\n          }\n\n          const profile = PROFILE_MAP.get(profile_id);\n          if (!profile) {\n            __DEBUG_BUILD__ && logger.log(`[Profiling] Could not retrieve profile for transaction: ${profile_id}`);\n            continue;\n          }\n\n          PROFILE_MAP.delete(profile_id);\n          const profileEvent = createProfilingEvent(profile_id, profile, profiledTransaction as ProfiledEvent);\n\n          if (profileEvent) {\n            profilesToAddToEnvelope.push(profileEvent);\n          }\n        }\n\n        addProfilesToEnvelope(envelope, profilesToAddToEnvelope);\n      });\n    } else {\n      logger.warn('[Profiling] Client does not support hooks, profiling will be disabled');\n    }\n  }\n}\n"],"mappings":";;;;;;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA,IASAA,2BAAA;EAAA,SAAAA,4BAAA;IAAAC,eAAA,OAAAD,2BAAA;IAAAA,2BAAA,CAAAE,SAAA,CAAAC,MAAA,CAAAC,IAAA;IAAAJ,2BAAA,CAAAE,SAAA,CAAAG,OAAA,CAAAD,IAAA;EAAA;EAAAE,YAAA,CAAAN,2BAAA;IAAAO,GAAA;IAAAC,KAAA,EACA,SAAAL,OAAA;MAAA,KAAAM,IAAA;IAAA;EAAA;IAAAF,GAAA;IAAAC,KAAA,EACA,SAAAH,QAAA;MAAA,KAAAK,aAAA,GAAAC,SAAA;IAAA;;IAEA;AACA;AACA;EAFA;IAAAJ,GAAA;IAAAC,KAAA,EAGA,SAAAI,UAAAC,uBAAA,EAAAH,aAAA;MACA,KAAAA,aAAA,GAAAA,aAAA;MACA,IAAAI,MAAA,QAAAJ,aAAA,GAAAK,SAAA;MAEA,IAAAD,MAAA,WAAAA,MAAA,CAAAE,EAAA;QACAF,MAAA,CAAAE,EAAA,+BAAAC,WAAA;UACAC,4BAAA,CAAAD,WAAA;QACA;QAEAH,MAAA,CAAAE,EAAA,6BAAAG,QAAA;UACA;UACA,KAAAC,WAAA;YACA;UACA;UAEA,IAAAC,yBAAA,GAAAC,oCAAA,CAAAH,QAAA;UACA,KAAAE,yBAAA,CAAAE,MAAA;YACA;UACA;UAEA,IAAAC,uBAAA;UAAA,IAAAC,SAAA,GAAAC,0BAAA,CAEAL,yBAAA;YAAAM,KAAA;UAAA;YAAA,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA;cAAA,IAAAC,mBAAA,GAAAJ,KAAA,CAAAnB,KAAA;cACA,IAAAwB,OAAA,GAAAD,mBAAA,IAAAA,mBAAA,CAAAE,QAAA;cACA,IAAAC,UAAA,GAAAF,OAAA,IAAAA,OAAA,eAAAA,OAAA;cAEA,KAAAE,UAAA;gBACA,QAAAC,gBAAA,oBAAAA,gBAAA,KACAC,MAAA,CAAAC,GAAA;gBACA;cACA;;cAEA;cACA,IAAAL,OAAA,IAAAA,OAAA;gBACA,OAAAA,OAAA,CAAAM,OAAA;cACA;cAEA,IAAAA,OAAA,GAAAlB,WAAA,CAAAmB,GAAA,CAAAL,UAAA;cACA,KAAAI,OAAA;gBACA,QAAAH,gBAAA,oBAAAA,gBAAA,KAAAC,MAAA,CAAAC,GAAA,4DAAAG,MAAA,CAAAN,UAAA;gBACA;cACA;cAEAd,WAAA,CAAAqB,MAAA,CAAAP,UAAA;cACA,IAAAQ,YAAA,GAAAC,oBAAA,CAAAT,UAAA,EAAAI,OAAA,EAAAP,mBAAA;cAEA,IAAAW,YAAA;gBACAlB,uBAAA,CAAAoB,IAAA,CAAAF,YAAA;cACA;YACA;UAAA,SAAAG,GAAA;YAAApB,SAAA,CAAAqB,CAAA,CAAAD,GAAA;UAAA;YAAApB,SAAA,CAAAsB,CAAA;UAAA;UAEAC,qBAAA,CAAA7B,QAAA,EAAAK,uBAAA;QACA;MACA;QACAY,MAAA,CAAAa,IAAA;MACA;IACA;EAAA;EAAA,OAAAjD,2BAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}