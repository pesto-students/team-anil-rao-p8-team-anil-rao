{"ast":null,"code":"import { DEFAULT_ENVIRONMENT, getCurrentHub } from '@sentry/core';\nimport { forEachEnvelopeItem, logger, uuid4, GLOBAL_OBJ } from '@sentry/utils';\nimport { WINDOW } from '../helpers.js';\n\n/* eslint-disable max-lines */\n\nconst MS_TO_NS = 1e6;\n// Use 0 as main thread id which is identical to threadId in node:worker_threads\n// where main logs 0 and workers seem to log in increments of 1\nconst THREAD_ID_STRING = String(0);\nconst THREAD_NAME = 'main';\n\n// Machine properties (eval only once)\nlet OS_PLATFORM = '';\nlet OS_PLATFORM_VERSION = '';\nlet OS_ARCH = '';\nlet OS_BROWSER = WINDOW.navigator && WINDOW.navigator.userAgent || '';\nlet OS_MODEL = '';\nconst OS_LOCALE = WINDOW.navigator && WINDOW.navigator.language || WINDOW.navigator && WINDOW.navigator.languages && WINDOW.navigator.languages[0] || '';\nfunction isUserAgentData(data) {\n  return typeof data === 'object' && data !== null && 'getHighEntropyValues' in data;\n}\n\n// @ts-ignore userAgentData is not part of the navigator interface yet\nconst userAgentData = WINDOW.navigator && WINDOW.navigator.userAgentData;\nif (isUserAgentData(userAgentData)) {\n  userAgentData.getHighEntropyValues(['architecture', 'model', 'platform', 'platformVersion', 'fullVersionList']).then(ua => {\n    OS_PLATFORM = ua.platform || '';\n    OS_ARCH = ua.architecture || '';\n    OS_MODEL = ua.model || '';\n    OS_PLATFORM_VERSION = ua.platformVersion || '';\n    if (ua.fullVersionList && ua.fullVersionList.length > 0) {\n      const firstUa = ua.fullVersionList[ua.fullVersionList.length - 1];\n      OS_BROWSER = `${firstUa.brand} ${firstUa.version}`;\n    }\n  }).catch(e => void e);\n}\nfunction isProcessedJSSelfProfile(profile) {\n  return !('thread_metadata' in profile);\n}\n\n// Enriches the profile with threadId of the current thread.\n// This is done in node as we seem to not be able to get the info from C native code.\n/**\n *\n */\nfunction enrichWithThreadInformation(profile) {\n  if (!isProcessedJSSelfProfile(profile)) {\n    return profile;\n  }\n  return convertJSSelfProfileToSampledFormat(profile);\n}\n\n// Profile is marked as optional because it is deleted from the metadata\n// by the integration before the event is processed by other integrations.\n\nfunction getTraceId(event) {\n  const traceId = event && event.contexts && event.contexts['trace'] && event.contexts['trace']['trace_id'];\n  // Log a warning if the profile has an invalid traceId (should be uuidv4).\n  // All profiles and transactions are rejected if this is the case and we want to\n  // warn users that this is happening if they enable debug flag\n  if (typeof traceId === 'string' && traceId.length !== 32) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log(`[Profiling] Invalid traceId: ${traceId} on profiled event`);\n    }\n  }\n  if (typeof traceId !== 'string') {\n    return '';\n  }\n  return traceId;\n}\n/**\n * Creates a profiling event envelope from a Sentry event. If profile does not pass\n * validation, returns null.\n * @param event\n * @param dsn\n * @param metadata\n * @param tunnel\n * @returns {EventEnvelope | null}\n */\n\n/**\n * Creates a profiling event envelope from a Sentry event.\n */\nfunction createProfilePayload(event, processedProfile, profile_id) {\n  if (event.type !== 'transaction') {\n    // createProfilingEventEnvelope should only be called for transactions,\n    // we type guard this behavior with isProfiledTransactionEvent.\n    throw new TypeError('Profiling events may only be attached to transactions, this should never occur.');\n  }\n  if (processedProfile === undefined || processedProfile === null) {\n    throw new TypeError(`Cannot construct profiling event envelope without a valid profile. Got ${processedProfile} instead.`);\n  }\n  const traceId = getTraceId(event);\n  const enrichedThreadProfile = enrichWithThreadInformation(processedProfile);\n  const transactionStartMs = typeof event.start_timestamp === 'number' ? event.start_timestamp * 1000 : Date.now();\n  const transactionEndMs = typeof event.timestamp === 'number' ? event.timestamp * 1000 : Date.now();\n  const profile = {\n    event_id: profile_id,\n    timestamp: new Date(transactionStartMs).toISOString(),\n    platform: 'javascript',\n    version: '1',\n    release: event.release || '',\n    environment: event.environment || DEFAULT_ENVIRONMENT,\n    runtime: {\n      name: 'javascript',\n      version: WINDOW.navigator.userAgent\n    },\n    os: {\n      name: OS_PLATFORM,\n      version: OS_PLATFORM_VERSION,\n      build_number: OS_BROWSER\n    },\n    device: {\n      locale: OS_LOCALE,\n      model: OS_MODEL,\n      manufacturer: OS_BROWSER,\n      architecture: OS_ARCH,\n      is_emulator: false\n    },\n    debug_meta: {\n      images: applyDebugMetadata(processedProfile.resources)\n    },\n    profile: enrichedThreadProfile,\n    transactions: [{\n      name: event.transaction || '',\n      id: event.event_id || uuid4(),\n      trace_id: traceId,\n      active_thread_id: THREAD_ID_STRING,\n      relative_start_ns: '0',\n      relative_end_ns: ((transactionEndMs - transactionStartMs) * 1e6).toFixed(0)\n    }]\n  };\n  return profile;\n}\n\n/**\n * Converts a JSSelfProfile to a our sampled format.\n * Does not currently perform stack indexing.\n */\nfunction convertJSSelfProfileToSampledFormat(input) {\n  let EMPTY_STACK_ID = undefined;\n  let STACK_ID = 0;\n\n  // Initialize the profile that we will fill with data\n  const profile = {\n    samples: [],\n    stacks: [],\n    frames: [],\n    thread_metadata: {\n      [THREAD_ID_STRING]: {\n        name: THREAD_NAME\n      }\n    }\n  };\n  if (!input.samples.length) {\n    return profile;\n  }\n\n  // We assert samples.length > 0 above and timestamp should always be present\n  const start = input.samples[0].timestamp;\n  for (let i = 0; i < input.samples.length; i++) {\n    const jsSample = input.samples[i];\n\n    // If sample has no stack, add an empty sample\n    if (jsSample.stackId === undefined) {\n      if (EMPTY_STACK_ID === undefined) {\n        EMPTY_STACK_ID = STACK_ID;\n        profile.stacks[EMPTY_STACK_ID] = [];\n        STACK_ID++;\n      }\n      profile['samples'][i] = {\n        // convert ms timestamp to ns\n        elapsed_since_start_ns: ((jsSample.timestamp - start) * MS_TO_NS).toFixed(0),\n        stack_id: EMPTY_STACK_ID,\n        thread_id: THREAD_ID_STRING\n      };\n      continue;\n    }\n    let stackTop = input.stacks[jsSample.stackId];\n\n    // Functions in top->down order (root is last)\n    // We follow the stackTop.parentId trail and collect each visited frameId\n    const stack = [];\n    while (stackTop) {\n      stack.push(stackTop.frameId);\n      const frame = input.frames[stackTop.frameId];\n\n      // If our frame has not been indexed yet, index it\n      if (profile.frames[stackTop.frameId] === undefined) {\n        profile.frames[stackTop.frameId] = {\n          function: frame.name,\n          file: frame.resourceId ? input.resources[frame.resourceId] : undefined,\n          line: frame.line,\n          column: frame.column\n        };\n      }\n      stackTop = stackTop.parentId === undefined ? undefined : input.stacks[stackTop.parentId];\n    }\n    const sample = {\n      // convert ms timestamp to ns\n      elapsed_since_start_ns: ((jsSample.timestamp - start) * MS_TO_NS).toFixed(0),\n      stack_id: STACK_ID,\n      thread_id: THREAD_ID_STRING\n    };\n    profile['stacks'][STACK_ID] = stack;\n    profile['samples'][i] = sample;\n    STACK_ID++;\n  }\n  return profile;\n}\n\n/**\n * Adds items to envelope if they are not already present - mutates the envelope.\n * @param envelope\n */\nfunction addProfilesToEnvelope(envelope, profiles) {\n  if (!profiles.length) {\n    return envelope;\n  }\n  for (const profile of profiles) {\n    // @ts-ignore untyped envelope\n    envelope[1].push([{\n      type: 'profile'\n    }, profile]);\n  }\n  return envelope;\n}\n\n/**\n * Finds transactions with profile_id context in the envelope\n * @param envelope\n * @returns\n */\nfunction findProfiledTransactionsFromEnvelope(envelope) {\n  const events = [];\n  forEachEnvelopeItem(envelope, (item, type) => {\n    if (type !== 'transaction') {\n      return;\n    }\n    for (let j = 1; j < item.length; j++) {\n      const event = item[j];\n      if (event && event.contexts && event.contexts['profile'] && event.contexts['profile']['profile_id']) {\n        events.push(item[j]);\n      }\n    }\n  });\n  return events;\n}\nconst debugIdStackParserCache = new WeakMap();\n/**\n * Applies debug meta data to an event from a list of paths to resources (sourcemaps)\n */\nfunction applyDebugMetadata(resource_paths) {\n  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n  if (!debugIdMap) {\n    return [];\n  }\n  const hub = getCurrentHub();\n  if (!hub) {\n    return [];\n  }\n  const client = hub.getClient();\n  if (!client) {\n    return [];\n  }\n  const options = client.getOptions();\n  if (!options) {\n    return [];\n  }\n  const stackParser = options.stackParser;\n  if (!stackParser) {\n    return [];\n  }\n  let debugIdStackFramesCache;\n  const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);\n  if (cachedDebugIdStackFrameCache) {\n    debugIdStackFramesCache = cachedDebugIdStackFrameCache;\n  } else {\n    debugIdStackFramesCache = new Map();\n    debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);\n  }\n\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = Object.keys(debugIdMap).reduce((acc, debugIdStackTrace) => {\n    let parsedStack;\n    const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);\n    if (cachedParsedStack) {\n      parsedStack = cachedParsedStack;\n    } else {\n      parsedStack = stackParser(debugIdStackTrace);\n      debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);\n    }\n    for (let i = parsedStack.length - 1; i >= 0; i--) {\n      const stackFrame = parsedStack[i];\n      const file = stackFrame && stackFrame.filename;\n      if (stackFrame && file) {\n        acc[file] = debugIdMap[debugIdStackTrace];\n        break;\n      }\n    }\n    return acc;\n  }, {});\n  const images = [];\n  for (const path of resource_paths) {\n    if (path && filenameDebugIdMap[path]) {\n      images.push({\n        type: 'sourcemap',\n        code_file: path,\n        debug_id: filenameDebugIdMap[path]\n      });\n    }\n  }\n  return images;\n}\n\n/**\n * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).\n */\nfunction isValidSampleRate(rate) {\n  // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck\n  if (typeof rate !== 'number' && typeof rate !== 'boolean' || typeof rate === 'number' && isNaN(rate)) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`[Profiling] Invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(rate)} of type ${JSON.stringify(typeof rate)}.`);\n    return false;\n  }\n\n  // Boolean sample rates are always valid\n  if (rate === true || rate === false) {\n    return true;\n  }\n\n  // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false\n  if (rate < 0 || rate > 1) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`[Profiling] Invalid sample rate. Sample rate must be between 0 and 1. Got ${rate}.`);\n    return false;\n  }\n  return true;\n}\nfunction isValidProfile(profile) {\n  if (profile.samples.length < 2) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      // Log a warning if the profile has less than 2 samples so users can know why\n      // they are not seeing any profiling data and we cant avoid the back and forth\n      // of asking them to provide us with a dump of the profile data.\n      logger.log('[Profiling] Discarding profile because it contains less than 2 samples');\n    }\n    return false;\n  }\n  if (!profile.frames.length) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log('[Profiling] Discarding profile because it contains no frames');\n    }\n    return false;\n  }\n  return true;\n}\n\n/**\n * Creates a profiling envelope item, if the profile does not pass validation, returns null.\n * @param event\n * @returns {Profile | null}\n */\nfunction createProfilingEvent(profile_id, profile, event) {\n  if (!isValidProfile(profile)) {\n    return null;\n  }\n  return createProfilePayload(event, profile, profile_id);\n}\nconst PROFILE_MAP = new Map();\n/**\n *\n */\nfunction addProfileToMap(profile_id, profile) {\n  PROFILE_MAP.set(profile_id, profile);\n  if (PROFILE_MAP.size > 30) {\n    const last = PROFILE_MAP.keys().next().value;\n    PROFILE_MAP.delete(last);\n  }\n}\nexport { PROFILE_MAP, addProfileToMap, addProfilesToEnvelope, applyDebugMetadata, convertJSSelfProfileToSampledFormat, createProfilePayload, createProfilingEvent, enrichWithThreadInformation, findProfiledTransactionsFromEnvelope, isValidSampleRate };","map":{"version":3,"names":["MS_TO_NS","THREAD_ID_STRING","String","THREAD_NAME","OS_PLATFORM","OS_PLATFORM_VERSION","OS_ARCH","OS_BROWSER","WINDOW","navigator","userAgent","OS_MODEL","OS_LOCALE","language","languages","isUserAgentData","data","userAgentData","getHighEntropyValues","then","ua","platform","architecture","model","platformVersion","fullVersionList","length","firstUa","brand","version","catch","e","isProcessedJSSelfProfile","profile","enrichWithThreadInformation","convertJSSelfProfileToSampledFormat","getTraceId","event","traceId","contexts","__SENTRY_DEBUG__","logger","log","createProfilePayload","processedProfile","profile_id","type","TypeError","undefined","enrichedThreadProfile","transactionStartMs","start_timestamp","Date","now","transactionEndMs","timestamp","event_id","toISOString","release","environment","DEFAULT_ENVIRONMENT","runtime","name","os","build_number","device","locale","manufacturer","is_emulator","debug_meta","images","applyDebugMetadata","resources","transactions","transaction","id","uuid4","trace_id","active_thread_id","relative_start_ns","relative_end_ns","toFixed","input","EMPTY_STACK_ID","STACK_ID","samples","stacks","frames","thread_metadata","start","i","jsSample","stackId","elapsed_since_start_ns","stack_id","thread_id","stackTop","stack","push","frameId","frame","function","file","resourceId","line","column","parentId","sample","addProfilesToEnvelope","envelope","profiles","findProfiledTransactionsFromEnvelope","events","forEachEnvelopeItem","item","j","debugIdStackParserCache","WeakMap","resource_paths","debugIdMap","GLOBAL_OBJ","_sentryDebugIds","hub","getCurrentHub","client","getClient","options","getOptions","stackParser","debugIdStackFramesCache","cachedDebugIdStackFrameCache","get","Map","set","filenameDebugIdMap","Object","keys","reduce","acc","debugIdStackTrace","parsedStack","cachedParsedStack","stackFrame","filename","path","code_file","debug_id","isValidSampleRate","rate","isNaN","warn","JSON","stringify","isValidProfile","createProfilingEvent","PROFILE_MAP","addProfileToMap","size","last","next","value","delete"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/src/profiling/utils.ts"],"sourcesContent":["/* eslint-disable max-lines */\n\nimport { DEFAULT_ENVIRONMENT, getCurrentHub } from '@sentry/core';\nimport type { DebugImage, Envelope, Event, StackFrame, StackParser } from '@sentry/types';\nimport type { Profile, ThreadCpuProfile } from '@sentry/types/src/profiling';\nimport { forEachEnvelopeItem, GLOBAL_OBJ, logger, uuid4 } from '@sentry/utils';\n\nimport { WINDOW } from '../helpers';\nimport type { JSSelfProfile, JSSelfProfileStack } from './jsSelfProfiling';\n\nconst MS_TO_NS = 1e6;\n// Use 0 as main thread id which is identical to threadId in node:worker_threads\n// where main logs 0 and workers seem to log in increments of 1\nconst THREAD_ID_STRING = String(0);\nconst THREAD_NAME = 'main';\n\n// Machine properties (eval only once)\nlet OS_PLATFORM = '';\nlet OS_PLATFORM_VERSION = '';\nlet OS_ARCH = '';\nlet OS_BROWSER = (WINDOW.navigator && WINDOW.navigator.userAgent) || '';\nlet OS_MODEL = '';\nconst OS_LOCALE =\n  (WINDOW.navigator && WINDOW.navigator.language) ||\n  (WINDOW.navigator && WINDOW.navigator.languages && WINDOW.navigator.languages[0]) ||\n  '';\n\ntype UAData = {\n  platform?: string;\n  architecture?: string;\n  model?: string;\n  platformVersion?: string;\n  fullVersionList?: {\n    brand: string;\n    version: string;\n  }[];\n};\n\ninterface UserAgentData {\n  getHighEntropyValues: (keys: string[]) => Promise<UAData>;\n}\n\nfunction isUserAgentData(data: unknown): data is UserAgentData {\n  return typeof data === 'object' && data !== null && 'getHighEntropyValues' in data;\n}\n\n// @ts-ignore userAgentData is not part of the navigator interface yet\nconst userAgentData = WINDOW.navigator && WINDOW.navigator.userAgentData;\n\nif (isUserAgentData(userAgentData)) {\n  userAgentData\n    .getHighEntropyValues(['architecture', 'model', 'platform', 'platformVersion', 'fullVersionList'])\n    .then((ua: UAData) => {\n      OS_PLATFORM = ua.platform || '';\n      OS_ARCH = ua.architecture || '';\n      OS_MODEL = ua.model || '';\n      OS_PLATFORM_VERSION = ua.platformVersion || '';\n\n      if (ua.fullVersionList && ua.fullVersionList.length > 0) {\n        const firstUa = ua.fullVersionList[ua.fullVersionList.length - 1];\n        OS_BROWSER = `${firstUa.brand} ${firstUa.version}`;\n      }\n    })\n    .catch(e => void e);\n}\n\nfunction isProcessedJSSelfProfile(profile: ThreadCpuProfile | JSSelfProfile): profile is JSSelfProfile {\n  return !('thread_metadata' in profile);\n}\n\n// Enriches the profile with threadId of the current thread.\n// This is done in node as we seem to not be able to get the info from C native code.\n/**\n *\n */\nexport function enrichWithThreadInformation(profile: ThreadCpuProfile | JSSelfProfile): ThreadCpuProfile {\n  if (!isProcessedJSSelfProfile(profile)) {\n    return profile;\n  }\n\n  return convertJSSelfProfileToSampledFormat(profile);\n}\n\n// Profile is marked as optional because it is deleted from the metadata\n// by the integration before the event is processed by other integrations.\nexport interface ProfiledEvent extends Event {\n  sdkProcessingMetadata: {\n    profile?: JSSelfProfile;\n  };\n}\n\nfunction getTraceId(event: Event): string {\n  const traceId: unknown = event && event.contexts && event.contexts['trace'] && event.contexts['trace']['trace_id'];\n  // Log a warning if the profile has an invalid traceId (should be uuidv4).\n  // All profiles and transactions are rejected if this is the case and we want to\n  // warn users that this is happening if they enable debug flag\n  if (typeof traceId === 'string' && traceId.length !== 32) {\n    if (__DEBUG_BUILD__) {\n      logger.log(`[Profiling] Invalid traceId: ${traceId} on profiled event`);\n    }\n  }\n  if (typeof traceId !== 'string') {\n    return '';\n  }\n\n  return traceId;\n}\n/**\n * Creates a profiling event envelope from a Sentry event. If profile does not pass\n * validation, returns null.\n * @param event\n * @param dsn\n * @param metadata\n * @param tunnel\n * @returns {EventEnvelope | null}\n */\n\n/**\n * Creates a profiling event envelope from a Sentry event.\n */\nexport function createProfilePayload(\n  event: ProfiledEvent,\n  processedProfile: JSSelfProfile,\n  profile_id: string,\n): Profile {\n  if (event.type !== 'transaction') {\n    // createProfilingEventEnvelope should only be called for transactions,\n    // we type guard this behavior with isProfiledTransactionEvent.\n    throw new TypeError('Profiling events may only be attached to transactions, this should never occur.');\n  }\n\n  if (processedProfile === undefined || processedProfile === null) {\n    throw new TypeError(\n      `Cannot construct profiling event envelope without a valid profile. Got ${processedProfile} instead.`,\n    );\n  }\n\n  const traceId = getTraceId(event);\n  const enrichedThreadProfile = enrichWithThreadInformation(processedProfile);\n  const transactionStartMs = typeof event.start_timestamp === 'number' ? event.start_timestamp * 1000 : Date.now();\n  const transactionEndMs = typeof event.timestamp === 'number' ? event.timestamp * 1000 : Date.now();\n\n  const profile: Profile = {\n    event_id: profile_id,\n    timestamp: new Date(transactionStartMs).toISOString(),\n    platform: 'javascript',\n    version: '1',\n    release: event.release || '',\n    environment: event.environment || DEFAULT_ENVIRONMENT,\n    runtime: {\n      name: 'javascript',\n      version: WINDOW.navigator.userAgent,\n    },\n    os: {\n      name: OS_PLATFORM,\n      version: OS_PLATFORM_VERSION,\n      build_number: OS_BROWSER,\n    },\n    device: {\n      locale: OS_LOCALE,\n      model: OS_MODEL,\n      manufacturer: OS_BROWSER,\n      architecture: OS_ARCH,\n      is_emulator: false,\n    },\n    debug_meta: {\n      images: applyDebugMetadata(processedProfile.resources),\n    },\n    profile: enrichedThreadProfile,\n    transactions: [\n      {\n        name: event.transaction || '',\n        id: event.event_id || uuid4(),\n        trace_id: traceId,\n        active_thread_id: THREAD_ID_STRING,\n        relative_start_ns: '0',\n        relative_end_ns: ((transactionEndMs - transactionStartMs) * 1e6).toFixed(0),\n      },\n    ],\n  };\n\n  return profile;\n}\n\n/**\n *\n */\nexport function isProfiledTransactionEvent(event: Event): event is ProfiledEvent {\n  return !!(event.sdkProcessingMetadata && event.sdkProcessingMetadata['profile']);\n}\n\n/**\n * Converts a JSSelfProfile to a our sampled format.\n * Does not currently perform stack indexing.\n */\nexport function convertJSSelfProfileToSampledFormat(input: JSSelfProfile): Profile['profile'] {\n  let EMPTY_STACK_ID: undefined | number = undefined;\n  let STACK_ID = 0;\n\n  // Initialize the profile that we will fill with data\n  const profile: Profile['profile'] = {\n    samples: [],\n    stacks: [],\n    frames: [],\n    thread_metadata: {\n      [THREAD_ID_STRING]: { name: THREAD_NAME },\n    },\n  };\n\n  if (!input.samples.length) {\n    return profile;\n  }\n\n  // We assert samples.length > 0 above and timestamp should always be present\n  const start = input.samples[0].timestamp;\n\n  for (let i = 0; i < input.samples.length; i++) {\n    const jsSample = input.samples[i];\n\n    // If sample has no stack, add an empty sample\n    if (jsSample.stackId === undefined) {\n      if (EMPTY_STACK_ID === undefined) {\n        EMPTY_STACK_ID = STACK_ID;\n        profile.stacks[EMPTY_STACK_ID] = [];\n        STACK_ID++;\n      }\n\n      profile['samples'][i] = {\n        // convert ms timestamp to ns\n        elapsed_since_start_ns: ((jsSample.timestamp - start) * MS_TO_NS).toFixed(0),\n        stack_id: EMPTY_STACK_ID,\n        thread_id: THREAD_ID_STRING,\n      };\n      continue;\n    }\n\n    let stackTop: JSSelfProfileStack | undefined = input.stacks[jsSample.stackId];\n\n    // Functions in top->down order (root is last)\n    // We follow the stackTop.parentId trail and collect each visited frameId\n    const stack: number[] = [];\n\n    while (stackTop) {\n      stack.push(stackTop.frameId);\n\n      const frame = input.frames[stackTop.frameId];\n\n      // If our frame has not been indexed yet, index it\n      if (profile.frames[stackTop.frameId] === undefined) {\n        profile.frames[stackTop.frameId] = {\n          function: frame.name,\n          file: frame.resourceId ? input.resources[frame.resourceId] : undefined,\n          line: frame.line,\n          column: frame.column,\n        };\n      }\n\n      stackTop = stackTop.parentId === undefined ? undefined : input.stacks[stackTop.parentId];\n    }\n\n    const sample: Profile['profile']['samples'][0] = {\n      // convert ms timestamp to ns\n      elapsed_since_start_ns: ((jsSample.timestamp - start) * MS_TO_NS).toFixed(0),\n      stack_id: STACK_ID,\n      thread_id: THREAD_ID_STRING,\n    };\n\n    profile['stacks'][STACK_ID] = stack;\n    profile['samples'][i] = sample;\n    STACK_ID++;\n  }\n\n  return profile;\n}\n\n/**\n * Adds items to envelope if they are not already present - mutates the envelope.\n * @param envelope\n */\nexport function addProfilesToEnvelope(envelope: Envelope, profiles: Profile[]): Envelope {\n  if (!profiles.length) {\n    return envelope;\n  }\n\n  for (const profile of profiles) {\n    // @ts-ignore untyped envelope\n    envelope[1].push([{ type: 'profile' }, profile]);\n  }\n  return envelope;\n}\n\n/**\n * Finds transactions with profile_id context in the envelope\n * @param envelope\n * @returns\n */\nexport function findProfiledTransactionsFromEnvelope(envelope: Envelope): Event[] {\n  const events: Event[] = [];\n\n  forEachEnvelopeItem(envelope, (item, type) => {\n    if (type !== 'transaction') {\n      return;\n    }\n\n    for (let j = 1; j < item.length; j++) {\n      const event = item[j] as Event;\n\n      if (event && event.contexts && event.contexts['profile'] && event.contexts['profile']['profile_id']) {\n        events.push(item[j] as Event);\n      }\n    }\n  });\n\n  return events;\n}\n\nconst debugIdStackParserCache = new WeakMap<StackParser, Map<string, StackFrame[]>>();\n/**\n * Applies debug meta data to an event from a list of paths to resources (sourcemaps)\n */\nexport function applyDebugMetadata(resource_paths: ReadonlyArray<string>): DebugImage[] {\n  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n\n  if (!debugIdMap) {\n    return [];\n  }\n\n  const hub = getCurrentHub();\n  if (!hub) {\n    return [];\n  }\n  const client = hub.getClient();\n  if (!client) {\n    return [];\n  }\n  const options = client.getOptions();\n  if (!options) {\n    return [];\n  }\n  const stackParser = options.stackParser;\n  if (!stackParser) {\n    return [];\n  }\n\n  let debugIdStackFramesCache: Map<string, StackFrame[]>;\n  const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);\n  if (cachedDebugIdStackFrameCache) {\n    debugIdStackFramesCache = cachedDebugIdStackFrameCache;\n  } else {\n    debugIdStackFramesCache = new Map<string, StackFrame[]>();\n    debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);\n  }\n\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = Object.keys(debugIdMap).reduce<Record<string, string>>((acc, debugIdStackTrace) => {\n    let parsedStack: StackFrame[];\n\n    const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);\n    if (cachedParsedStack) {\n      parsedStack = cachedParsedStack;\n    } else {\n      parsedStack = stackParser(debugIdStackTrace);\n      debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);\n    }\n\n    for (let i = parsedStack.length - 1; i >= 0; i--) {\n      const stackFrame = parsedStack[i];\n      const file = stackFrame && stackFrame.filename;\n\n      if (stackFrame && file) {\n        acc[file] = debugIdMap[debugIdStackTrace] as string;\n        break;\n      }\n    }\n    return acc;\n  }, {});\n\n  const images: DebugImage[] = [];\n  for (const path of resource_paths) {\n    if (path && filenameDebugIdMap[path]) {\n      images.push({\n        type: 'sourcemap',\n        code_file: path,\n        debug_id: filenameDebugIdMap[path] as string,\n      });\n    }\n  }\n\n  return images;\n}\n\n/**\n * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).\n */\nexport function isValidSampleRate(rate: unknown): boolean {\n  // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck\n  if ((typeof rate !== 'number' && typeof rate !== 'boolean') || (typeof rate === 'number' && isNaN(rate))) {\n    __DEBUG_BUILD__ &&\n      logger.warn(\n        `[Profiling] Invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(\n          rate,\n        )} of type ${JSON.stringify(typeof rate)}.`,\n      );\n    return false;\n  }\n\n  // Boolean sample rates are always valid\n  if (rate === true || rate === false) {\n    return true;\n  }\n\n  // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false\n  if (rate < 0 || rate > 1) {\n    __DEBUG_BUILD__ &&\n      logger.warn(`[Profiling] Invalid sample rate. Sample rate must be between 0 and 1. Got ${rate}.`);\n    return false;\n  }\n  return true;\n}\n\nfunction isValidProfile(profile: JSSelfProfile): profile is JSSelfProfile & { profile_id: string } {\n  if (profile.samples.length < 2) {\n    if (__DEBUG_BUILD__) {\n      // Log a warning if the profile has less than 2 samples so users can know why\n      // they are not seeing any profiling data and we cant avoid the back and forth\n      // of asking them to provide us with a dump of the profile data.\n      logger.log('[Profiling] Discarding profile because it contains less than 2 samples');\n    }\n    return false;\n  }\n\n  if (!profile.frames.length) {\n    if (__DEBUG_BUILD__) {\n      logger.log('[Profiling] Discarding profile because it contains no frames');\n    }\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Creates a profiling envelope item, if the profile does not pass validation, returns null.\n * @param event\n * @returns {Profile | null}\n */\nexport function createProfilingEvent(profile_id: string, profile: JSSelfProfile, event: ProfiledEvent): Profile | null {\n  if (!isValidProfile(profile)) {\n    return null;\n  }\n\n  return createProfilePayload(event, profile, profile_id);\n}\n\nexport const PROFILE_MAP: Map<string, JSSelfProfile> = new Map();\n/**\n *\n */\nexport function addProfileToMap(profile_id: string, profile: JSSelfProfile): void {\n  PROFILE_MAP.set(profile_id, profile);\n\n  if (PROFILE_MAP.size > 30) {\n    const last: string = PROFILE_MAP.keys().next().value;\n    PROFILE_MAP.delete(last);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}