{"ast":null,"code":"import _slicedToArray from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { logger } from './logger.js';\n\n/** Regular expression used to parse a Dsn. */\nvar DSN_REGEX = /^(?:(\\w+):)\\/\\/(?:(\\w+)(?::(\\w+)?)?@)([\\w.-]+)(?::(\\d+))?\\/(.+)/;\nfunction isValidProtocol(protocol) {\n  return protocol === 'http' || protocol === 'https';\n}\n\n/**\n * Renders the string representation of this Dsn.\n *\n * By default, this will render the public representation without the password\n * component. To get the deprecated private representation, set `withPassword`\n * to true.\n *\n * @param withPassword When set to true, the password will be included.\n */\nfunction dsnToString(dsn) {\n  var withPassword = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var host = dsn.host,\n    path = dsn.path,\n    pass = dsn.pass,\n    port = dsn.port,\n    projectId = dsn.projectId,\n    protocol = dsn.protocol,\n    publicKey = dsn.publicKey;\n  return \"\".concat(protocol, \"://\").concat(publicKey).concat(withPassword && pass ? \":\".concat(pass) : '') + \"@\".concat(host).concat(port ? \":\".concat(port) : '', \"/\").concat(path ? \"\".concat(path, \"/\") : path).concat(projectId);\n}\n\n/**\n * Parses a Dsn from a given string.\n *\n * @param str A Dsn as string\n * @returns Dsn as DsnComponents or undefined if @param str is not a valid DSN string\n */\nfunction dsnFromString(str) {\n  var match = DSN_REGEX.exec(str);\n  if (!match) {\n    // This should be logged to the console\n    // eslint-disable-next-line no-console\n    console.error(\"Invalid Sentry Dsn: \".concat(str));\n    return undefined;\n  }\n  var _match$slice = match.slice(1),\n    _match$slice2 = _slicedToArray(_match$slice, 6),\n    protocol = _match$slice2[0],\n    publicKey = _match$slice2[1],\n    _match$slice2$ = _match$slice2[2],\n    pass = _match$slice2$ === void 0 ? '' : _match$slice2$,\n    host = _match$slice2[3],\n    _match$slice2$2 = _match$slice2[4],\n    port = _match$slice2$2 === void 0 ? '' : _match$slice2$2,\n    lastPath = _match$slice2[5];\n  var path = '';\n  var projectId = lastPath;\n  var split = projectId.split('/');\n  if (split.length > 1) {\n    path = split.slice(0, -1).join('/');\n    projectId = split.pop();\n  }\n  if (projectId) {\n    var projectMatch = projectId.match(/^\\d+/);\n    if (projectMatch) {\n      projectId = projectMatch[0];\n    }\n  }\n  return dsnFromComponents({\n    host: host,\n    pass: pass,\n    path: path,\n    projectId: projectId,\n    port: port,\n    protocol: protocol,\n    publicKey: publicKey\n  });\n}\nfunction dsnFromComponents(components) {\n  return {\n    protocol: components.protocol,\n    publicKey: components.publicKey || '',\n    pass: components.pass || '',\n    host: components.host,\n    port: components.port || '',\n    path: components.path || '',\n    projectId: components.projectId\n  };\n}\nfunction validateDsn(dsn) {\n  if (!(typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n    return true;\n  }\n  var port = dsn.port,\n    projectId = dsn.projectId,\n    protocol = dsn.protocol;\n  var requiredComponents = ['protocol', 'publicKey', 'host', 'projectId'];\n  var hasMissingRequiredComponent = requiredComponents.find(function (component) {\n    if (!dsn[component]) {\n      logger.error(\"Invalid Sentry Dsn: \".concat(component, \" missing\"));\n      return true;\n    }\n    return false;\n  });\n  if (hasMissingRequiredComponent) {\n    return false;\n  }\n  if (!projectId.match(/^\\d+$/)) {\n    logger.error(\"Invalid Sentry Dsn: Invalid projectId \".concat(projectId));\n    return false;\n  }\n  if (!isValidProtocol(protocol)) {\n    logger.error(\"Invalid Sentry Dsn: Invalid protocol \".concat(protocol));\n    return false;\n  }\n  if (port && isNaN(parseInt(port, 10))) {\n    logger.error(\"Invalid Sentry Dsn: Invalid port \".concat(port));\n    return false;\n  }\n  return true;\n}\n\n/**\n * Creates a valid Sentry Dsn object, identifying a Sentry instance and project.\n * @returns a valid DsnComponents object or `undefined` if @param from is an invalid DSN source\n */\nfunction makeDsn(from) {\n  var components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);\n  if (!components || !validateDsn(components)) {\n    return undefined;\n  }\n  return components;\n}\nexport { dsnFromString, dsnToString, makeDsn };","map":{"version":3,"names":["DSN_REGEX","isValidProtocol","protocol","dsnToString","dsn","withPassword","arguments","length","undefined","host","path","pass","port","projectId","publicKey","concat","dsnFromString","str","match","exec","console","error","_match$slice","slice","_match$slice2","_slicedToArray","_match$slice2$","_match$slice2$2","lastPath","split","join","pop","projectMatch","dsnFromComponents","components","validateDsn","__SENTRY_DEBUG__","requiredComponents","hasMissingRequiredComponent","find","component","logger","isNaN","parseInt","makeDsn","from"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/dsn.ts"],"sourcesContent":["import type { DsnComponents, DsnLike, DsnProtocol } from '@sentry/types';\n\nimport { logger } from './logger';\n\n/** Regular expression used to parse a Dsn. */\nconst DSN_REGEX = /^(?:(\\w+):)\\/\\/(?:(\\w+)(?::(\\w+)?)?@)([\\w.-]+)(?::(\\d+))?\\/(.+)/;\n\nfunction isValidProtocol(protocol?: string): protocol is DsnProtocol {\n  return protocol === 'http' || protocol === 'https';\n}\n\n/**\n * Renders the string representation of this Dsn.\n *\n * By default, this will render the public representation without the password\n * component. To get the deprecated private representation, set `withPassword`\n * to true.\n *\n * @param withPassword When set to true, the password will be included.\n */\nexport function dsnToString(dsn: DsnComponents, withPassword: boolean = false): string {\n  const { host, path, pass, port, projectId, protocol, publicKey } = dsn;\n  return (\n    `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ''}` +\n    `@${host}${port ? `:${port}` : ''}/${path ? `${path}/` : path}${projectId}`\n  );\n}\n\n/**\n * Parses a Dsn from a given string.\n *\n * @param str A Dsn as string\n * @returns Dsn as DsnComponents or undefined if @param str is not a valid DSN string\n */\nexport function dsnFromString(str: string): DsnComponents | undefined {\n  const match = DSN_REGEX.exec(str);\n\n  if (!match) {\n    // This should be logged to the console\n    // eslint-disable-next-line no-console\n    console.error(`Invalid Sentry Dsn: ${str}`);\n    return undefined;\n  }\n\n  const [protocol, publicKey, pass = '', host, port = '', lastPath] = match.slice(1);\n  let path = '';\n  let projectId = lastPath;\n\n  const split = projectId.split('/');\n  if (split.length > 1) {\n    path = split.slice(0, -1).join('/');\n    projectId = split.pop() as string;\n  }\n\n  if (projectId) {\n    const projectMatch = projectId.match(/^\\d+/);\n    if (projectMatch) {\n      projectId = projectMatch[0];\n    }\n  }\n\n  return dsnFromComponents({ host, pass, path, projectId, port, protocol: protocol as DsnProtocol, publicKey });\n}\n\nfunction dsnFromComponents(components: DsnComponents): DsnComponents {\n  return {\n    protocol: components.protocol,\n    publicKey: components.publicKey || '',\n    pass: components.pass || '',\n    host: components.host,\n    port: components.port || '',\n    path: components.path || '',\n    projectId: components.projectId,\n  };\n}\n\nfunction validateDsn(dsn: DsnComponents): boolean {\n  if (!__DEBUG_BUILD__) {\n    return true;\n  }\n\n  const { port, projectId, protocol } = dsn;\n\n  const requiredComponents: ReadonlyArray<keyof DsnComponents> = ['protocol', 'publicKey', 'host', 'projectId'];\n  const hasMissingRequiredComponent = requiredComponents.find(component => {\n    if (!dsn[component]) {\n      logger.error(`Invalid Sentry Dsn: ${component} missing`);\n      return true;\n    }\n    return false;\n  });\n\n  if (hasMissingRequiredComponent) {\n    return false;\n  }\n\n  if (!projectId.match(/^\\d+$/)) {\n    logger.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);\n    return false;\n  }\n\n  if (!isValidProtocol(protocol)) {\n    logger.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);\n    return false;\n  }\n\n  if (port && isNaN(parseInt(port, 10))) {\n    logger.error(`Invalid Sentry Dsn: Invalid port ${port}`);\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Creates a valid Sentry Dsn object, identifying a Sentry instance and project.\n * @returns a valid DsnComponents object or `undefined` if @param from is an invalid DSN source\n */\nexport function makeDsn(from: DsnLike): DsnComponents | undefined {\n  const components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);\n  if (!components || !validateDsn(components)) {\n    return undefined;\n  }\n  return components;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}