{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _assertThisInitialized from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _classCallCheck from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { logger, timestampInSeconds } from '@sentry/utils';\nimport { SpanRecorder } from './span.js';\nimport { Transaction } from './transaction.js';\nvar TRACING_DEFAULTS = {\n  idleTimeout: 1000,\n  finalTimeout: 30000,\n  heartbeatInterval: 5000\n};\nvar FINISH_REASON_TAG = 'finishReason';\nvar IDLE_TRANSACTION_FINISH_REASONS = ['heartbeatFailed', 'idleTimeout', 'documentHidden', 'finalTimeout', 'externalFinish', 'cancelled'];\n\n/**\n * @inheritDoc\n */\nvar IdleTransactionSpanRecorder = /*#__PURE__*/function (_SpanRecorder) {\n  _inherits(IdleTransactionSpanRecorder, _SpanRecorder);\n  var _super = _createSuper(IdleTransactionSpanRecorder);\n  function IdleTransactionSpanRecorder(_pushActivity, _popActivity, transactionSpanId, maxlen) {\n    var _this;\n    _classCallCheck(this, IdleTransactionSpanRecorder);\n    _this = _super.call(this, maxlen);\n    _this._pushActivity = _pushActivity;\n    _this._popActivity = _popActivity;\n    _this.transactionSpanId = transactionSpanId;\n    return _this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  _createClass(IdleTransactionSpanRecorder, [{\n    key: \"add\",\n    value: function add(span) {\n      var _this2 = this;\n      // We should make sure we do not push and pop activities for\n      // the transaction that this span recorder belongs to.\n      if (span.spanId !== this.transactionSpanId) {\n        // We patch span.finish() to pop an activity after setting an endTimestamp.\n        span.finish = function (endTimestamp) {\n          span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampInSeconds();\n          _this2._popActivity(span.spanId);\n        };\n\n        // We should only push new activities if the span does not have an end timestamp.\n        if (span.endTimestamp === undefined) {\n          this._pushActivity(span.spanId);\n        }\n      }\n      _get(_getPrototypeOf(IdleTransactionSpanRecorder.prototype), \"add\", this).call(this, span);\n    }\n  }]);\n  return IdleTransactionSpanRecorder;\n}(SpanRecorder);\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nvar IdleTransaction = /*#__PURE__*/function (_Transaction) {\n  _inherits(IdleTransaction, _Transaction);\n  var _super2 = _createSuper(IdleTransaction);\n  function IdleTransaction(transactionContext, _idleHub) {\n    var _this3;\n    var _idleTimeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TRACING_DEFAULTS.idleTimeout;\n    var _finalTimeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TRACING_DEFAULTS.finalTimeout;\n    var _heartbeatInterval = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : TRACING_DEFAULTS.heartbeatInterval;\n    var _onScope = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    _classCallCheck(this, IdleTransaction);\n    _this3 = _super2.call(this, transactionContext, _idleHub);\n    _this3._idleHub = _idleHub;\n    _this3._idleTimeout = _idleTimeout;\n    _this3._finalTimeout = _finalTimeout;\n    _this3._heartbeatInterval = _heartbeatInterval;\n    _this3._onScope = _onScope;\n    IdleTransaction.prototype.__init.call(_assertThisInitialized(_this3));\n    IdleTransaction.prototype.__init2.call(_assertThisInitialized(_this3));\n    IdleTransaction.prototype.__init3.call(_assertThisInitialized(_this3));\n    IdleTransaction.prototype.__init4.call(_assertThisInitialized(_this3));\n    IdleTransaction.prototype.__init5.call(_assertThisInitialized(_this3));\n    IdleTransaction.prototype.__init6.call(_assertThisInitialized(_this3));\n    if (_onScope) {\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(\"Setting idle transaction on scope. Span ID: \".concat(_this3.spanId));\n      _idleHub.configureScope(function (scope) {\n        return scope.setSpan(_assertThisInitialized(_this3));\n      });\n    }\n    _this3._restartIdleTimeout();\n    setTimeout(function () {\n      if (!_this3._finished) {\n        _this3.setStatus('deadline_exceeded');\n        _this3._finishReason = IDLE_TRANSACTION_FINISH_REASONS[3];\n        _this3.finish();\n      }\n    }, _this3._finalTimeout);\n    return _this3;\n  }\n\n  /** {@inheritDoc} */\n  _createClass(IdleTransaction, [{\n    key: \"__init\",\n    value:\n    // Activities store a list of active spans\n    function __init() {\n      this.activities = {};\n    }\n\n    // Track state of activities in previous heartbeat\n\n    // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n  }, {\n    key: \"__init2\",\n    value: function __init2() {\n      this._heartbeatCounter = 0;\n    }\n\n    // We should not use heartbeat if we finished a transaction\n  }, {\n    key: \"__init3\",\n    value: function __init3() {\n      this._finished = false;\n    }\n\n    // Idle timeout was canceled and we should finish the transaction with the last span end.\n  }, {\n    key: \"__init4\",\n    value: function __init4() {\n      this._idleTimeoutCanceledPermanently = false;\n    }\n  }, {\n    key: \"__init5\",\n    value: function __init5() {\n      this._beforeFinishCallbacks = [];\n    }\n\n    /**\n     * Timer that tracks Transaction idleTimeout\n     */\n  }, {\n    key: \"__init6\",\n    value: function __init6() {\n      this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[4];\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      var _this4 = this;\n      var endTimestamp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : timestampInSeconds();\n      this._finished = true;\n      this.activities = {};\n      if (this.op === 'ui.action.click') {\n        this.setTag(FINISH_REASON_TAG, this._finishReason);\n      }\n      if (this.spanRecorder) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n        var _iterator = _createForOfIteratorHelper(this._beforeFinishCallbacks),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var callback = _step.value;\n            callback(this, endTimestamp);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        this.spanRecorder.spans = this.spanRecorder.spans.filter(function (span) {\n          // If we are dealing with the transaction itself, we just return it\n          if (span.spanId === _this4.spanId) {\n            return true;\n          }\n\n          // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n          if (!span.endTimestamp) {\n            span.endTimestamp = endTimestamp;\n            span.setStatus('cancelled');\n            (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n          }\n          var keepSpan = span.startTimestamp < endTimestamp;\n          if (!keepSpan) {\n            (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] discarding Span since it happened after Transaction was finished', JSON.stringify(span, undefined, 2));\n          }\n          return keepSpan;\n        });\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] flushing IdleTransaction');\n      } else {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] No active IdleTransaction');\n      }\n\n      // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n      if (this._onScope) {\n        var scope = this._idleHub.getScope();\n        if (scope.getTransaction() === this) {\n          scope.setSpan(undefined);\n        }\n      }\n      return _get(_getPrototypeOf(IdleTransaction.prototype), \"finish\", this).call(this, endTimestamp);\n    }\n\n    /**\n     * Register a callback function that gets excecuted before the transaction finishes.\n     * Useful for cleanup or if you want to add any additional spans based on current context.\n     *\n     * This is exposed because users have no other way of running something before an idle transaction\n     * finishes.\n     */\n  }, {\n    key: \"registerBeforeFinishCallback\",\n    value: function registerBeforeFinishCallback(callback) {\n      this._beforeFinishCallbacks.push(callback);\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"initSpanRecorder\",\n    value: function initSpanRecorder(maxlen) {\n      var _this5 = this;\n      if (!this.spanRecorder) {\n        var pushActivity = function pushActivity(id) {\n          if (_this5._finished) {\n            return;\n          }\n          _this5._pushActivity(id);\n        };\n        var popActivity = function popActivity(id) {\n          if (_this5._finished) {\n            return;\n          }\n          _this5._popActivity(id);\n        };\n        this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);\n\n        // Start heartbeat so that transactions do not run forever.\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('Starting heartbeat');\n        this._pingHeartbeat();\n      }\n      this.spanRecorder.add(this);\n    }\n\n    /**\n     * Cancels the existing idle timeout, if there is one.\n     * @param restartOnChildSpanChange Default is `true`.\n     *                                 If set to false the transaction will end\n     *                                 with the last child span.\n     */\n  }, {\n    key: \"cancelIdleTimeout\",\n    value: function cancelIdleTimeout(endTimestamp) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n          restartOnChildSpanChange: true\n        },\n        restartOnChildSpanChange = _ref.restartOnChildSpanChange;\n      this._idleTimeoutCanceledPermanently = restartOnChildSpanChange === false;\n      if (this._idleTimeoutID) {\n        clearTimeout(this._idleTimeoutID);\n        this._idleTimeoutID = undefined;\n        if (Object.keys(this.activities).length === 0 && this._idleTimeoutCanceledPermanently) {\n          this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];\n          this.finish(endTimestamp);\n        }\n      }\n    }\n\n    /**\n     * Temporary method used to externally set the transaction's `finishReason`\n     *\n     * ** WARNING**\n     * This is for the purpose of experimentation only and will be removed in the near future, do not use!\n     *\n     * @internal\n     *\n     */\n  }, {\n    key: \"setFinishReason\",\n    value: function setFinishReason(reason) {\n      this._finishReason = reason;\n    }\n\n    /**\n     * Restarts idle timeout, if there is no running idle timeout it will start one.\n     */\n  }, {\n    key: \"_restartIdleTimeout\",\n    value: function _restartIdleTimeout(endTimestamp) {\n      var _this6 = this;\n      this.cancelIdleTimeout();\n      this._idleTimeoutID = setTimeout(function () {\n        if (!_this6._finished && Object.keys(_this6.activities).length === 0) {\n          _this6._finishReason = IDLE_TRANSACTION_FINISH_REASONS[1];\n          _this6.finish(endTimestamp);\n        }\n      }, this._idleTimeout);\n    }\n\n    /**\n     * Start tracking a specific activity.\n     * @param spanId The span id that represents the activity\n     */\n  }, {\n    key: \"_pushActivity\",\n    value: function _pushActivity(spanId) {\n      this.cancelIdleTimeout(undefined, {\n        restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently\n      });\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(\"[Tracing] pushActivity: \".concat(spanId));\n      this.activities[spanId] = true;\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n\n    /**\n     * Remove an activity from usage\n     * @param spanId The span id that represents the activity\n     */\n  }, {\n    key: \"_popActivity\",\n    value: function _popActivity(spanId) {\n      if (this.activities[spanId]) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(\"[Tracing] popActivity \".concat(spanId));\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete this.activities[spanId];\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n      }\n      if (Object.keys(this.activities).length === 0) {\n        var endTimestamp = timestampInSeconds();\n        if (this._idleTimeoutCanceledPermanently) {\n          this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];\n          this.finish(endTimestamp);\n        } else {\n          // We need to add the timeout here to have the real endtimestamp of the transaction\n          // Remember timestampInSeconds is in seconds, timeout is in ms\n          this._restartIdleTimeout(endTimestamp + this._idleTimeout / 1000);\n        }\n      }\n    }\n\n    /**\n     * Checks when entries of this.activities are not changing for 3 beats.\n     * If this occurs we finish the transaction.\n     */\n  }, {\n    key: \"_beat\",\n    value: function _beat() {\n      // We should not be running heartbeat if the idle transaction is finished.\n      if (this._finished) {\n        return;\n      }\n      var heartbeatString = Object.keys(this.activities).join('');\n      if (heartbeatString === this._prevHeartbeatString) {\n        this._heartbeatCounter++;\n      } else {\n        this._heartbeatCounter = 1;\n      }\n      this._prevHeartbeatString = heartbeatString;\n      if (this._heartbeatCounter >= 3) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n        this.setStatus('deadline_exceeded');\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[0];\n        this.finish();\n      } else {\n        this._pingHeartbeat();\n      }\n    }\n\n    /**\n     * Pings the heartbeat\n     */\n  }, {\n    key: \"_pingHeartbeat\",\n    value: function _pingHeartbeat() {\n      var _this7 = this;\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(\"pinging Heartbeat -> current counter: \".concat(this._heartbeatCounter));\n      setTimeout(function () {\n        _this7._beat();\n      }, this._heartbeatInterval);\n    }\n  }]);\n  return IdleTransaction;\n}(Transaction);\nexport { IdleTransaction, IdleTransactionSpanRecorder, TRACING_DEFAULTS };","map":{"version":3,"names":["TRACING_DEFAULTS","idleTimeout","finalTimeout","heartbeatInterval","FINISH_REASON_TAG","IDLE_TRANSACTION_FINISH_REASONS","IdleTransactionSpanRecorder","_SpanRecorder","_inherits","_super","_createSuper","_pushActivity","_popActivity","transactionSpanId","maxlen","_this","_classCallCheck","call","_createClass","key","value","add","span","_this2","spanId","finish","endTimestamp","timestampInSeconds","undefined","_get","_getPrototypeOf","prototype","SpanRecorder","IdleTransaction","_Transaction","_super2","transactionContext","_idleHub","_this3","_idleTimeout","arguments","length","_finalTimeout","_heartbeatInterval","_onScope","__init","_assertThisInitialized","__init2","__init3","__init4","__init5","__init6","__SENTRY_DEBUG__","logger","log","concat","configureScope","scope","setSpan","_restartIdleTimeout","setTimeout","_finished","setStatus","_finishReason","activities","_heartbeatCounter","_idleTimeoutCanceledPermanently","_beforeFinishCallbacks","_this4","op","setTag","spanRecorder","Date","toISOString","_iterator","_createForOfIteratorHelper","_step","s","n","done","callback","err","e","f","spans","filter","JSON","stringify","keepSpan","startTimestamp","getScope","getTransaction","registerBeforeFinishCallback","push","initSpanRecorder","_this5","pushActivity","id","popActivity","_pingHeartbeat","cancelIdleTimeout","_ref","restartOnChildSpanChange","_idleTimeoutID","clearTimeout","Object","keys","setFinishReason","reason","_this6","_beat","heartbeatString","join","_prevHeartbeatString","_this7","Transaction"],"sources":["/Users/chirag_vaid/Desktop/Pesto/team-anil-rao-p8-team-anil-rao/node_modules/@sentry/src/tracing/idletransaction.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type { TransactionContext } from '@sentry/types';\nimport { logger, timestampInSeconds } from '@sentry/utils';\n\nimport type { Hub } from '../hub';\nimport type { Span } from './span';\nimport { SpanRecorder } from './span';\nimport { Transaction } from './transaction';\n\nexport const TRACING_DEFAULTS = {\n  idleTimeout: 1000,\n  finalTimeout: 30000,\n  heartbeatInterval: 5000,\n};\n\nconst FINISH_REASON_TAG = 'finishReason';\n\nconst IDLE_TRANSACTION_FINISH_REASONS = [\n  'heartbeatFailed',\n  'idleTimeout',\n  'documentHidden',\n  'finalTimeout',\n  'externalFinish',\n  'cancelled',\n];\n\n/**\n * @inheritDoc\n */\nexport class IdleTransactionSpanRecorder extends SpanRecorder {\n  public constructor(\n    private readonly _pushActivity: (id: string) => void,\n    private readonly _popActivity: (id: string) => void,\n    public transactionSpanId: string,\n    maxlen?: number,\n  ) {\n    super(maxlen);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public add(span: Span): void {\n    // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n    if (span.spanId !== this.transactionSpanId) {\n      // We patch span.finish() to pop an activity after setting an endTimestamp.\n      span.finish = (endTimestamp?: number) => {\n        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampInSeconds();\n        this._popActivity(span.spanId);\n      };\n\n      // We should only push new activities if the span does not have an end timestamp.\n      if (span.endTimestamp === undefined) {\n        this._pushActivity(span.spanId);\n      }\n    }\n\n    super.add(span);\n  }\n}\n\nexport type BeforeFinishCallback = (transactionSpan: IdleTransaction, endTimestamp: number) => void;\n\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nexport class IdleTransaction extends Transaction {\n  // Activities store a list of active spans\n  public activities: Record<string, boolean> = {};\n\n  // Track state of activities in previous heartbeat\n  private _prevHeartbeatString: string | undefined;\n\n  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n  private _heartbeatCounter: number = 0;\n\n  // We should not use heartbeat if we finished a transaction\n  private _finished: boolean = false;\n\n  // Idle timeout was canceled and we should finish the transaction with the last span end.\n  private _idleTimeoutCanceledPermanently: boolean = false;\n\n  private readonly _beforeFinishCallbacks: BeforeFinishCallback[] = [];\n\n  /**\n   * Timer that tracks Transaction idleTimeout\n   */\n  private _idleTimeoutID: ReturnType<typeof setTimeout> | undefined;\n\n  private _finishReason: (typeof IDLE_TRANSACTION_FINISH_REASONS)[number] = IDLE_TRANSACTION_FINISH_REASONS[4];\n\n  public constructor(\n    transactionContext: TransactionContext,\n    private readonly _idleHub: Hub,\n    /**\n     * The time to wait in ms until the idle transaction will be finished. This timer is started each time\n     * there are no active spans on this transaction.\n     */\n    private readonly _idleTimeout: number = TRACING_DEFAULTS.idleTimeout,\n    /**\n     * The final value in ms that a transaction cannot exceed\n     */\n    private readonly _finalTimeout: number = TRACING_DEFAULTS.finalTimeout,\n    private readonly _heartbeatInterval: number = TRACING_DEFAULTS.heartbeatInterval,\n    // Whether or not the transaction should put itself on the scope when it starts and pop itself off when it ends\n    private readonly _onScope: boolean = false,\n  ) {\n    super(transactionContext, _idleHub);\n\n    if (_onScope) {\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      __DEBUG_BUILD__ && logger.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`);\n      _idleHub.configureScope(scope => scope.setSpan(this));\n    }\n\n    this._restartIdleTimeout();\n    setTimeout(() => {\n      if (!this._finished) {\n        this.setStatus('deadline_exceeded');\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[3];\n        this.finish();\n      }\n    }, this._finalTimeout);\n  }\n\n  /** {@inheritDoc} */\n  public finish(endTimestamp: number = timestampInSeconds()): string | undefined {\n    this._finished = true;\n    this.activities = {};\n\n    if (this.op === 'ui.action.click') {\n      this.setTag(FINISH_REASON_TAG, this._finishReason);\n    }\n\n    if (this.spanRecorder) {\n      __DEBUG_BUILD__ &&\n        logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n\n      for (const callback of this._beforeFinishCallbacks) {\n        callback(this, endTimestamp);\n      }\n\n      this.spanRecorder.spans = this.spanRecorder.spans.filter((span: Span) => {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanId === this.spanId) {\n          return true;\n        }\n\n        // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n        if (!span.endTimestamp) {\n          span.endTimestamp = endTimestamp;\n          span.setStatus('cancelled');\n          __DEBUG_BUILD__ &&\n            logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n\n        const keepSpan = span.startTimestamp < endTimestamp;\n        if (!keepSpan) {\n          __DEBUG_BUILD__ &&\n            logger.log(\n              '[Tracing] discarding Span since it happened after Transaction was finished',\n              JSON.stringify(span, undefined, 2),\n            );\n        }\n        return keepSpan;\n      });\n\n      __DEBUG_BUILD__ && logger.log('[Tracing] flushing IdleTransaction');\n    } else {\n      __DEBUG_BUILD__ && logger.log('[Tracing] No active IdleTransaction');\n    }\n\n    // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n    if (this._onScope) {\n      const scope = this._idleHub.getScope();\n      if (scope.getTransaction() === this) {\n        scope.setSpan(undefined);\n      }\n    }\n\n    return super.finish(endTimestamp);\n  }\n\n  /**\n   * Register a callback function that gets excecuted before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n  public registerBeforeFinishCallback(callback: BeforeFinishCallback): void {\n    this._beforeFinishCallbacks.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public initSpanRecorder(maxlen?: number): void {\n    if (!this.spanRecorder) {\n      const pushActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._pushActivity(id);\n      };\n      const popActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._popActivity(id);\n      };\n\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);\n\n      // Start heartbeat so that transactions do not run forever.\n      __DEBUG_BUILD__ && logger.log('Starting heartbeat');\n      this._pingHeartbeat();\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Cancels the existing idle timeout, if there is one.\n   * @param restartOnChildSpanChange Default is `true`.\n   *                                 If set to false the transaction will end\n   *                                 with the last child span.\n   */\n  public cancelIdleTimeout(\n    endTimestamp?: Parameters<IdleTransaction['finish']>[0],\n    {\n      restartOnChildSpanChange,\n    }: {\n      restartOnChildSpanChange?: boolean;\n    } = {\n      restartOnChildSpanChange: true,\n    },\n  ): void {\n    this._idleTimeoutCanceledPermanently = restartOnChildSpanChange === false;\n    if (this._idleTimeoutID) {\n      clearTimeout(this._idleTimeoutID);\n      this._idleTimeoutID = undefined;\n\n      if (Object.keys(this.activities).length === 0 && this._idleTimeoutCanceledPermanently) {\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];\n        this.finish(endTimestamp);\n      }\n    }\n  }\n\n  /**\n   * Temporary method used to externally set the transaction's `finishReason`\n   *\n   * ** WARNING**\n   * This is for the purpose of experimentation only and will be removed in the near future, do not use!\n   *\n   * @internal\n   *\n   */\n  public setFinishReason(reason: string): void {\n    this._finishReason = reason;\n  }\n\n  /**\n   * Restarts idle timeout, if there is no running idle timeout it will start one.\n   */\n  private _restartIdleTimeout(endTimestamp?: Parameters<IdleTransaction['finish']>[0]): void {\n    this.cancelIdleTimeout();\n    this._idleTimeoutID = setTimeout(() => {\n      if (!this._finished && Object.keys(this.activities).length === 0) {\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[1];\n        this.finish(endTimestamp);\n      }\n    }, this._idleTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  private _pushActivity(spanId: string): void {\n    this.cancelIdleTimeout(undefined, { restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently });\n    __DEBUG_BUILD__ && logger.log(`[Tracing] pushActivity: ${spanId}`);\n    this.activities[spanId] = true;\n    __DEBUG_BUILD__ && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  private _popActivity(spanId: string): void {\n    if (this.activities[spanId]) {\n      __DEBUG_BUILD__ && logger.log(`[Tracing] popActivity ${spanId}`);\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this.activities[spanId];\n      __DEBUG_BUILD__ && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n\n    if (Object.keys(this.activities).length === 0) {\n      const endTimestamp = timestampInSeconds();\n      if (this._idleTimeoutCanceledPermanently) {\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];\n        this.finish(endTimestamp);\n      } else {\n        // We need to add the timeout here to have the real endtimestamp of the transaction\n        // Remember timestampInSeconds is in seconds, timeout is in ms\n        this._restartIdleTimeout(endTimestamp + this._idleTimeout / 1000);\n      }\n    }\n  }\n\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n  private _beat(): void {\n    // We should not be running heartbeat if the idle transaction is finished.\n    if (this._finished) {\n      return;\n    }\n\n    const heartbeatString = Object.keys(this.activities).join('');\n\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter++;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n\n    this._prevHeartbeatString = heartbeatString;\n\n    if (this._heartbeatCounter >= 3) {\n      __DEBUG_BUILD__ && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n      this.setStatus('deadline_exceeded');\n      this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[0];\n      this.finish();\n    } else {\n      this._pingHeartbeat();\n    }\n  }\n\n  /**\n   * Pings the heartbeat\n   */\n  private _pingHeartbeat(): void {\n    __DEBUG_BUILD__ && logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);\n    setTimeout(() => {\n      this._beat();\n    }, this._heartbeatInterval);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}